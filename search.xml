<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python学习记录]]></title>
    <url>%2F2019%2F12%2F12%2FPython%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[第一部分 Python基础知识 Python简介及特性Python+PyCharm集成开发环境Python基本语法Python变量类型Python运算符Python条件语句Python循环语句Number/字符串/列表/元组Python字典DictionaryPython日期和时间Python函数Python模块Python文件I/OPython文件/目录相关的方法Python内置函数Python列表解析式和生成器Python调用其他py文件的函数Python替换函数和split函数Python字符串&amp;元组&amp;列表&amp;字典互转 第二部分 Python进阶学习 Python异常处理Python面向对象Python+Pillow实现图片处理（对比/裁剪/…）Python&amp;MySQLPython简易GUI界面模块EasyGUI将python文件打包为exe文件Python跳出多重循环Python修改文件指定行Python爬取js动态生成的网页信息Python SMTP发送邮件Python爬虫学习过程（First）Python爬虫学习过程（Second）BeautifulSoup用法简列PyQt4&amp;QtDesigner学习过程（First）PyQt4&amp;QtDesigner学习过程（Second）使用paramiko执行远程Linux主机命令 第三部分 Python项目实战 云来后台UI自动化工具Python项目小工具开发（针对目前项目APP）线上纸白银价格自动监测小工具Python通过HTTP接口模拟用户注册基于项目对测试工具二次开发（First）基于项目对测试工具二次开发（Second）]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云来后台UI自动化工具]]></title>
    <url>%2F2019%2F02%2F15%2F%E4%BA%91%E6%9D%A5%E5%90%8E%E5%8F%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[工具功能说明：方便每天早上的快速巡检 工具实现的整体步骤：1.用PyQt designer设计界面及设计信号和槽2.结合python selenium库对商户后台进行元素定位及代码编写3.把两部分代码相互调用结合4.设计交互方式，优化工作使用交互5.用Pyinstaller打包成可执行程序文件6.校验程序可用性，是否正常可使用程序界面 实现效果界面动图如下 代码及程序目录：https://pan.baidu.com/s/1vxTU3H3QUPc5qQNYexFU0w 本次实现参考文献：selenium 上传文件方法补充——SendKeys、win32gui如何使用python+selenium向富文本编辑器输入内容有关PyQt界面卡顿的解决方案大全怎么让QLineEdit中只能输入数字？QLineEdit加入正则判断IPPyQt分离UI主线程与工作线程PyQt UI与后台逻辑操作线程分离(PyQt登陆窗口设计为例讲解)使用PyQt4写界面后台程序方法总结]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium利用Cookie自动登录]]></title>
    <url>%2F2018%2F04%2F18%2FSelenium%E5%88%A9%E7%94%A8Cookie%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[webdriver可以读取并添加cookie，所以可以通过这点进行自动登陆。有很多系统的登陆信息都是保存在cookie里的，因此只要往cookie中添加正确的值就可以实现自动登陆了 操作的方法：1.访问地址，通过浏览器进行密码保存，确认再次访问该地址是否直接登录2.通过调试器确认cookie信息，对应信息则为需要add-cookie的内容 3.代码里进行调用，如下： 1234567891011121314# -*- coding: utf-8 -*-from selenium import webbrowseriverfrom time import sleepbrowser = webbrowseriver.Chrome()url = 'http://120.24.67.22:8072/JieWebAdmin/index.xhtml'browser.get(url)browser.delete_all_cookies()# 添加获取的Cookie所有值browser.add_cookie(&#123;'name': 'JSESSIONID', 'value': 'D25351129******0E6E11F56'&#125;)browser.add_cookie(&#123;'name': '80*********BD42', 'value': 'n***'&#125;)browser.add_cookie(&#123;'name': 'n***8n', 'value': '0*****8'&#125;)browser.refresh()sleep(3) 4.完成自动登录的操作]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium模拟手机端访问]]></title>
    <url>%2F2018%2F04%2F17%2FSelenium%E6%A8%A1%E6%8B%9F%E6%89%8B%E6%9C%BA%E7%AB%AF%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[Chrome浏览器支持移动端调试，所以可以使用python调用Webdriver的Chrome浏览器驱动，并设置对应的options就可以实现浏览器打开后为移动端模式 1.简单模式，指定对应设备： 12345678910111213# -*- coding:utf-8 -*- import time from selenium import webdriver from selenium.webdriver.chrome.options import Options mobile_emulation = &#123;"deviceName":"Google Nexus 5"&#125; chrome_options = Options() chrome_options.add_experimental_option("mobileEmulation", mobile_emulation) driver = webdriver.Chrome(chrome_options = chrome_options) driver.get("http://www.baidu.com") time.sleep(5) driver.close() 2.设置设备具体的高宽等： 123456789101112# -*- coding: utf-8 -*-from selenium import webdriverfrom time import sleepUserAgent = 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1'mobileEmulation = &#123;"deviceMetrics": &#123;"width": 375, "height": 812, "pixelRatio": 3.0&#125;, "userAgent": UserAgent&#125;options = webdriver.ChromeOptions()options.add_experimental_option('mobileEmulation', mobileEmulation)driver = webdriver.Chrome(executable_path='chromedriver.exe', chrome_options=options)driver.get('http://jenkins.lend51.com:8072/JieWapApp/VxinWebApp/index.html#/')sleep(3)driver.close() 3.通过Unittest单元测试框架： 12345678910111213def setUp(self): mobileEmulation = &#123; "deviceMetrics": &#123;"width": 375, "height": 812, "pixelRatio": 3.0&#125;, "userAgent": 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1' &#125; options = webdriver.ChromeOptions() options.add_experimental_option('mobileEmulation', mobileEmulation) self.driver = webdriver.Chrome(executable_path='chromedriver.exe', chrome_options=options) self.driver.implicitly_wait(30) self.driver.delete_all_cookies() self.base_url = "http://jenkins.lend51.com:8072/JieWapApp/VxinWebApp/index.html#/" self.verificationErrors = [] self.accept_next_alert = True]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium-Unittest测试框架]]></title>
    <url>%2F2018%2F04%2F16%2FSelenium-Unittest%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Selenium IDESelenium IDE是Firefox浏览器插件，可快速对网页进行记录/回放/编辑和调试测试 注： Selenium IDE在最新版本Firefox上已经有新的界面样式，实际已不支持，会出现脚本运行白屏，所以要安装Firefox55以下的版本 安装方式：1.Firebox版本安装：http://ftp.mozilla.org/pub/firefox/releases/2.在Firebox中打开http://seleniumhq.org/download/ ，提示需最新浏览器才可安装，对应进入详情查找2.9.1的老版本，进行插件安装3.重启浏览器生效 IDE界面介绍： 第1模块：菜单栏 文件：创建、打开和保存测试案例和测试案例集编辑：复制、粘贴、删除、撤销和选择测试案例中的所有命令Actions： 对Actions进行操作Options：用于设置seleniunm IDE帮助：IDE的使用帮助 第2模块：被测网站的地址 第3模块：Actions操作快捷键 运行所有：运行一个测试suite的case运行当前case：运行当前选定的case暂停/恢复：暂停和恢复case执行单步：运行一个case中的一行命令应用汇总规则：此高级功能允许将一连串的Selenium命令组合为单个操作。有关汇总规则的详细文档，请参见“帮助”菜单上的“UI元素文档”录制：点击之后，开始记录你对浏览器的操作速度控制：控制case的运行速度 第4模块：案例集列表 第5模块：脚本编辑区 测试脚本展示：table标签，用表格形式展现命令及参数；source标签，用原始方式展现，默认是HTML语言格式，也可以用其他语言展示命令参数编辑：选择脚本中的一行，可以选择编辑命令、key值、value值 第6模块：脚本运行通过/失败的个数 第7模块：日志/参考/UI元素/Rollup 日志：当你运行测试时，错误和信息将会自定显示参考：当在表格中输入和编辑selenese命令时，面板中会显示对应的参考文档UI元素/Rollup：参考帮助菜单中的，UI-Element Documentation 引入Unittest框架通过seleinium IDE完成脚本的录制后，将其导出为unittest单元测试框架的相应脚本 将脚本导出后，一定要对元素的定位进行确认并修改正确如下为导出后的脚本，对应各部分的说明以备注形式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# -*- coding: utf-8 -*-from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support.ui import Selectfrom selenium.common.exceptions import NoSuchElementExceptionfrom selenium.common.exceptions import NoAlertPresentException# 引入unittest框架包import unittest, time, re# Baidu类继承unittest.TestCase类，从TestCase类继承是告诉unittest模块，这是一个测试案例class Baidu(unittest.TestCase): # setUp用于设置初始化，在测试用例执行前，这个方法中的函数将先被调用，这里将浏览器的调用和Url的访问放在初始化部分 def setUp(self): self.driver = webdriver.Firefox() self.driver.implicitly_wait(30) self.base_url = "https://www.baidu.com/" # 脚本运行时，错误的信息将被打印到这个列表中 self.verificationErrors = [] # 是否继续接受下一个警告 self.accept_next_alert = True # 放置测试脚本，这里也就是需要调试的部分 def test_baidu(self): driver = self.driver driver.get(self.base_url) driver.find_element_by_class_name('soutu-btn').click() driver.implicitly_wait(4) driver.find_element_by_class_name('upload-pic').send_keys('C:\\Users\\admin\\Desktop\\a.png') driver.implicitly_wait(10) text = driver.find_element_by_class_name('imglist-active').text print text # is_element_present函数用来查找页面元素是否存在，在这里用处不大，通常删除，因为判断页面元素一般都加在testcase中 def is_element_present(self, how, what): try: self.driver.find_element(by=how, value=what) except NoSuchElementException as e: return False return True # 对弹窗异常的处理 def is_alert_present(self): try: self.driver.switch_to_alert() except NoAlertPresentException as e: return False return True # 关闭警告以及对得到文本框的处理 def close_alert_and_get_its_text(self): try: alert = self.driver.switch_to_alert() alert_text = alert.text if self.accept_next_alert: alert.accept() else: alert.dismiss() return alert_text finally: self.accept_next_alert = True # tearDown方法在每个测试方法执行后调用，这个地方做所有测试用例执行完成的清理工作，如退出浏览器等 def tearDown(self): self.driver.quit() # 对前面verificationErrors方法获得的列表进行比较；如不为空，输出列表中的报错信息 self.assertEqual([], self.verificationErrors)if __name__ == "__main__": # unitest.main()函数用来测试类中以test开头的测试用例 unittest.main() 直接运行后报如下两类错误： WebDriverException: Message: Missing ‘type’ parameterWebDriverException: Message: Expected [object Undefined] undefined to be a string 原因：selenium版本和火狐浏览器driver不兼容，需要更新对应https://github.com/mozilla/geckodriver/releases解决后版本对应：Selenium_v3.11.0 / geckodriver_v0.20.0 批量执行测试用例unittest框架支持在一个.py文件里编写多个测试用例并可执行，但用例很多情况下，放一.py 文件显然有些不太合理比较合理的做法是把相关的几条用例放到一个.py文件里，把所有.py文件放到一个文件夹下，然后通过一个程序执行文件夹下面的所有用例 所以构建如下结构： 调用执行文件夹用例的test_case.py： 123456789101112# !/usr/bin/env python# -*- coding:utf-8 -*-import os# 列出某个文件夹下的所有case,这里用的是python，# 所在py 文件运行一次后会生成一个pyc 的副本caselist = os.listdir('E:\\Python\\Learn\\Selenium\\Unittest\\test_case')for a in caselist: # 选取后缀名为py 的文件 s = a.split('.')[1] if s == 'py': # 此处执行dos 命令并将结果保存到log.txt os.system('E:\\Python\\Learn\\Selenium\\Unittest\\test_case\\%s 1&gt;&gt;log.txt 2&gt;&amp;1' % a) 解释下代码中的方法： os.listdir(Path)函数 获得指定目录中的内容 os.system(‘Path\%s 1&gt;&gt;log.txt 2&gt;&amp;1’ %a)函数，把目录下的文件执行，并将执行结果保存到log.txt文件中 split()函数 用于字符串分割 引入测试报告与结构优化生成HTMLTestRunner测试报告 HTMLTestRunner是Python标准库的unittest模块的一个扩展。它生成易于使用的HTML 测试报告下载地址：http://tungwaiyip.info/software/HTMLTestRunner.html 操作步骤：1.将文件内容另存并放置在Python27/Lib目录下2.导入模块HTMLTestRunner3.修改程序的主函数if __name__ == &quot;__main__&quot;: 123456789101112131415161718if __name__ == "__main__": # 定义一个单元测试容器 testunit = unittest.TestSuite() # 将测试用例加入到测试容器中 testunit.addTest(Baidu("test_baidu")) testunit.addTest(Baidu("test_register")) # 定义个报告存放路径，支持相对路径 filename = 'E:\\Python\\Learn\\Selenium\\Unittest\\result.html' fp = file(filename, 'wb') # 定义测试报告 runner = HTMLTestRunner.HTMLTestRunner( # stream定义报告所写入的文件；title为报告标题；description为说明与描述 stream=fp, title=u'百度测试报告', description=u'用例执行情况：' ) # 运行测试容器中的用例，并将结果写入的报告中 runner.run(testunit) 修改程序后，如果直接在Pycharm运行的话，没有正常写入html，原因和解决方式如下：原因：PyCharm会默认使用自带的unittest框架来执行单元测试，不会执行main函数中的代码，所以不生成测试报告解决方式：1.点击PyCharm中上方的Uittest in xxx.py下拉框，选择“编辑结构”； 2.在Python结构下新增Python格式文件，在Script选择对应目录； 3.再次执行可生效形成HTML 测试套件 引入测试套件，实现之前的构建结构，一个测试套件包含多个python文件，每个python文件包含多个用例 在同一目录下新建一个py文件，引入所有测试文件，再引用HTMLTestRunner来生成报告 1234567891011121314151617181920# !/usr/bin/env python# -*- coding:utf-8 -*-import unittestimport baidu, Processonimport HTMLTestRunnertestunit = unittest.TestSuite()# 将测试用例加入到测试容器(套件)中testunit.addTest(unittest.makeSuite(baidu.Baidu))testunit.addTest(unittest.makeSuite(Processon.Processon))filename = 'E:\\Python\\Learn\\Selenium\\Unittest\\test_case\\result.html'fp = file(filename, 'wb')runner = HTMLTestRunner.HTMLTestRunner( stream=fp, title=u'百度测试报告', description=u'用例执行情况：')runner.run(testunit) 解释下代码，这里用到了unittest的makeSuite：用于生产testsuite对象的实例，把所有的测试用例组装成TestSuite，最后把TestSuite传给TestRunner进行执行 优化测试报告报告中用例添加注释 123456... # 百度图片 def test_baidu(self): u'''百度识图''' driver = self.driver... 效果如下： 报告标题添加时间 1234import timenow = time.strftime("%Y-%m-%d-%H%M%S", time.localtime(time.time()))filename = 'E:\\Python\\Learn\\Selenium\\Unittest\\test_case\\'+'result'+now+'.html' 效果如下： 对selenium的学习到这里暂告一段落 后续主要还是以实际工作，对多线程的学习，多浏览器兼容，邮件发送等方面入手]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium简介及Webdriver-API]]></title>
    <url>%2F2018%2F04%2F12%2FSelenium%E7%AE%80%E4%BB%8B%E5%8F%8AWebdriver-API%2F</url>
    <content type="text"><![CDATA[Selenium的学习主要是通过课程以及文档，如下仅对学习过程中觉得必要的部分进行记录 学习课程和资料如下：pdf文档：https://pan.baidu.com/s/1RopxU8YAT_Y6q6IPllo_lA安装selenium：pip install -U selenium 什么是selenium？ Selenium主要是用于Web应用程序的自动化测试，但肯定不只局限于此，同时支持所有基于web的管理任务自动化 Selenium的特点： 开源，免费 多浏览器支持：FireFox、Chrome、IE、Opera 多平台支持：linux、windows、MAC 多语言支持：java、python、ruby、php、C#、JavaScript 对web页面有良好的支持 简单（API 简单）、灵活（用开发语言驱动） 支持分布式测试用例执行 Selenium的主要组成部分： selenium IDE selenium IDE 是嵌入到Firefox浏览器中的一个插件，实现简单的浏览器操作的录制与回放功能IDE录制的脚本可以可以转换成多种语言，从而帮助我们快速的开发脚本 selenium Grid Selenium Grid是一种自动化的测试辅助工具，Grid通过利用现有的计算机基础设施，能加快Web-app的功能测试。利用Grid，可以很方便地同时在多台机器上和异构环境中并行运行多个测试事例。其特点为：1.并行执行2.通过一个主机统一控制用例在不同环境、不同浏览器下运行3.灵活添加变动测试机 selenium RC Selenium RC在selenium3.0开始已经废弃，所以不理会 selenium WebDriver WebDriver是selenium RC的替代品，因为selenium为了向下兼容性WebDriver通过原生浏览器支持或者浏览器扩展直接控制浏览器。针对各个浏览器而开发，取代了嵌入到被测Web 应用中的JavaScript。与浏览器的紧密集成支持创建更高级的测试，避免了JavaScript安全模型导致的限制。除了来自浏览器厂商的支持，WebDriver还利用操作系统级的调用模拟用户输入 Python webdriver API如下将针对web页面上各种元素、弹窗的定位与操作，以及浏览器cookie的操作，JavaScript的调用等问题进行开展学习 公共部分： 123from selenium import webdriverbrowser = webdriver.Chrome()browser.get("http://www.baidu.com") 浏览器的操作浏览器最大化： browser.maximize_window()设置浏览器宽/高： browser.set_window_size(480, 800)关闭单一窗口： browser.close()关闭所有相关窗口/退出程序： browser.quit()刷新窗口页面： browser.refresh()控制浏览器前进/后退： 12345678910111213141516# !/usr/bin/env python# -*- coding:utf-8 -*-from selenium import webdriverimport timebrowser = webdriver.Chrome()url1 = 'http://www.sohu.com'url2 = 'http://www.baidu.com'browser.get(url1)time.sleep(3)browser.get(url2)browser.back() # 返回到sohu首页time.sleep(2)browser.forward() # 前进到baidu首页browser.quit() 简单对象的定位webdriver提供了一系列的元素定位方法，常用的有以下几种： .find_element_by_id() .find_element_by_name() .find_element_by_class_name() 通过class属性对元素进行定位 .find_element_by_tag_name() .find_element_by_link_text() 通过完整链接文案进行定位 .find_element_by_partial_link_text() 通过部分特定链接文案进行定位 .find_element_by_xpath() .find_element_by_css_selector() 操作测试对象Webdriver中常用的操作元素的方法如下，在元素定位后引用： .clear 清除元素的内容，如果可以的话 .send_keys 在元素上模拟按键输入 .click 单击元素 .submit 提交表单 注：编码问题，send_keys()方法中输入中文时，需要在脚本开头声明编码为utf-8，然后在中文字符的前面加个小u 就可解决 # coding=utf-8.send_keys(u”中文内容”) WebElement接口常用方法，在元素定位后引用： .size 返回元素的尺寸 .text 获取元素的文本 .get_attribute(name) 获得属性值 .is_displayed() 设置该元素是否用户可见 实例： 12345678910111213141516171819202122# !/usr/bin/env python# -*- coding:utf-8 -*-from selenium import webdriverimport timebrowser = webdriver.Chrome()url = 'http://www.baidu.com'browser.get(url)# 返回百度输入狂的宽高size = browser.find_element_by_id('kw').size# 返回百度页面底部备案信息text = browser.find_element_by_id("cp").text# 返回元素的属性值，可以是id、name、type 或元素拥有的其它任意属性attribute = browser.find_element_by_id("kw").get_attribute('type')# 返回元素的结果是否可见，返回结果为True或Falseresult = browser.find_element_by_id("kw").is_displayed()print sizeprint textprint attributeprint resultbrowser.quit() 鼠标事件有关鼠标的操作，不单单只有单击.Click，还有右击，双击，拖动等操作，这些操作包含在ActionChains类中 ActionChains类鼠标操作的常用方法： .context_click() 右击 .double_click() 双击 .drag_and_drop() 拖动 .move_to_element() 鼠标悬停在一个元素上 .click_and_hold() 按下鼠标左键在一个元素上 .context_click() 右键点击一个元素 如下以实操processon网站来学习.context_click()和.move_to_element() 1234567891011121314151617181920# !/usr/bin/env python# -*- coding:utf-8 -*-from selenium import webdriverfrom selenium.webdriver.common.action_chains import ActionChainsimport timebrowser = webdriver.Chrome()url = 'https://www.processon.com/login'browser.get(url)browser.find_element_by_id('login_email').send_keys('wzp_work@qq.com')browser.find_element_by_id('login_password').send_keys('123456')browser.find_element_by_id('signin_btn').submit()time.sleep(5)# 鼠标右击操作right = browser.find_element_by_xpath('//div[@class="file-list"]/div[3]/div[@class="file-img-container"]')ActionChains(browser).context_click(right).perform()# 模拟鼠标移动到一个元素上above = browser.find_element_by_xpath('//*[@class="file-list-item active"]/div[3]/ul/li[5]')ActionChains(browser).move_to_element(above).perform() 解释下代码： from selenium.webdriver.common.action_chains import ActionChains，这里需要注意的是，在使用ActionChains类方法之前，要先将包引入ActionChains(browser)，browser: webdriver实例执行用户操作，通过perform()执行存储的行为，perform()通常与ActionChains()配合使用 .double_click()双点击页面元素 1234#定位到要双击的元素double = browser.find_element_by_xpath("xxx")#对定位到的元素执行鼠标双击操作ActionChains(browser).double_click(double).perform() .drag_and_drop(source, target)鼠标拖放操作 在源元素上按下鼠标左键，然后移动到目标元素上释放source: 鼠标按下的源元素target: 鼠标释放的目标元素 鼠标拖放操作的参考代码如下： 123456#定位元素的原位置element = browser.find_element_by_name("xxx")#定位元素要移动到的目标位置target = browser.find_element_by_name("xxx")#执行元素的移动操作ActionChains(browser).drag_and_drop(element, target).perform() .click_and_hold()长按左键 1234#定位到鼠标按下左键的元素left=driver.find_element_by_xpath("xxx")#对定位到的元素执行鼠标左键按下的操作ActionChains(driver).click_and_hold(left).perform() 键盘事件在使用键盘按键方法前需要先导入keys类包from selenium.webdriver.common.keys import Keys 常用到的键盘操作： send_keys(Keys.BACK_SPACE) 删除键（BackSpace） send_keys(Keys.SPACE) 空格键(Space) send_keys(Keys.TAB) 制表键(Tab) send_keys(Keys.ESCAPE) 回退键（Esc） send_keys(Keys.ENTER) 回车键（Enter） send_keys(Keys.CONTROL,’a’) 全选（Ctrl+A） send_keys(Keys.CONTROL,’c’) 复制（Ctrl+C） send_keys(Keys.CONTROL,’x’) 剪切（Ctrl+X） send_keys(Keys.CONTROL,’v’) 粘贴（Ctrl+V） 打印信息一般情况下，脚本运行成功，没有异样信息就表示执行成功，当然，这需要获得更多的信息来证明用例执行结果确实是成功通常可以通过获得页面的title、URL地址，页面上的标识性信息（如，登录成功的“欢迎，xxx”信息）来判断用例执行成功获取当前URL非常重要，在某些情况下，你存在系统会自动进行跳转，也就是“重定向”。一般测试重定向的方法是访问这个URL，然后等待页面重定向完毕之后，获取当前页面的URL，判断该URL是否符合预期 返回当前页面的标题： browser.title返回当前页面的标题： browser.current_url 设置等待时间有时候为了保证脚本运行的稳定性，需要脚本中添加等待时间 time.sleep browser.implicitly_wait(10) webdirver提供的一个超时等待，等待一个元素被发现，或一个命令完成，如果超出了设置时间的则抛出异常 WebDriverWait() 在设置时间内，默认每隔一段时间检测一次当前页面元素是否存在，如果超过设置时间检测不到则抛出异常，不作详细学习 定位frame中的对象在web应用中经常会出现frame嵌套的应用，假设页面上有A、B两个frame，其中B在A内，那么定位B中的内容则需要先到A，然后再到Bswitch_to_frame 方法可以把当前定位的主体切换了frame里，webdriver 每次只能在一个页面识别，所以需要用switch_to.frame方法去获取frame中嵌入的页面，对那个页面里的元素进行定位 方法如下： 1234567...#先找到到ifrome1（id = f1）driver.switch_to_frame("f1")#再找到其下面的ifrome2(id =f2)driver.switch_to_frame("f2")#下面就可以正常的操作元素了... 对话框处理很多情况下对话框是一个iframe，但现在很多前端框架的对话框是div形式定位的方式是二次定位，效果如下： 123456789101112131415161718192021222324252627282930# !/usr/bin/env python# -*- coding:utf-8 -*-from selenium import webdriverfrom selenium.webdriver.common.action_chains import ActionChainsimport timebrowser = webdriver.Chrome()url = 'https://www.processon.com/login'browser.get(url)browser.find_element_by_id('login_email').send_keys('wzp_work@qq.com')browser.find_element_by_id('login_password').send_keys('123456')browser.find_element_by_id('signin_btn').submit()browser.implicitly_wait(5)# 鼠标右击操作right = browser.find_element_by_xpath('//div[@class="file-list"]/div[3]/div[@class="file-img-container"]')ActionChains(browser).context_click(right).perform()# 模拟鼠标移动到一个元素上above = browser.find_element_by_xpath('//*[@class="file-list-item active"]/div[3]/ul/li[5]')ActionChains(browser).move_to_element(above).perform()above.click()browser.implicitly_wait(6)# 操作创建链接browser.find_element_by_id('share_win').find_element_by_xpath('//div[@class="dialog-win-right"]/div/div[2]/span').click()time.sleep(2)# 删除分享链接browser.find_element_by_id('share_win').find_element_by_xpath('//div[@class="dialog-win-right"]/div/div[2]/span').click()time.sleep(2)# 关闭窗口browser.find_element_by_id('share_win').find_element_by_class_name('dialog-close').click() 浏览器多窗口处理多个窗口之间切换，首先要获得每一个窗口的唯一标识符号（句柄）。通过获得的句柄来区分不同窗口，从而对不同窗口上的元素进行操作 针对百度注册弹窗的过程，实现如下： 1234567891011121314151617181920212223242526272829# !/usr/bin/env python# -*- coding:utf-8 -*-from selenium import webdriverimport timebrowser = webdriver.Chrome()url = 'https://www.baidu.com/'browser.get(url)# 获得当前页的句柄nowhandle = browser.current_window_handlebrowser.find_element_by_xpath('//*[@id="head"]/div/div[@id="u1"]/a[7]').click()time.sleep(3)browser.find_element_by_id('passport-login-pop').find_element_by_xpath('//*[@id="passport-login-pop-dialog"]/div/div/div/div[4]/a').click()# 获取所有窗口句柄allhandles = browser.window_handles# 循环判断窗口是否为当前窗口for handle in allhandles: if handle != nowhandle: browser.switch_to_window(handle) print 'now register window!' time.sleep(5) browser.close()# 回到原先的窗口browser.switch_to_window(nowhandle) 解释下代码： 获得当前窗口句柄： browser.current_window_handle返回所有窗口的句柄： browser.window_handles切换窗口： browser.switch_to_window(句柄)关闭窗口： browser.close() alert/confirm/prompt处理JavaScript弹出框：警告(alert)、确认(confirm)、提问(prompt) webdriver通过使用switch_to.alert()方法定位到alert/confirm/prompt，然后使用text/accept/dismiss/send_keys按需进行操作 text 返回alert/confirm/prompt中的文字信息 accept 点击确认按钮 dismiss 点击取消按钮 send_keys 输入值 方法如下： 123456789101112#接受警告信息alert = driver.switch_to_alert()alert.accept()#得到文本信息并打印alert = driver.switch_to_alert()print alert.text()#取消对话框（如果有的话）alert = driver.switch_to_alert()alert.dismiss()#输入值（如果有的话）alert = driver.switch_to_alert()alert.send_keys(“xxx”) 上传文件上传过程一般要打开系统的window窗口，从窗口选择本地文件添加，所以，只要定位上传按钮&lt;input&gt;，通过.send_keys添加本地文件路径就可以，绝对路径和相对路径都可以 如下以百度搜图做示例： 12345678910from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com/')browser.find_element_by_class_name('soutu-btn').click()browser.implicitly_wait(4)browser.find_element_by_class_name('upload-pic').send_keys('C:\\Users\\admin\\Desktop\\a.png')browser.implicitly_wait(10)text = browser.find_element_by_class_name('imglist-active').textprint text 调用JavaScriptwebdriver提供了.execute_script( 接口用来调用js代码 执行js一般有两种场景： 在页面上直接执行JS 在某个已经定位的元素上执行JS 控制浏览器滚动条有时候web页面上的元素并非直接可见，就算浏览器最大化，依然需要拖动滚动条才能看到想要操作的元素，这个时候就要控制页面滚动条的拖动，但滚动条并非页面上的元素，可以借助JavaScript是来完成操作 一般用到操作滚动条的两个场景： 注册时的法律条文的阅读，判断用户是否阅读完成的标准是：滚动条是否拉到最下方 要操作的页面元素不在视觉范围，无法进行操作，需要拖动滚动条 方法案例如下： 1234567891011121314151617181920# !/usr/bin/env python# -*- coding:utf-8 -*-from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.baidu.com/')browser.find_element_by_class_name('soutu-btn').click()browser.implicitly_wait(4)browser.find_element_by_class_name('upload-pic').send_keys('C:\\Users\\admin\\Desktop\\a.png')time.sleep(4)# 将页面滚动条拖到底部js = "var q=document.documentElement.scrollTop=10000"browser.execute_script(js)time.sleep(6)# 将滚动条移动到页面的顶部js2 = "var q=document.documentElement.scrollTop=0"browser.execute_script(js2) cookie处理webdriver操作cookie的方法有： get_cookies() 获得所有cookie信息 get_cookie(name) 返回特定name有cookie信息 add_cookie(cookie_dict) 添加cookie，必须有name和value值 delete_cookie(name) 删除特定(部分)的cookie信息 delete_all_cookies() 删除所有cookie信息 错误截图Webdriver提供错误截图函数get_screenshot_as_file()，在脚本无法继续执行时候，get_screenshot_as_file()函数将截取当前页面的截图保存到指定位置 1234try: browser.find_element_by_class_name('soutu2-btn').click() # 不存在的元素except: browser.get_screenshot_as_file("C:\\Users\\admin\\Desktop\\error_png.png")]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler抓包工具]]></title>
    <url>%2F2018%2F04%2F10%2FFiddler%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Fiddler抓包工具，默认抓http请求，对于pc上的https请求，会提示网页不安全，所以需要在浏览器上安装证书 Fiddler设置：1.打开菜单栏：Tools&gt;Options&gt;HTTPS2.勾选Decrypt HTTPS traffic，两个子菜单也一起勾选3.选择右侧的Actions按钮，选第二个选项，导出证书4.到浏览器设置中导入证书，导入后重启浏览器 抓取手机APP的请求环境准备：1.电脑上已装fiddler2.手机和电脑在同一局域网 操作步骤如下： 设置 1.fiddler&gt;Tools&gt;Options&gt;Connections勾选Allow remote computers to connect2.设置端口号：99993.ipconfig查看本地IP，设置手机代理4.保存生效后即可抓到APP的HTTP请求 抓APP上的HTTPS请求 1.在手机浏览器中输入：代理IP:端口2.出现fiddler的介绍，点击FiddlerRoot certificate，安装证书3.安装完成后即可抓取到HTTPS请求 设置请求过滤 手机上设置代理后，fiddler上抓到的是pc和app所有请求，所以针对APP需要开启过滤功能 操作：Tools&gt;Options&gt;HTTPS&gt;…from remote clients only …from all processes： 抓所有的请求 …from browsers only： 只抓浏览器的请求 …from non-browsers only： 只抓非浏览器的请求 …from remote clients only： 只抓远程客户端请求 查看get与post请求以ProcessOn官网的请求为例，分析get与post数据有何不同https://www.processon.com/ GET 打开网址后，点开fiddler右侧Inspectors下的Headers区域，查看Request Headers，可以看到请求为GET请求 POST 打开网址，选择登陆，查看Headers，可看到请求为POST方式 判断所需请求 1.清屏（cls）,在左下角命令行输入cls或者Remove all清空屏幕2.观察HOST和URL，对应自己在发起请求时的链接地址，则所陈列的就是所需要的请求 工具介绍（Request和Response） 1.第一块区域是设置菜单2.第二块区域快捷菜单3.第三块区域是抓捕的请求会话列表，每一个请求为一个会话4.第四块区域是request请求的详细信息，可以查看headerd、cookies、raw、json等5.第五块区域就是response信息，可以查看服务端返回的json数据或其它信息6.第六块区域是命令行模式，可以输入简单的指令如：cls，执行清屏的作用等 会话框 会话框主要查看请求的一些基本信息 #：代表这个请求大概是什么内容，&lt;&gt;这个符号一般就是请求与响应的类型 Result：服务器返回的代码 200，请求ok；2xx一般是服务器接受成功了并处理 3xx，重定向相关 4xx，404为找不到服务器,一般是请求地址有问题 5xx，一般是服务器本身的错误 Protocol：协议类型，如http、https Host：主机地址或域名 URL：请求的路径 Body：该条请求产生的数据大小 Caching：缓存相关 Content-type：连接类型 Process：客户端类型 Request和Response Request是客户端发出去的数据，Response是服务端返回过来的数据，这两块区域功能差不多 Headers：请求头，包含client、cookies、transport等 Webfroms：请求参数信息表格展示，更直观。可以直接显示参数 Auth：授权相关，如果显示如下两行，说明不需要授权 No Proxy-Authorization Header is present. No Authorization Header is present. Cookies：cookie详情 Raw：查看一个完整请求的内容，可以直接复制 JSON：查看json数据 XML：查看xml文件信息 decode解码 如果response的TextView区域出现乱码情况，可以直接点下方黄色区域解码，又或者在抓取前事先点击快捷菜单的“Decode”，这样抓取到的内容会自动解码 断点（bpu）断点的作用 比如一个金额输入框，前端做了限制100-1000，测试需要测试遍历小于100的情况。这时候可以先抓到接口，修改请求参数，绕过前端，传一个小于100的数，检查服务端的功能是否正常 接口测试其实是不需要管前端的，主要测后端的功能。Fiddler作为代理服务器的作用相当于中介，Fiddler修改了请求参数去验证服务端功能 Fiddler可以修改以下请求： 可修改HTTP请求头信息，如修改Cookie，User-Agent等 可修改请求数据，突破表单限制，提交任意数字，如充值最大100,可以修改成10000 拦截响应数据，修改响应体，如修改服务端返回的页面数据 断点的两种方式 1.before response：这个是打在request请求的时候，未到达服务器之前（A）2.after response：也就是服务器响应之后，在Fiddler将响应传回给客户端之前（B） 全局断点 全局断点就是中断fiddler捕获的所有请求 操作步骤： 1.Rules-&gt;Automatic Breakpoint-&gt;Before Requests2.打开所需测试链接，会话区“#”列显示“T”标识，说明断点成功3.开始断点后，所有的请求都需要Go按钮才能走下一步4.找到需要修改的请求会话，右侧打开WebFroms，修改参数5.点Run to Completion提交修改后的参数6.清除断点：Rules-&gt;Automatic Breakpoint-&gt;Disabled 请求前断点（before response) 操作步骤： 1.命令行输入：bpu 请求链接，执行回车 （如 bpu https://www.processon.com/login）2.请求该接口，只会拦截这个接口，此时可修改任意请求参数3.取消断点，在命令行输入：bpu ，执行回车 响应后断点（after requests） 1.命令行输入：bpafter 请求链接，执行回车2.请求该接口，会发现已经拦截到服务器返回的数据，此时可以修改任意返回数据3.取消断点，在命令行输入： bpafter ，执行回车 命令行其它相关指令 Bpafter xxx： 中断URL包含指定字符的全部session响应 Bps xxx： 中断HTTP响应状态为指定字符的全部session响应 Bpv xxx： 中断指定请求方式的全部session响应 Bpm xxx： 中断指定请求方式的全部session响应，同Bpv xxx Bpu xxx： 与bpafter类似 当这些命令没有加参数时，会清空所有设置了断点的HTTP请求 保存会话一、保存为文本：File&gt;Save&gt;Selected Sessions&gt;as Text 二、几种保存方式 save-All Sessions： 保存所有的会话，saz文件 save-Selected Session： 保存选中的会话 in ArchiveZIP： 保存为saz文件 as Text： 以txt文件形式保存整个会话包括Request和Response as Text(Headers only)： 仅保存头部 Request： 保存请求 Entir Request： 保存整个请求信息（headers和body） Request Body： 只保存请求body部分 Response： 保存返回 Entir Response： 保存整个返回信息（headers和body） Response Body： 只保存返回body部分 and Open as Local File： 保存Response信息，并打开文件 注：保存过程注意乱码问题，最后选择All Sessions，可直接拉取导入 参考学习文献：http://www.cnblogs.com/yoyoketang/tag/fiddler/]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium2Library库详细用法]]></title>
    <url>%2F2018%2F04%2F08%2FSelenium2Library%E5%BA%93%E8%AF%A6%E7%BB%86%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[浏览器驱动 通过不同的浏览器执行脚本Open Browser | Htpp://www.xxx.com | chrome 浏览器对应的关键字：FireFox： firefox / ffInternet Explorer： internetexplorer / ieGoogle Chrome： googlechrome / gc / chromeOpera： operaPhantomJS： phantomjsHTMLUnit： htmlunitHTMLUnit with Javascipt support： htmlunitwithjsAndroid： androidIphone： iphoneSafari： safari 备注： 要想通过不同的浏览打开URL地址，一定要安装浏览器相对应的驱动浏览器默认为空时启动FireFox下载好的驱动要copy放置于Python的主目录下 chromedriver官网下载地址：http://chromedriver.storage.googleapis.com/index.html chromedriver与chrome的对应关系表： chromedriver版本 支持的Chrome版本 v2.37 v64-66 v2.36 v63-65 v2.35 v62-64 v2.34 v61-63 关键字 官方对所有关键字的解释（翻译）：https://pan.baidu.com/s/1kTPkpCEE_jnG5yeIH5dxlA 如下对主要常使用的关键字进行列述： 关闭浏览器 | Close Browser | #关闭当前的浏览器 || Close All Browsers | #关闭所有浏览器和浏览器缓存重置 | 浏览器最大化 | Maximize Browser Window | 设置浏览器宽、高 | Get Window Size | 800 | 600 |以像素为单位，参数800表示宽度，参数600表示高度 文本输入 | Input Text | Xpath=//*[@] | 输入信息 |Xpath=//*[@]定位文本输入框 点击元素 | Click Element | Xpath=//*[@] | 点击按钮 | Click Button | Xpath=//*[@] | 固定时间休眠 | Sleep | 42 || Sleep | 2 minutes 10 seconds |Sleep表示执行到当前行固定休眠多长时间，以“秒”为单位2 minutes 10 seconds 表示2分10秒 等待元素出现在当前页面 | Wait Until Page Contains Element | Xpath=//*[@] | 4 | error |4： 表示最长等待时间Error： 自定义错误提示 获取title | Get Text | Xpath=//*[@] | 获取文本信息 | Get Text | Xpath=//*[@] | 获取元素属性值 | Get Element Attribute | id=kw@name |id=kw@name： id=kw表示定位的元素；@name获取这个元素的name属性值 cookie处理 | get cookies | #获得当前浏览器的所有cookie || get cookie value | Key_name | #获得cookie值 || delete cookie | Key_name | #删除cookie || delete all cookies | #删除当前浏览器的所有cookie || add cookie | Key_name | Value_name | #添加cookie | 声明变量 | ${a} | Set Variable | hello |定义变量a为hello| ${a} | ${b} | Set Variable | hello | world |定义变量a为hello，b为world 日志（输出） | ${a} | Set Variable | Hello World || log | ${a} | 获得浏览器窗口宽、高 | ${width} | ${height} | get window size || log | ${width} || log | ${height} | 校验页面必须包含元素 | Page Should Contain | 校验文案 || Page Should Contain Element | 校验元素xpath | 等待页面加载完成 | Wait Until Page Contains Element | xpath=//*[@] | 8 | Error |等待页面出现特定元素后继续执行下方用例8：指的是等待时长，Error：指失败后的返回文案 执行关键字后忽略错误 | ${result} | ${returnvalue} | Run Keyword And Ignore Error | 关键字 || log | ${result} ， ${returnvalue} |${result}：指执行结果（PASS/FAIL），${returnvalue}：返回错误原因，无错误返回None 验证对比 | open browser | http://www.baidu.com | chrome || ${title} | Get Title || should contain | ${title} | 百度一下，你就知道 |Should Contain比较${title}是否等于“百度一下，你就知道” 表单嵌套 | Select Frame | Xpath=//*[@] | #选择表单 || Unselect Frame | #退出表单 | 下拉框选择 | Unselect From List By Value | Xpath=//*[@] | vlaue |Vlaue 选择下拉框里的属性值 If分支语句 | ${a} | Set variable | 2 || ${b} | Set variable | 5 || run keyword if | ${a}&gt;=1 | log | a大于1 || … | ELSE IF | ${b}&lt;=5 | log | b小于等于5 || … | ELSE | log | 上面两个条件都不满足 | For循环语句 循环1：| :FOR | ${i} | in range | 10 || log | ${i} | 循环2：| @{a} | create list | aaa | bbb || :FOR | ${i} | in | @{a} || log | ${i} |通过in可遍历非整型（in range） 元素定位 Web自动化测试其实就是找到元素（定位元素）并操作元素Selenium2Library提供了非常丰富的定位器： id和name定位 以百度为例。我们可看到输入框input元素有id和name属性，百度一下按钮有id属性 输入框：id=kw name=wd，在Robotframework中就是这样写的： Input text用于输入框的关键字，后面两个参数，一个是元素的定位，一个是输入框输入的值百度一下按钮：id=su，在Robotframework中就是这样写的： click button用户点击按钮的关键字，后面跟着一个必填参数 XPath定位 XPath是一种在XML文档中定位元素的语言。因为HTML可以看做XML的一种实现，所以selenium用户可是使用这种强大语言在web应用中定位元素。如果一个元素没有id和name或没有唯一标识可以使用xpath通过层级关系找到元素 （1）xpath绝对路径 比如百度页面的搜索输入框：xpath=/html/body/div[2]/div[1]/div/div[1]/div/form/span[1]/input绝对路径的用法往往是在我们迫不得已的时候才用的。大多时候用相对路径更简便 （2）xpath的相对路径 使用元素本身定位：比如百度页面的搜索输入框xpath=//*[@id=&quot;kw&quot;]，可以利用元素自身的属性。//表示某个层级下，*表示某个标签名。@id=kw表示这个元素有个id等于kw 当然，一般也可以制定标签名：xpath=//input[@id=&quot;kw&quot;]元素本身，可以利用的属性就不只局限为于id和name，如：Xpath=//input[@autocomplete=’off’]，但要保证这些元素可以唯一的识别一个元素 找上级：如果一个元素找不到可以先找到他的上级。比如：xpath=//span[@class=&#39;bg s_btn_wr’]/input，如果父级没有唯一标识，还可以继续往上找：xpath=//form[@id=’form1’]/span/input 布尔值写法：Xpath=//input[@id=’kw1’ and @name=’wd’] css定位 CSS(Cascading Style Sheets)是一种语言，它被用来描述HTML和XML文档的表现。CSS使用选择器来为页面元素绑定属性。这些选择器可以被 selenium 用作另外的定位策略。CSS可以比较灵活选择控件的任意属性，一般情况下定位速度要比XPath快 CSS 选择器的常见语法： 分层思想进行参数化配置 在程序设计的讲究设计模式，设计模式其实就是根据需求使用抽象与封装，其实就是分层思想。把一个实现过程分成不同多层。提高的灵活性，从而达到可扩展性和可维护性 再回到自动化的话题上，我们可以把操作步骤封装一个一个的方法（关键字），通过调用关键字来实现测试用例以及参数化 方法：新增关键字，编辑关键字的Arguments输入框，创建变量定义变量，多个变量从用“|”隔开 编写完关键字的参数后，直接在用例中调用 参考文献：https://www.cnblogs.com/fnng/p/3969978.html 模态窗口的处理 所谓模态窗口，就是指除非采取有效的关闭手段，用户的鼠标焦点或者输入光标将一直停留在其上的对话框。（说白了，就是弹出了模态窗口之后，后面的窗口无法被点击） 在web自动化测试，可能时常会碰到，但是如果普通的操作（click button）来打开模态窗口 会导致RF卡住，运行不下去。所以必须使用异步的js来打开模态窗口 核心的代码就是： setTimeout(function(){document.getElementById(“aa”).click()},100) 具体的demo如下图： 实际以如下模态窗口作为实例：http://www.runoob.com/try/demo_source/bootstrap-modal.htm 用例如下： 其他文献（涉及弹窗以及复选框）：Selenium2Lib库之界面元素交互常用关键字实战 结束driverserver的方法 case运行时，使用IE或chrome浏览器，运行一次后IEDriverServer.exe或chromedriver.exe进程仍在运行中，所以会出现log窗口未实时进行打印日志的现象，解决方法如下： 方法一： 新建批处理，执行批处理即可 taskkill /f /im chromedriver.exe 方法二： 以关键字形式进行调用 1.RFT引入OperatingSystem类库2.新建一个关键字，例“CloseDriverserver”3.在“CloseDriverserver”输入内容： ${RunOutput} | OperatingSystem.Run | taskkill /IM “chromedriver.exe” /T /F 4.在Case的TearDown中填写“CloseDriverserver”关键字 每次Case步骤执行完成后，会执行该关键字结束IEdriverserver或者Chromedriverserver]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>RobotFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平安云官网自动化校验]]></title>
    <url>%2F2018%2F04%2F01%2F%E5%B9%B3%E5%AE%89%E4%BA%91%E5%AE%98%E7%BD%91%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[针对平安云平台的官网进行简要的自动化校验的概想平安云官网：https://yun.pingan.com/ 自动化校验方式： 通过RobotFramework对页面的主要模块元素进行校验，对主要业务流程进行校验如下以校验官网首页的主要元素和模块，导航栏的跳转，注册流程这三个模块进行自动化校验部署 部署模式： Robotframework+jenkins+Selenium+Email 运行方式： jenkins构建job进行触发即可自动运行 对应有相应的report报告和log日志文件，打开有详细脚本的执行过程，以及出现异常时对应位置和原因 运行完成后，对应会通过jenkins的邮件模块进行通知 实现脚本 具体包括网站导航栏的链接和内容爬取，平安云官网的元素校验，导航栏的正常跳转校验，注册过程校验 导航栏的链接爬取 实际上链接的爬取，主要原先考虑的是存在链接模块的变更，所以想通过每次自动爬取线上存在的模块，再进行各自分类详情页面跳转的校验，但实际工作中应该每个链接都在之前人工有进行遍历测试，所以后面就仅针对平安云的解决方案的几个模块进行爬取试验 脚本如下: 1234567891011121314151617181920212223242526# !/usr/bin/env python# -*- coding:utf-8 -*-from bs4 import BeautifulSoupimport requestsimport timeheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36', 'Cookie': 'UM_distinctid=1616e21c43b644-0abc70fea70a34-4540002c-100200-1616e21c43c436; _ga=GA1.2.280042949.1522389115; _gid=GA1.2.903414702.1522389115; BIGipServerPOOL_Portal_8080_200=1225016420.36895.0000; CNZZDATA1271235823=1822455642-1522386437-https%253A%252F%252Fwww.baidu.com%252F%7C1522482791; SESSION=f5643c32-d4e1-41de-b27d-909798ac15a4'&#125;url = 'https://yun.pingan.com/'wd_data = requests.get(url, headers=headers)time.sleep(1)wd_data.encoding = 'utf-8'soup = BeautifulSoup(wd_data.text, 'lxml')# 爬取解决方案tab的所有分类cates = soup.select('div.menu-overview &gt; div.product-menu-detail &gt; a.product-menu-href &gt; div.menu-title')urls = soup.select('div.menu-overview &gt; div.product-menu-detail &gt; a')for cate, url in zip(cates, urls): data = &#123; 'cate': cate.get_text().encode('utf-8'), 'url': 'https://yun.pingan.com' + url.get('href') &#125; # print data robotframework对应脚本，因为本次涉及的是web，所以使用了Selenium2Library库 case运行时，使用IE或chrome浏览器，运行一次后IEDriverServer.exe或chromedriver.exe进程仍在运行中，所以会出现log窗口未实时进行打印日志的现象，解决方法如下： 1.RFT引入OperatingSystem类库2.新建一个关键字，例“CloseDriverserver”3.在“CloseDriverserver”输入内容： ${RunOutput} | OperatingSystem.Run | taskkill /IM “chromedriver.exe” /T /F 4.在Case的TearDown中填写“CloseDriverserver”关键字 每次Case步骤执行完成后，会执行该关键字结束IEdriverserver或者Chromedriverserver 首页元素校验 这里仅针对首页的title，banner文案，banner标题，中间的解决方案模块，后半部分的图片进行简要校验 导航栏链接跳转校验 在测试套件中，实际上对这部分的校验，很多脚本实际操作行为相同，只是校验的部分以及对应导航栏的链接不同，所以这里用到了分层的想法，把相同部分的脚本作为关键字，然后再通过创建Arguments接口变量，对应做到参数化的效果 调用关键字用例部分（这里仅针对几个分类，未全部覆盖）： 关键字分层部分： 注册行为校验 注册内容的填写主要是通过xpath绝对定位的方式，对应去input text，而在选项上，为非规则下拉选项所以采用模拟点击的方式，button则用click形式直接触发，对应用例如下： 到此，通过jenkins上构建job即可触发自动化脚本的校验]]></content>
      <categories>
        <category>实际运用</category>
      </categories>
      <tags>
        <tag>RobotFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于项目对测试工具二次开发（Second）]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%9F%BA%E4%BA%8E%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%EF%BC%88Second%EF%BC%89%2F</url>
    <content type="text"><![CDATA[工具的界面以及介绍在上篇文章已经陈列说明，如下仅对代码进行贴附 完整的代码放置在百度网盘，作为备份 https://pan.baidu.com/s/1ZPBKEC11h0ITpA7WVRvmHA Main12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208# -*- coding: utf-8 -*-# Form implementation generated from reading ui file 'demo.ui'## Created by: PyQt4 UI code generator 4.11.4## WARNING! All changes made in this file will be lost!from PyQt4 import QtCore, QtGuiimport sysimport registerfrom information import *from PyQt4.QtCore import *from PyQt4.QtGui import *from trading import *import time# 这里是为了解决‘UnicodeEncodeError: 'ascii' codec can't encode characters in position 21-23: ordinal not in range(128)’的方式# 实际上是因为python2.7的问题，输入中文默认asciireload(sys)sys.setdefaultencoding('utf-8')try: _fromUtf8 = QtCore.QString.fromUtf8except AttributeError: def _fromUtf8(s): return s# UI部分代码不陈列，如下主要陈列构造想法 self.retranslateUi(MainWindow) self.tabWidget.setCurrentIndex(0) QtCore.QObject.connect(self.pushButton, QtCore.SIGNAL(_fromUtf8("clicked()")), MainWindow.btn_accepted) QtCore.QObject.connect(self.pushButton_2, QtCore.SIGNAL(_fromUtf8("clicked()")), MainWindow.btn_rejected) QtCore.QObject.connect(self.pushButton_3, QtCore.SIGNAL(_fromUtf8("clicked()")), MainWindow.btn_help) QtCore.QObject.connect(self.new_iden, QtCore.SIGNAL(_fromUtf8("clicked()")), self.new_iden_num.clear) QtCore.QObject.connect(self.new_phone, QtCore.SIGNAL(_fromUtf8("clicked()")), self.new_phone_info.clear) QtCore.QObject.connect(self.new_iden, QtCore.SIGNAL(_fromUtf8("clicked()")), self.new_iden_name.clear) QtCore.QObject.connect(self.old_iden, QtCore.SIGNAL(_fromUtf8("clicked()")), self.old_iden_num.clear) QtCore.QObject.connect(self.old_iden, QtCore.SIGNAL(_fromUtf8("clicked()")), self.old_iden_name.clear) QtCore.QObject.connect(self.env_comboBox, QtCore.SIGNAL(_fromUtf8("currentIndexChanged(int)")), self.tabWidget.setCurrentIndex) QtCore.QObject.connect(self.env_comboBox, QtCore.SIGNAL(_fromUtf8("currentIndexChanged(int)")), MainWindow.setenabled) QtCore.QMetaObject.connectSlotsByName(MainWindow) # ------------------------------------------------------------------------------------------------------------------------------------- # 定义功能函数 def btn_accepted(self): info = u'程序执行中，请稍后...' self.textBrowser.setText(info) # 增加QApplication.processEvents()进行界面刷新 QApplication.processEvents() # 判断是新用户还是已注册用户 statue = ['False', 'False', 'False', 'False', 'False', 'False', 'False', 'False', 'False', 'False', 'False'] text = ['', '', '', '', '', '', ''] result = [] # 定义判断执行环境 if self.env_comboBox.currentIndex() == 0: # ------------------------------------ 新用户 ---------------------------------------------- if self.tabWidget.currentIndex() == 0: global register_result # 判断手机号的选择和输入 if self.new_phone.isChecked(): statue[0] = 'True' if self.new_phone_info.text() == '': info = u'请检查手机号输入项！' self.textBrowser.setText(info) else: set_phone = str(self.new_phone_info.text()) text[0] = set_phone # 调用注册模块代码 register_result = register.user_register(set_phone) # 判断身份证的选择和输入 if self.new_iden.isChecked(): statue[1] = 'True' if self.new_iden_num.text() == '' or self.new_iden_name.text() == '': if register_result == 'registerTrue': num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) # self.textBrowser.setText(info) name = u'随手借' iden_no = '440582199001011112' iden_check = Identity('1', userid, name, iden_no) iden_result = iden_check.identity_in() if iden_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: if register_result == 'registerTrue': text[1] = str(self.new_iden_num.text()) text[2] = str(self.new_iden_name.text()) num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) # self.textBrowser.setText(info) name = str(text[2]) iden_no = str(text[1]) iden_check = Identity('1', userid, name, iden_no) iden_result = iden_check.identity_in() if iden_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断工作资料项 if self.new_work.isChecked(): if register_result == 'registerTrue': statue[2] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) work_check = Work('1', userid) work_result = work_check.work_in() if work_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断联系人资料项 if self.new_cont.isChecked(): if register_result == 'registerTrue': statue[3] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) cont_check = Contacts('1', userid) cont_result = cont_check.contacts_in() if cont_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断芝麻信用资料项 if self.new_zmxy.isChecked(): if register_result == 'registerTrue': statue[4] = 'True' text[3] = str(self.spinBox.value()) num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) score = str(text[3]) zmxy_check = Userzmxy('1', userid, score) zmxy_result = zmxy_check.userzmxy_in() if zmxy_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断支付宝资料项 if self.new_zfb.isChecked(): if register_result == 'registerTrue': statue[5] = 'True' text[4] = str(self.spinBox_2.value()) phone = str(text[0]) userid_check = UserID('1', phone) userid_no = userid_check.userid_get() userid = str(userid_no) setnum = str(text[4]) zfb_check = Userzfb('1', userid, phone, setnum) zfb_result = zfb_check.zfb_set() if zfb_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断学历资料项 if self.new_edu.isChecked(): if register_result == 'registerTrue': statue[6] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) edu_check = Education('1', userid) edu_result = edu_check.edu_set() if edu_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断运营商 if self.new_oper.isChecked(): if register_result == 'registerTrue': statue[7] = 'True' text[5] = str(self.spinBox_4.value()) num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) month = str(text[5]) oper_check = Operator('1', userid, num, month) oper_result = oper_check.operator_in() if oper_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断京东 if self.new_jd.isChecked(): if register_result == 'registerTrue': statue[8] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) jd_check = JD('1', userid) jd_result = jd_check.jd_set() if jd_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断社保 if self.new_sb.isChecked(): if register_result == 'registerTrue': statue[9] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) sb_check = Social('1', userid, name=u'随手借', identity='440582199001010012', salary='5000') sb_result = sb_check.social_in() if sb_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断用户额度 if self.new_quota.isChecked(): if register_result == 'registerTrue': statue[10] = 'True' text[6] = str(self.spinBox_3.value()) num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) account = str(text[6]) account_check = Useraccount('1', userid, account) account_result = account_check.account_set() if account_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # print statue # print text # print result else: # 调用注册的代码，进行注册 phone_num = register.get_random_phone() print phone_num register_result = register.user_register(phone_num) text[0] = phone_num # 判断身份证的选择和输入 if self.new_iden.isChecked(): statue[1] = 'True' if self.new_iden_num.text() == '' or self.new_iden_name.text() == '': if register_result == 'registerTrue': num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) # self.textBrowser.setText(info) name = u'随手借' iden_no = '440582199001011112' iden_check = Identity('1', userid, name, iden_no) iden_result = iden_check.identity_in() if iden_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: if register_result == 'registerTrue': text[1] = str(self.new_iden_num.text()) text[2] = str(self.new_iden_name.text()) num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) # self.textBrowser.setText(info) name = str(text[2]) iden_no = str(text[1]) iden_check = Identity('1', userid, name, iden_no) iden_result = iden_check.identity_in() if iden_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断工作资料项 if self.new_work.isChecked(): if register_result == 'registerTrue': statue[2] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) work_check = Work('1', userid) work_result = work_check.work_in() if work_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断联系人资料项 if self.new_cont.isChecked(): if register_result == 'registerTrue': statue[3] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) cont_check = Contacts('1', userid) cont_result = cont_check.contacts_in() if cont_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断芝麻信用资料项 if self.new_zmxy.isChecked(): if register_result == 'registerTrue': statue[4] = 'True' text[3] = str(self.spinBox.value()) num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) score = str(text[3]) zmxy_check = Userzmxy('1', userid, score) zmxy_result = zmxy_check.userzmxy_in() if zmxy_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断支付宝资料项 if self.new_zfb.isChecked(): if register_result == 'registerTrue': statue[5] = 'True' text[4] = str(self.spinBox_2.value()) phone = str(text[0]) userid_check = UserID('1', phone) userid_no = userid_check.userid_get() userid = str(userid_no) setnum = str(text[4]) zfb_check = Userzfb('1', userid, phone, setnum) zfb_result = zfb_check.zfb_set() if zfb_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断学历资料项 if self.new_edu.isChecked(): if register_result == 'registerTrue': statue[6] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) edu_check = Education('1', userid) edu_result = edu_check.edu_set() if edu_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断运营商 if self.new_oper.isChecked(): if register_result == 'registerTrue': statue[7] = 'True' text[5] = str(self.spinBox_4.value()) num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) month = str(text[5]) oper_check = Operator('1', userid, num, month) oper_result = oper_check.operator_in() if oper_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断京东 if self.new_jd.isChecked(): if register_result == 'registerTrue': statue[8] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) jd_check = JD('1', userid) jd_result = jd_check.jd_set() if jd_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断社保 if self.new_sb.isChecked(): if register_result == 'registerTrue': statue[9] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) sb_check = Social('1', userid, name=u'随手借', identity='440582199001010012', salary='5000') sb_result = sb_check.social_in() if sb_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # 判断用户额度 if self.new_quota.isChecked(): if register_result == 'registerTrue': statue[10] = 'True' text[6] = str(self.spinBox_3.value()) num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) account = str(text[6]) account_check = Useraccount('1', userid, account) account_result = account_check.account_set() if account_result == 'success': result.append('Y') else: result.append('N') else: info = u'注册失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: pass # print statue # print text # print result # 判断定义是否成功 if 'N' in result: info = u'执行失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: info = u'执行成功，账号：' + text[0] self.textBrowser.setText(info) self.pushButton.setEnabled(False) self.pushButton_2.setDefault(True) # ------------------------------------ 已注册用户 ---------------------------------------------- elif self.tabWidget.currentIndex() == 1: # 判断手机号的选择和输入 if self.old_phone.isChecked(): statue[0] = 'True' if self.old_phone_info.text() == u'请输入手机号': info = u'请检查手机号输入项！' self.textBrowser.setText(info) else: set_phone = str(self.old_phone_info.text()) text[0] = set_phone # 判断身份证的选择和输入 if self.old_iden.isChecked(): statue[1] = 'True' if self.old_iden_num.text() == '' or self.old_iden_name.text() == '': num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) # self.textBrowser.setText(info) name = u'随手借' iden_no = '440582199001011112' iden_check = Identity('1', userid, name, iden_no) iden_result = iden_check.identity_in() if iden_result == 'success': result.append('Y') else: result.append('N') else: if register_result == 'registerTrue': text[1] = str(self.new_iden_num.text()) text[2] = str(self.new_iden_name.text()) num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) # self.textBrowser.setText(info) name = str(text[2]) iden_no = str(text[1]) iden_check = Identity('1', userid, name, iden_no) iden_result = iden_check.identity_in() if iden_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断工作资料项 if self.old_work.isChecked(): statue[2] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) work_check = Work('1', userid) work_result = work_check.work_in() if work_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断联系人资料项 if self.old_cont.isChecked(): statue[3] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) cont_check = Contacts('1', userid) cont_result = cont_check.contacts_in() if cont_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断芝麻信用资料项 if self.old_zmxy.isChecked(): statue[4] = 'True' text[3] = str(self.spinBox_7.value()) num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) score = str(text[3]) zmxy_check = Userzmxy('1', userid, score) zmxy_result = zmxy_check.userzmxy_in() if zmxy_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断支付宝资料项 if self.old_zfb.isChecked(): statue[5] = 'True' text[4] = str(self.spinBox_6.value()) phone = str(text[0]) userid_check = UserID('1', phone) userid_no = userid_check.userid_get() userid = str(userid_no) setnum = str(text[4]) zfb_check = Userzfb('1', userid, phone, setnum) zfb_result = zfb_check.zfb_set() if zfb_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断学历资料项 if self.old_edu.isChecked(): statue[6] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) edu_check = Education('1', userid) edu_result = edu_check.edu_set() if edu_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断运营商 if self.old_oper.isChecked(): statue[7] = 'True' text[5] = str(self.spinBox_8.value()) num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) month = str(text[5]) oper_check = Operator('1', userid, num, month) oper_result = oper_check.operator_in() if oper_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断京东 if self.old_jd.isChecked(): statue[8] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) jd_check = JD('1', userid) jd_result = jd_check.jd_set() if jd_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断社保 if self.old_sb.isChecked(): statue[9] = 'True' num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) sb_check = Social('1', userid, name=u'随手借', identity='440582199001010012', salary='5000') sb_result = sb_check.social_in() if sb_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断用户额度 if self.old_quota.isChecked(): statue[10] = 'True' text[6] = str(self.spinBox_5.value()) print text[6] num = str(text[0]) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) account = str(text[6]) account_check = Useraccount('1', userid, account) account_result = account_check.account_set() if account_result == 'success': result.append('Y') else: result.append('N') else: pass # print statue # print text # print result # 判断定义是否成功 if 'N' in result: info = u'执行失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: info = u'执行成功，账号：' + text[0] self.textBrowser.setText(info) self.pushButton.setEnabled(False) self.pushButton_2.setDefault(True) else: pass # ------------------------------------ 用户借款 ---------------------------------------------- else: money = str(self.spinBox_9.value()) periods = self.comboBox_2.currentIndex() set_time = str(self.dateTimeEdit.text()) coupon = self.comboBox.currentIndex() SetDate(set_time) trading_clean('13311113333') time.sleep(3) QApplication.processEvents() # 判断是否有使用优惠券 if coupon == 1: tranding_coupon('1', set_time) time.sleep(6) # 判断分期月份 if periods == 0: QApplication.processEvents() trading_result = tranding_set(money, '3', '1') elif periods == 1: QApplication.processEvents() trading_result = tranding_set(money, '6', '1') elif periods == 2: QApplication.processEvents() trading_result = tranding_set(money, '9', '1') else: QApplication.processEvents() trading_result = tranding_set(money, '12', '1') elif coupon == 2: tranding_coupon('2', set_time) time.sleep(6) if periods == 0: QApplication.processEvents() trading_result = tranding_set(money, '3', '2') elif periods == 1: QApplication.processEvents() trading_result = tranding_set(money, '6', '2') elif periods == 2: QApplication.processEvents() trading_result = tranding_set(money, '9', '2') else: QApplication.processEvents() trading_result = tranding_set(money, '12', '2') elif coupon == 3: tranding_coupon('3', set_time) time.sleep(6) if periods == 0: QApplication.processEvents() trading_result = tranding_set(money, '3', '3') elif periods == 1: QApplication.processEvents() trading_result = tranding_set(money, '6', '3') elif periods == 2: QApplication.processEvents() trading_result = tranding_set(money, '9', '3') else: QApplication.processEvents() trading_result = tranding_set(money, '12', '3') elif coupon == 4: tranding_coupon('4', set_time) time.sleep(6) if periods == 0: QApplication.processEvents() trading_result = tranding_set(money, '3', '4') elif periods == 1: QApplication.processEvents() trading_result = tranding_set(money, '6', '4') elif periods == 2: QApplication.processEvents() trading_result = tranding_set(money, '9', '4') else: QApplication.processEvents() trading_result = tranding_set(money, '12', '4') else: if periods == 0: QApplication.processEvents() trading_result = tranding_set(money, '3', '5') elif periods == 1: QApplication.processEvents() trading_result = tranding_set(money, '6', '5') elif periods == 2: QApplication.processEvents() trading_result = tranding_set(money, '9', '5') else: QApplication.processEvents() trading_result = tranding_set(money, '12', '5') if trading_result == 'tradingTrue': self.pushButton.setEnabled(False) self.pushButton_2.setDefault(True) QApplication.processEvents() num = '13311113333' userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) trading_Id = check_trading_id(userid) info = u'执行成功，请查询交易ID：' + str(trading_Id) self.textBrowser.setText(info) else: info = u'执行失败，请检查设定账号的资料状态！' self.textBrowser.setText(info) else: if self.tabWidget.currentIndex() == 0: info = u'0513环境暂不实现新用户注册...' self.textBrowser.setText(info) elif self.tabWidget.currentIndex() == 2: info = u'0513环境暂不实现用户借款...' self.textBrowser.setText(info) else: # 判断手机号的选择和输入 if self.old_phone.isChecked(): statue[0] = 'True' if self.old_phone_info.text() == u'请输入手机号': info = u'请检查手机号输入项！' self.textBrowser.setText(info) else: set_phone = str(self.old_phone_info.text()) text[0] = set_phone # 判断身份证的选择和输入 if self.old_iden.isChecked(): statue[1] = 'True' if self.old_iden_num.text() == '' or self.old_iden_name.text() == '': num = str(text[0]) userid_check = UserID('2', num) userid_no = userid_check.userid_get() userid = str(userid_no) # self.textBrowser.setText(info) name = u'随手借' iden_no = '440582199001011112' iden_check = Identity('2', userid, name, iden_no) iden_result = iden_check.identity_in() if iden_result == 'success': result.append('Y') else: result.append('N') else: if register_result == 'registerTrue': text[1] = str(self.new_iden_num.text()) text[2] = str(self.new_iden_name.text()) num = str(text[0]) userid_check = UserID('2', num) userid_no = userid_check.userid_get() userid = str(userid_no) # self.textBrowser.setText(info) name = str(text[2]) iden_no = str(text[1]) iden_check = Identity('2', userid, name, iden_no) iden_result = iden_check.identity_in() if iden_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断工作资料项 if self.old_work.isChecked(): statue[2] = 'True' num = str(text[0]) userid_check = UserID('2', num) userid_no = userid_check.userid_get() userid = str(userid_no) work_check = Work('2', userid) work_result = work_check.work_in() if work_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断联系人资料项 if self.old_cont.isChecked(): statue[3] = 'True' num = str(text[0]) userid_check = UserID('2', num) userid_no = userid_check.userid_get() userid = str(userid_no) cont_check = Contacts('2', userid) cont_result = cont_check.contacts_in() if cont_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断芝麻信用资料项 if self.old_zmxy.isChecked(): statue[4] = 'True' text[3] = str(self.spinBox_7.value()) num = str(text[0]) userid_check = UserID('2', num) userid_no = userid_check.userid_get() userid = str(userid_no) score = str(text[3]) zmxy_check = Userzmxy('2', userid, score) zmxy_result = zmxy_check.userzmxy_in() if zmxy_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断支付宝资料项 if self.old_zfb.isChecked(): statue[5] = 'True' text[4] = str(self.spinBox_6.value()) phone = str(text[0]) userid_check = UserID('2', phone) userid_no = userid_check.userid_get() userid = str(userid_no) setnum = str(text[4]) zfb_check = Userzfb('2', userid, phone, setnum) zfb_result = zfb_check.zfb_set() if zfb_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断学历资料项 if self.old_edu.isChecked(): statue[6] = 'True' num = str(text[0]) userid_check = UserID('2', num) userid_no = userid_check.userid_get() userid = str(userid_no) edu_check = Education('2', userid) edu_result = edu_check.edu_set() if edu_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断运营商 if self.old_oper.isChecked(): statue[7] = 'True' text[5] = str(self.spinBox_8.value()) num = str(text[0]) userid_check = UserID('2', num) userid_no = userid_check.userid_get() userid = str(userid_no) month = str(text[5]) oper_check = Operator('2', userid, num, month) oper_result = oper_check.operator_in() if oper_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断京东 if self.old_jd.isChecked(): statue[8] = 'True' num = str(text[0]) userid_check = UserID('2', num) userid_no = userid_check.userid_get() userid = str(userid_no) jd_check = JD('2', userid) jd_result = jd_check.jd_set() if jd_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断社保 if self.old_sb.isChecked(): info = u'执行中，请稍后...' self.textBrowser.setText(info) statue[9] = 'True' num = str(text[0]) userid_check = UserID('2', num) userid_no = userid_check.userid_get() userid = str(userid_no) sb_check = Social('2', userid, name=u'随手借', identity='440582199001010012', salary='5000') sb_result = sb_check.social_in() if sb_result == 'success': result.append('Y') else: result.append('N') else: pass # 判断用户额度 if self.old_quota.isChecked(): info = u'执行中，请稍后...' self.textBrowser.setText(info) statue[10] = 'True' text[6] = str(self.spinBox_5.value()) num = str(text[0]) userid_check = UserID('2', num) userid_no = userid_check.userid_get() userid = str(userid_no) account = str(text[6]) account_check = Useraccount('2', userid, account) account_result = account_check.account_set() if account_result == 'success': result.append('Y') else: result.append('N') else: pass # print statue # print text # print result # 判断定义是否成功 if 'N' in result: info = u'执行失败，请检查远程服务器配置！' self.textBrowser.setText(info) else: info = u'执行成功，账号：' + text[0] self.textBrowser.setText(info) self.pushButton.setEnabled(False) self.pushButton_2.setDefault(True) else: pass def btn_help(self): info = u'如有疑问，请联系测试人员！' self.textBrowser.setText(info) def btn_rejected(self): sys.exit() def setenabled(self): if self.env_comboBox.currentIndex() == 1: self.new_phone.setEnabled(False) self.new_phone_info.setEnabled(False) self.new_iden_name.setEnabled(False) self.new_iden.setEnabled(False) self.new_iden_num.setEnabled(False) self.new_work.setEnabled(False) self.new_cont.setEnabled(False) self.new_zmxy.setEnabled(False) self.new_zfb.setEnabled(False) self.new_edu.setEnabled(False) self.new_oper.setEnabled(False) self.new_jd.setEnabled(False) self.new_sb.setEnabled(False) self.new_quota.setEnabled(False) self.spinBox.setEnabled(False) self.spinBox_2.setEnabled(False) self.spinBox_3.setEnabled(False) self.spinBox_4.setEnabled(False) self.spinBox_9.setEnabled(False) self.dateTimeEdit.setEnabled(False) self.comboBox.setEnabled(False) self.comboBox_2.setEnabled(False) else: self.new_phone.setEnabled(True) self.new_phone_info.setEnabled(True) self.new_iden_name.setEnabled(True) self.new_iden.setEnabled(True) self.new_iden_num.setEnabled(True) self.new_work.setEnabled(True) self.new_cont.setEnabled(True) self.new_zmxy.setEnabled(True) self.new_zfb.setEnabled(True) self.new_edu.setEnabled(True) self.new_oper.setEnabled(True) self.new_jd.setEnabled(True) self.new_sb.setEnabled(True) self.spinBox.setEnabled(True) self.spinBox_2.setEnabled(True) self.spinBox_3.setEnabled(True) self.spinBox_4.setEnabled(True) self.spinBox_9.setEnabled(True) self.dateTimeEdit.setEnabled(True) self.comboBox.setEnabled(True) self.comboBox_2.setEnabled(True) def __init__(self, parent=None): super(Ui_MainWindow, self).__init__(parent) self.setupUi(self) helpbtn = self.pushButton_3 self.Ui_Form = Ui_Form() self.connect(helpbtn, SIGNAL('clicked()'), self.Ui_Form.show)# 第二个窗口，helpclass Ui_Form(QWidget): self.retranslateUi(Form) QtCore.QMetaObject.connectSlotsByName(Form) def __init__(self, parent=None): super(Ui_Form, self).__init__(parent) self.setupUi(self)if __name__ == "__main__": app = 0 app = QApplication(sys.argv) ui = Ui_MainWindow() ui.show() sys.exit(app.exec_()) Informatioon只贴userid查询和单项资料提交部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#!/usr/bin/python# -*- coding: UTF-8 -*-import timeimport MySQLdbimport sys# -------------------------------------------- 用户userid查询 ----------------------------------------------------class UserID: # 用来查询UserID def userid_get(self): q = self.source if q == '1': # 打开数据库连接 db = MySQLdb.connect("12****2", "**t", "A******7", "t**", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 查询输入手机号的UserID p = self.phone.encode('utf-8') sql3 = "SELECT a.`ID` FROM `user_base_info` a WHERE a.`Phone` = '%s' " % p try: # 执行sql语句 cursor.execute(sql3) result = cursor.fetchall() for row in result: userid = row[0] print userid # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "success" print result # 关闭数据库连接 db.close() elif q == '2': # 打开数据库连接 db = MySQLdb.connect("1*****1", "root", "A*****m", "s***3", charset="utf8") cursor = db.cursor() p = self.phone.encode('utf-8') sql3 = "SELECT a.`ID` FROM `user_base_info` a WHERE a.`Phone` = '%s' " % p try: # 执行sql语句 cursor.execute(sql3) result = cursor.fetchall() for row in result: userid = row[0] print userid # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "useridsuccess" # print result db.close() else: print "useridFail" return userid def __init__(self, source, phone): self.source = source self.phone = phone# -------------------------------------------- 身份认证提交 -------------------------------------------------class Identity: # 用来添加身份认证信息 def identity_in(self): q = self.source if q == '1': db = MySQLdb.connect("1%%%%%52", "root", "A*****7", "test", charset="utf8") cursor = db.cursor() usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 global userid a = self.userid b = self.name.encode('utf-8') c = self.identityno.encode('utf-8') # 插入身份证信息SQL语句 sql1 = "INSERT INTO `user_identity_info` (UserID, Identity_Name, Identity_Sex, Identity_Birthday, \ Identity_No, Identity_Addr, Identity_Validity, Identity_LiveArea, Identity_LiveAddr, Identity_SubmitTime, \ Identity_AuthState, Identity_ReviewUser, Identity_ReviewTime, Identity_CloseTime, WideTableID) \ VALUE ('%s', '%s', '1','1986年07月08日', '%s', '软件大厦', '20170808-20270808', \ '222312', '科技中三路靠近软件大厦', '%s', '5', '2', '%s', \ '2920-08-30 13:20:00', 'BC07FC0D9A3BE739E9E65DB831E3EED8') " % \ (a, b, c, usertime, usertime) # 修改身份证认证状态SQL语句 sql2 = "UPDATE `user_base_info` AS a SET a.`Auth_Identity` = '5' WHERE a.`ID` = '%s' " % (a) try: cursor.execute(sql1) cursor.execute(sql2) db.commit() except: db.rollback() else: result = "success" print result db.close() return result elif q == '2': db = MySQLdb.connect("1****81", "root", "A****m", "s**83", charset="utf8") cursor = db.cursor() usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 global userid a = self.userid b = self.name.encode('utf-8') c = self.identityno.encode('utf-8') # 插入身份证信息SQL语句 sql1 = "INSERT INTO `user_identity_info` (UserID, Identity_Name, Identity_Sex, Identity_Birthday, \ Identity_No, Identity_Addr, Identity_Validity, Identity_LiveArea, Identity_LiveAddr, Identity_SubmitTime, \ Identity_AuthState, Identity_ReviewUser, Identity_ReviewTime, Identity_CloseTime, WideTableID) \ VALUE ('%s', '%s', '1','1986年07月08日', '%s', '软件大厦', '20170808-20270808', \ '222312', '科技中三路靠近软件大厦', '%s', '5', '2', '%s', \ '2920-08-30 13:20:00', 'BC07FC0D9A3BE739E9E65DB831E3EED8') " % \ (a, b, c, usertime, usertime) # 修改身份证认证状态SQL语句 sql2 = "UPDATE `user_base_info` AS a SET a.`Auth_Identity` = '5' WHERE a.`ID` = '%s' " % (a) try: cursor.execute(sql1) cursor.execute(sql2) db.commit() except: db.rollback() else: result = "success" print result db.close() return result else: print "fail" def __init__(self, source, userid, name, identityno): self.source = source self.userid = userid self.name = name self.identityno = identityno Trading123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258# !/usr/bin/env python# -*- coding:utf-8 -*-import paramikoimport timeimport MySQLdbimport sysfrom information import *import requestsimport jsonimport re# 设计修改LINUX服务器时间的函数，作为调用def SetDate(date): # 创建SSH对象 ssh = paramiko.SSHClient() # 允许连接不在know_hosts文件中的主机 ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) # 连接服务器 ssh.connect(hostname='12****2', port=22, username='root', password='A*****') # 执行命令 setdate = 'date -s \"&#123;&#125;\" ' .format(str(date)) stdin, stdout, stderr = ssh.exec_command(setdate) time.sleep(1) stdin2, stdout2, stderr2 = ssh.exec_command('date') # 获取命令结果 result = stdout2.read() print result # 关闭连接 ssh.close()# 设计清空数据修改account的机制函数def trading_clean(phone): num = str(phone) userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) db = MySQLdb.connect("1*****2", "root", "A****", "test", charset="utf8") cursor = db.cursor() sql1 = "UPDATE `user_base_info` AS a SET a.`UseState` = '1' WHERE a.`ID` = '%s'" % userid sql2 = "UPDATE `user_account_info` AS a SET a.`MaxAmount` = '10000', a.`UseAmount` = '0', a.`BlockAmount` = '0', \ a.`SurplusAmount` = '10000' WHERE a.`ID` = '%s'" % userid sql3 = "DELETE FROM `trading` WHERE UserID = '%s'" % userid sql4 = "DELETE FROM `user_coupon` WHERE UserID = '%s'" % userid try: cursor.execute(sql1) cursor.execute(sql2) cursor.execute(sql3) cursor.execute(sql4) db.commit() except: db.rollback() else: result = "success" print result db.close() return resultdef tranding_coupon(a, get_time): num = '13311113333' userid_check = UserID('1', num) userid_no = userid_check.userid_get() userid = str(userid_no) obtaintime = str(get_time) expiredate = '2022-03-09 11:59:06' if a == '1': db = MySQLdb.connect("1*****2", "root", "A*****7", "test", charset="utf8") cursor = db.cursor() sql = "INSERT INTO `user_coupon` (CouponNo, UserID, ObtainTime, ExpiredDate, STATUS, CouponRuleID, State) \ VALUES ('djfq0012018121200000001', '%s', '%s', '%s', '1', '277', '1')" % (userid, obtaintime, expiredate) try: cursor.execute(sql) db.commit() except: print 'false' db.rollback() else: result = "success" print result db.close() elif a == '2': db = MySQLdb.connect("1*****2", "root", "A****7", "test", charset="utf8") cursor = db.cursor() sql = "INSERT INTO `user_coupon` (CouponNo, UserID, ObtainTime, ExpiredDate, STATUS, CouponRuleID, State) \ VALUES ('djfq0022018121200000001', '%s', '%s', '%s', '1', '278', '1')" % (userid, obtaintime, expiredate) try: cursor.execute(sql) db.commit() except: print 'false' db.rollback() else: result = "success" print result db.close() elif a == '3': db = MySQLdb.connect("1****2", "root", "A****7", "test", charset="utf8") cursor = db.cursor() sql = "INSERT INTO `user_coupon` (CouponNo, UserID, ObtainTime, ExpiredDate, STATUS, CouponRuleID, State) \ VALUES ('djfq0032018121200000001', '%s', '%s', '%s', '1', '279', '1')" % (userid, obtaintime, expiredate) try: cursor.execute(sql) db.commit() except: print 'false' db.rollback() else: result = "success" print result db.close() elif a == '4': db = MySQLdb.connect("1****2", "root", "A****7", "test", charset="utf8") cursor = db.cursor() sql = "INSERT INTO `user_coupon` (CouponNo, UserID, ObtainTime, ExpiredDate, STATUS, CouponRuleID, State) \ VALUES ('djfq0042018121200000001', '%s', '%s', '%s', '1', '280', '1')" % (userid, obtaintime, expiredate) try: cursor.execute(sql) db.commit() except: print 'false' db.rollback() else: result = "success" print result db.close() else: print 'false' passdef tranding_set(money, month, type): import requests host = 'http://******:80' requests = requests.session() headers = &#123; 'Accept-Language': 'zh-cn', 'Content-Type': 'application/json; charset=UTF-8; ', 'Accept-Encoding': 'gzip, deflate', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'User-Agent': 'iPhone;Apple;iPhone9,2;iOS 11.1;640x1136;breeze 2.1.1;', &#125; # 请求PublicKey接口 url1 = host + '/Jie****icKey/' # 初始化url请求对象 response1 = requests.get(url1, headers=headers) # 转换获得的result为字典，取result对应值 result1_str = '&#123;' + str(response1.text).split(',')[4] + '&#125;' result1_eval = eval(result1_str)['result'] result1 = str(result1_eval) # 请求RSA加密接口 url2 = host + '/JieWebA*****tByPublicKey' payload2_dict = dict(&#123;'publicKey': result1, 'txt': '111111'&#125;) # 字典转为json payload2 = json.dumps(payload2_dict) response2 = requests.post(url2, data=payload2, headers=headers) result2_str = '&#123;' + str(response2.text).split(',')[4] + '&#125;' result2_eval = eval(result2_str)['result'] result2 = str(result2_eval) # 请求登录接口 url3 = host + '/JbAp****ity/login' payload3_dict = dict(&#123;'userName': '13311113333', 'password': result2, 'appType': '1', 'deviceName': 'iPhone', \ 'deviceModel': 'iPhone', 'deviceId': '0AB59207-8578-40B6-81A6-49004B754446', 'osName': 'iOS', \ 'osVersion': '11.2.6', 'appVersion': 'V4.9.0'&#125;) payload3 = json.dumps(payload3_dict) print payload3 response3 = requests.post(url3, data=payload3, headers=headers) # 请求其他接口 url4 = host + '/JieW****88ccount' url5 = host + '/Jie****CouonNum' response4 = requests.get(url4, headers=headers) response5 = requests.get(url5, headers=headers) # 请求借款接口 url6 = host + '/JieW****ans/loan' get_money = str(money) get_month = str(month) if type == '1': payload6_dict = dict(&#123;'principal': get_money, 'phaseNum': get_month, 'cardId': '20338', \ 'couponNo': 'djfq0012018121200000001', 'productType': '02', 'loanPoupose': '1'&#125;) payload6 = json.dumps(payload6_dict) response6 = requests.post(url6, data=payload6, headers=headers) elif type == '2': payload6_dict = dict(&#123;'principal': get_money, 'phaseNum': get_month, 'cardId': '20338', \ 'couponNo': 'djfq0022018121200000001', 'productType': '02', 'loanPoupose': '1'&#125;) payload6 = json.dumps(payload6_dict) response6 = requests.post(url6, data=payload6, headers=headers) elif type == '3': payload6_dict = dict(&#123;'principal': get_money, 'phaseNum': get_month, 'cardId': '20338', \ 'couponNo': 'djfq0032018121200000001', 'productType': '02', 'loanPoupose': '1'&#125;) payload6 = json.dumps(payload6_dict) response6 = requests.post(url6, data=payload6, headers=headers) elif type == '4': payload6_dict = dict(&#123;'principal': get_money, 'phaseNum': get_month, 'cardId': '20338', \ 'couponNo': 'djfq0042018121200000001', 'productType': '02', 'loanPoupose': '1'&#125;) payload6 = json.dumps(payload6_dict) response6 = requests.post(url6, data=payload6, headers=headers) else: payload6_dict = dict(&#123;'principal': get_money, 'phaseNum': get_month, 'cardId': '20338', \ 'couponNo': '', 'productType': '02', 'loanPoupose': '1'&#125;) payload6 = json.dumps(payload6_dict) response6 = requests.post(url6, data=payload6, headers=headers) print response1.text print response2.text print response3.text print response4.text print response5.text print response6.text # 判断结果是否正常 result = re.compile(u'null') check_point = response6.text.encode('utf-8') check_null = result.findall(check_point) outcome = check_null.count('null') if outcome == 4: result = 'tradingTrue' print result else: result = 'tradingFalse' print result return resultdef check_trading_id(userid): db = MySQLdb.connect("1****2", "root", "A****7", "test", charset="utf8") cursor = db.cursor() sql = "SELECT a.`ID` FROM `trading` a WHERE a.`UserID` = '%s'" % userid try: cursor.execute(sql) result = cursor.fetchall() for row in result: trading_id = row[0] print trading_id db.commit() except: print 'false' db.rollback() else: result = "success" # print result db.close() return trading_id# if __name__ == '__main__': # date = '2018-3-10 10:00' # SetDate(date) # trading_clean('13311113333') # time.sleep(6) # tranding_coupon('3', '2018-04-10 11:59:06') # time.sleep(10) # tranding_set('3000', '6', '3') # check_trading_id('4681406') Register123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103# !/usr/bin/env python# -*- coding:utf-8 -*-import requestsimport jsonimport reimport random# 拼接请求urlhost = 'http://j*****m:80'# 通过requests.Session对象，完成请求在上下文传递过程中的Cookie保持一致requests = requests.session()# 构建headers头部headers = &#123; 'Accept-Language': 'zh-cn', 'Content-Type': 'application/json; charset=UTF-8; ', 'Accept-Encoding': 'gzip, deflate', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'User-Agent': 'iPhone;Apple;iPhone9,2;iOS 11.1;640x1136;breeze 2.1.1;',&#125;def user_register(phone): # ------------------------------ 填写验证码页面 ------------------------------------- # 请求注册号码接口 url1 = host + '/JieWebApp/app/security/validatePhone/&#123;&#125;' .format(phone) # 初始化url请求对象 response1 = requests.get(url1, headers=headers) print response1.text # 请求短信验证码接口 payload2_dict = &#123;'userName': phone&#125; payload2 = json.dumps(payload2_dict) url2 = host + '/JieWebA*****thCodeImageCode' response2 = requests.post(url2, data=payload2, headers=headers) print response2.text # 请求短信验证码接口 url3 = host + '/JieWebA*****ode/new/&#123;&#125;/1/1234' .format(phone) response3 = requests.post(url3, headers=headers) print response3.text # ---------------------------- 提交验证码（注册过程） -------------------------------- # 请求PublicKey url4 = host + '/JieW*****getPublicKey/' response4 = requests.post(url4, headers=headers) # 转换获得的result为字典，取result对应值 result4_str = '&#123;' + str(response4.text).split(',')[4] + '&#125;' result4_eval = eval(result4_str)['result'] result4 = str(result4_eval) print result4 # 请求RSA加密接口 url5 = host + '/JieWeb*****yPublicKey' payload5_dict = dict(&#123;'publicKey': result4, 'txt': '111111'&#125;) # 字典转为json payload5 = json.dumps(payload5_dict) response5 = requests.post(url5, data=payload5, headers=headers) print response5.text result5_str = '&#123;' + str(response5.text).split(',')[4] + '&#125;' result5_eval = eval(result5_str)['result'] result5 = str(result5_eval) # 请求注册接口 url6 = host + '/JieWeb*****y/register' payload6_dict = dict(&#123;'userName': phone, 'password': result5, 'authCode': '123456', 'invite': '', 'appChannel': 'appstore', 'appType': '1'&#125;) payload6 = json.dumps(payload6_dict) response6 = requests.post(url6, data=payload6, headers=headers) print response6.text # 判断结果是否正常 result = re.compile(u'null') # print result check_point = response6.text.encode('utf-8') check_null = result.findall(check_point) outcome = check_null.count('null') print outcome, type(outcome) if outcome == 4: result = 'registerTrue' # print result return result else: result = 'registerFalse' # print result return result# 定义自动生成号码的函数def get_random_phone(): phone_start = '133777' phone_end = random.randint(10000, 99999) phone = phone_start + str(phone_end) # print phone return phone# if __name__ == '__main__': # phone_num = get_random_phone() # print phone_num # user_register('14455554444')]]></content>
      <categories>
        <category>实际运用</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyQt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于项目对测试工具二次开发（First）]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%9F%BA%E4%BA%8E%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%EF%BC%88First%EF%BC%89%2F</url>
    <content type="text"><![CDATA[对上次的测试工具进行的优化，主要是通过学习PyQt，设计完整新的GUI界面，达到流程步骤简便，界面美观的效果，下面对本次工具的实现的整体过程做个记录 本次的整体步骤：1.用PyQt designerS设计了新的界面2.通过信号和槽来引入变量3.转换成py文件4.设计自动注册的HTTP请求接口函数5.将界面和功能进行设计挂钩（了解控件的属性以及值的获取方式）6.设计python与Mysql数据库之间的联系，构建授权资料的各个函数7.了解控件的方法，将全部内容串起来，实现功能8.设计通过主界面按钮，唤起其他程序界面9.通过paramiko模块执行远程Linux服务器命令10.通过REQUESTS请求达到借款过程的遍历11.优化程序的卡顿，GUI界面不刷新的问题12.用Pyinstaller打包成可执行程序文件13.校验程序是否可用，数据是否正常生成程序界面 程序最后实现的GUI界面动图如下 本次实现中，主要按照几个模块进行陈列，考虑到代码量的问题，所以代码这块另起附文，这里主要概述下思路和方法，后面直接贴对应之后需要自己注意的有效方法和解决方案 代码及程序目录：https://pan.baidu.com/s/1ZPBKEC11h0ITpA7WVRvmHA 在import引用其他py文件的时候，如出现无法识别的现象，则在程序目录下面创建了一个名为__init__.py，空文件即可，所引用的所有py文件都需要在同一目录下 Register模块 该模块主要实现的功能是自动生成账号，再通过HTTP请求去进行接口注册接口的详细地址，仍然是用jmeter工具，然后通过自带的非测试原件-HTTP代理服务器进行录制，截取到请求，然后在jmeter调通后，再在python中进行拼接 脚本使用了requests json re random模块 12345678# 通过正则表达式进行匹配null的个数result = re.compile(u'null')check_point = response6.text.encode('utf-8')check_null = result.findall(check_point)outcome = check_null.count('null')# random函数自动生成后半部分的字符串phone_end = random.randint(10000, 99999) Information模块 该模块主要是处理python与Mysql之间的联系，也就是主要MySQLdb模块 脚本主要以如下的模式进行连接Mysql 12345678910111213141516171819202122232425# 打开数据库连接db = MySQLdb.connect("120****2", "root", "A******87", "test", charset="utf8")# 使用cursor()方法获取操作游标cursor = db.cursor()# 查询输入手机号的UserIDp = self.phone.encode('utf-8')sql = "SELECT a.`ID` FROM `user_base_info` a WHERE a.`Phone` = '%s' " % ptry: # 执行sql语句 cursor.execute(sql) # 获取执行后的结果 result = cursor.fetchall() for row in result: userid = row[0] print userid # 提交到数据库执行 db.commit()except: # 发生错误时回滚 db.rollback()else: result = "success" print result# 关闭数据库连接db.close() 代码中引用了Mysql的结果查询函数fetchone()：返回单个的元组，即一条记录(row)，如果无结果返回Nonefetchall()：返回多个元组，即多个记录(rows)，如果无结果返回()需要注明：在MySQL中是NULL，而在Python中则是None 用法如下所示： fetchone()用法：cur.execute(“select host,user,password from user where user=’%s’” %acc)a = cur.fetchone() ##此时 通过 a[0],a[1],a[2]可以依次访问host,user,password fetchall()用法：cur.execute(“select * from user”)如果select本身取的时候有多条数据时：cursor.fetchone()：将只取最上面的第一条结果，返回单个元组如(‘id’,’title’)，然后多次使用cursor.fetchone()，依次取得下一条结果，直到为空cursor.fetchall() :将返回所有结果，返回二维元组，如((‘id’,’title’),(‘id’,’title’)),如果select本身取的时候只有一条数据时：cursor.fetchone()：将只返回一条结果，返回单个元组如(‘id’,’title’)cursor.fetchall() :也将返回所有结果，返回二维元组，如((‘id’,’title’),), Trading模块 该模块主要有跟Linux系统相连接，跟Mysql连接以及接口请求相关主要运用了paramiko MySQLdb和ruquest 与Linux系统连接的模块代码如下： 123456789101112131415# 创建SSH对象ssh = paramiko.SSHClient()# 允许连接不在know_hosts文件中的主机ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())# 连接服务器ssh.connect(hostname='1******', port=***, username='root', password='******7')# 执行命令setdate = 'date -s \"&#123;&#125;\" ' .format(str(date))stdin, stdout, stderr = ssh.exec_command(setdate)stdin2, stdout2, stderr2 = ssh.exec_command('date')# 获取命令结果result = stdout2.read()print result# 关闭连接ssh.close() 接口请求以及Mysql与上方等同方式，不作罗列 Main模块 Main模块主要由两个层面组成，一部分是UI界面的实现，另一部分是功能的实现 UI界面是用designer工具是事先进行设计然后转换为PY文件转换目录：D:\Python27\Lib\site-packages\PyQt4\uic转换命令为：pyuic.py main.ui -o main.py 而界面与功能的关联需要使用槽和信号，如： 定义好槽后则对该部分进行功能编写即可 如下对代码中使用到的重要方法进行简要陈列和说明 输入框键入的ascii转utf-8 在获取PyQt的QLineEdit的值时，python2.7输入中文默认使用ascii，所以报如下错误： 1UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 21-23: ordinal not in range(128) 解决方法：在程序中开头添加如下代码： 1234import sysreload(sys)sys.setdefaultencoding('utf-8') 解决运行过程中GUI界面不刷新的问题 qt程序执行的过程中，不会刷新界面，这是由于调用show函数之后，并不能显示界面，必须调用app.exec_()函数后才能刷新出界面，而这个函数肯定最后才能执行到解决方法（程序中添加语句如下）： 1QApplication.processEvents() 按钮唤起其他窗口 在代码中定义对应的按钮，然后再该运行成__init__中调用方法，唤起另一个窗口，如果另一个窗口内容较少的情况下，可直接在同文件中进行运行，方法如下： 123456def __init__(self, parent=None): super(Ui_MainWindow, self).__init__(parent) self.setupUi(self) helpbtn = self.pushButton_3 self.Ui_Form = Ui_Form() self.connect(helpbtn, SIGNAL('clicked()'), self.Ui_Form.show) 到此完成工具脚本的开发 程序打包 到Pyinstaller模块下进行打包，对应将上面的几个主要程序放到该目录，执行如下命令 1pyinstaller -D -w --hidden-import=queue main.py 代码另附文：基于项目对测试工具二次开发（Second）]]></content>
      <categories>
        <category>实际运用</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyQt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用paramiko执行远程Linux主机命令]]></title>
    <url>%2F2018%2F03%2F15%2F%E4%BD%BF%E7%94%A8paramiko%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8BLinux%E4%B8%BB%E6%9C%BA%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[paramiko模块，基于SSH用于连接远程服务器并执行相关操作,可用来连接远程linux主机，然后执行linux命令或者通过SFTP传输文件。 一、安装 pip3 install paramiko 二、使用 基于用户名密码连接： 12345678910111213141516import paramiko # 创建SSH对象ssh = paramiko.SSHClient()# 允许连接不在know_hosts文件中的主机ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())# 连接服务器ssh.connect(hostname='c1.salt.com', port=22, username='wupeiqi', password='123') # 执行命令stdin, stdout, stderr = ssh.exec_command('ls')# 获取命令结果result = stdout.read() # 关闭连接ssh.close() 三、封装成函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# coding: utf-8import paramikoimport refrom time import sleep# 定义一个类，表示一台远端linux主机class Linux(object): # 通过IP, 用户名，密码，超时时间初始化一个远程Linux主机 def __init__(self, ip, username, password, timeout=30): self.ip = ip self.username = username self.password = password self.timeout = timeout # transport和chanel self.t = '' self.chan = '' # 链接失败的重试次数 self.try_times = 3 # 调用该方法连接远程主机 def connect(self): while True: # 连接过程中可能会抛出异常，比如网络不通、链接超时 try: self.t = paramiko.Transport(sock=(self.ip, 22022)) self.t.connect(username=self.username, password=self.password) self.chan = self.t.open_session() self.chan.settimeout(self.timeout) self.chan.get_pty() self.chan.invoke_shell() # 如果没有抛出异常说明连接成功，直接返回 print u'连接%s成功' % self.ip # 接收到的网络数据解码为str print self.chan.recv(65535).decode('utf-8') return # 这里不对可能的异常如socket.error, socket.timeout细化，直接一网打尽 except Exception, e1: if self.try_times != 0: print u'连接%s失败，进行重试' %self.ip self.try_times -= 1 else: print u'重试3次失败，结束程序' exit(1) # 断开连接 def close(self): self.chan.close() self.t.close() # 发送要执行的命令 def send(self, cmd): cmd += '\r' # 通过命令执行提示符来判断命令是否执行完成 p = re.compile(r':~ #') result = '' # 发送要执行的命令 self.chan.send(cmd) # 回显很长的命令可能执行较久，通过循环分批次取回回显 while True: sleep(0.5) ret = self.chan.recv(65535) ret = ret.decode('utf-8') result += ret if p.search(ret): print result return result# 链接正常的情况if __name__ == '__main__': host = Linux('12.1.23.4', 'root', 'aaaaaaa') host.connect() host.send('date') host.close()]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyQt4主程序通过按钮唤起另一程序界面]]></title>
    <url>%2F2018%2F03%2F14%2FPyQt4%E4%B8%BB%E7%A8%8B%E5%BA%8F%E9%80%9A%E8%BF%87%E6%8C%89%E9%92%AE%E5%94%A4%E8%B5%B7%E5%8F%A6%E4%B8%80%E7%A8%8B%E5%BA%8F%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[通过学习查阅资料后，得出如下两种方式，可以从主程序中通过程序的某一个按钮，connect另一个程序，然后进行调用唤起因为我自己的环境是python2.7，只能使用PyQt4，所以记录也以该版本的实现来开展 PyQt4的实现方式如下（直接贴自己写的界面）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# -*- coding: utf-8 -*-import sysfrom PyQt4.QtCore import *from PyQt4.QtGui import *from PyQt4 import QtCore, QtGuitry: _fromUtf8 = QtCore.QString.fromUtf8except AttributeError: def _fromUtf8(s): return stry: _encoding = QtGui.QApplication.UnicodeUTF8 def _translate(context, text, disambig): return QtGui.QApplication.translate(context, text, disambig, _encoding)except AttributeError: def _translate(context, text, disambig): return QtGui.QApplication.translate(context, text, disambig)class mainWindow(QWidget): def __init__(self, parent = None): super(mainWindow, self).__init__(parent) info = u'弹出新窗口' button = QPushButton(info, self) self.Ui_Form = Ui_Form() self.connect(button, SIGNAL('clicked()'), self.Ui_Form.show)class Ui_Form(QWidget): def setupUi(self, Form): Form.setObjectName(_fromUtf8("Form")) Form.resize(370, 320) Form.setMaximumSize(QtCore.QSize(370, 320)) icon = QtGui.QIcon() icon.addPixmap(QtGui.QPixmap(_fromUtf8("ssj.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off) Form.setWindowIcon(icon) self.textEdit = QtGui.QTextEdit(Form) self.textEdit.setGeometry(QtCore.QRect(10, 10, 350, 300)) self.textEdit.setMaximumSize(QtCore.QSize(350, 300)) self.textEdit.setStyleSheet(_fromUtf8("font: 9pt \"微软雅黑\";")) self.textEdit.setInputMethodHints(QtCore.Qt.ImhNone) self.textEdit.setReadOnly(True) self.textEdit.setObjectName(_fromUtf8("textEdit")) self.retranslateUi(Form) QtCore.QMetaObject.connectSlotsByName(Form) def retranslateUi(self, Form): Form.setWindowTitle(_translate("Form", "帮助", None)) self.textEdit.setHtml(_translate("Form", "&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\"&gt;\n""&lt;html&gt;&lt;head&gt;&lt;meta name=\"qrichtext\" content=\"1\" /&gt;&lt;style type=\"text/css\"&gt;\n""p, li &#123; white-space: pre-wrap; &#125;\n""&lt;/style&gt;&lt;/head&gt;&lt;body style=\" font-family:\'微软雅黑\'; font-size:9pt; font-weight:400; font-style:normal;\"&gt;\n""&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-family:\'SimSun\'; font-size:8pt; font-weight:600;\"&gt;1.测试工具支持的场景？&lt;/span&gt;&lt;/p&gt;\n""&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-family:\'SimSun\'; font-size:8pt;\"&gt;支持测试人员环境的注册及资料生成，支持开发人员的资料生成。&lt;/span&gt;&lt;/p&gt;\n""&lt;p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:\'SimSun\'; font-size:8pt;\"&gt;&lt;br /&gt;&lt;/p&gt;\n""&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-family:\'SimSun\'; font-size:8pt; font-weight:600;\"&gt;2.如何操作？&lt;/span&gt;&lt;/p&gt;\n""&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-family:\'SimSun\'; font-size:8pt;\"&gt;勾选所需要具备的资料项，填写对应模块右侧所需参数，点击执行，执行结果在右上方直接显示。&lt;/span&gt;&lt;/p&gt;\n""&lt;p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:\'SimSun\'; font-size:8pt;\"&gt;&lt;br /&gt;&lt;/p&gt;\n""&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-family:\'SimSun\'; font-size:8pt; font-weight:600;\"&gt;3.运行结果？&lt;/span&gt;&lt;/p&gt;\n""&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-family:\'SimSun\'; font-size:8pt;\"&gt;运行结果在右上方显示，执行成功则返回生效的账号，执行失败会提示联系测试人员。&lt;/span&gt;&lt;/p&gt;\n""&lt;p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:\'SimSun\'; font-size:8pt;\"&gt;&lt;br /&gt;&lt;/p&gt;\n""&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-family:\'SimSun\'; font-size:8pt; font-weight:600;\"&gt;4.为什么会执行失败？&lt;/span&gt;&lt;/p&gt;\n""&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-family:\'SimSun\'; font-size:8pt;\"&gt;因为远程服务器为Linux5.6版本，在请求HTTP接口过程存在被安全机制所拦截，对应该机制已做处理，当出现执行数据无效时，可尝试重启远程服务器。&lt;/span&gt;&lt;/p&gt;\n""&lt;p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:\'SimSun\'; font-size:8pt;\"&gt;&lt;br /&gt;&lt;/p&gt;\n""&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-family:\'SimSun\'; font-size:8pt; font-weight:600;\"&gt;5.需要填写的配置参数？&lt;/span&gt;&lt;/p&gt;\n""&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-family:\'SimSun\'; font-size:8pt;\"&gt;若勾选模块但未进行参数配置，未注册用户会自动随机注册一个号码，身份证号和姓名则以默认值作为参数，其他模块也以显示的默认值作为参数。&lt;/span&gt;&lt;/p&gt;\n""&lt;p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:\'SimSun\'; font-size:8pt;\"&gt;&lt;br /&gt;&lt;/p&gt;\n""&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-family:\'SimSun\'; font-size:8pt; font-weight:600;\"&gt;注：&lt;/span&gt;&lt;span style=\" font-family:\'SimSun\'; font-size:8pt;\"&gt;新注册用户密码为111111&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;", None)) def __init__(self, parent=None): super(Ui_Form, self).__init__(parent) self.setupUi(self)app = QApplication(sys.argv)mainwindow = mainWindow()mainwindow.show()app.exec_() 而PyQt5的实现方式，贴如下介绍，若以后需要，再拓展学习https://bbs.csdn.net/topics/390965991https://segmentfault.com/q/1010000005676597/a-1020000005676867]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyQt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyQt4&QtDesigner学习过程（Second）]]></title>
    <url>%2F2018%2F03%2F11%2FPyQt4%26QtDesigner%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%EF%BC%88Second%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在First的基础上，了解并安装了环境，对designer也有所了解，Second主要是就整体情况以及通过一个实现了功能的demo进行学习，为后面的小工具进行铺垫 本次的学习点：使用PyQt4 designer构建界面，对界面上的功能进行实现 使用PyQt4 designer构建界面 关于Main Window和Widget，其实是有无菜单栏的区别。Main Window是有菜单栏的 创建完后，就是以下界面 1 -&gt; 是各个控件 2 -&gt; 画布，也就是界面的部分，可以将各个控件拖放到该画布上 3 -&gt; 属性界面 Designer只能实现界面，不能实现功能。要实现功能，要将界面导出，然后再外部用python编写 关于控件，有几个是比较常用的。Designer将控件分成了几个部分 属性设置里面有两部分，一部分是各个控件都共有的属性，包括控件使能，控件位置大小等等。还有一部分是各个控件自己的属性。设置一般是设置控件自己的属性 在控件的全局属性，QWidget有一个enabled属性，这个属性是控制在界面运行中，控件是否可以操作。如果对于输入框，没有选上勾，那么就不能输入数据了，显示是灰色的。我们可以控制这个属性，来实现某些控件的使能 对于控件的私有属性，以lineEdit控件为例 在属性一栏，可以看到很多属性，在程序中，可以使用属性(),来得到属性的内容比如，有text属性，通过text()就可以得到text属性内容。其他的也是一样但是对于&gt;勾选框的就不一样了。勾选框属性，要通过is属性名()来得到，属性名的第一个字母要大写比如，readOnly这个属性，要通过isReadOnly()，就得到这个属性是否选择了，这种选择的，返回False和True。 以上是得到属性的内容，其实也是可以设置内容的。设置内容的方式是set属性名（要设置的属性内容），其中属性名的第一个字母要大写比如要设置text内容是test，就setText(“test”)，这样，控件中的数据就显示为test了 界面构建好后，可以对界面进行预览 界面程序设计 在之前完成了界面的设计，下面就要对界面进行编程，实现界面功能。首先对之前设计的界面进行保存，得到一个后缀是ui的文件。使用pyuic4将ui文件转换成py文件，这样才能用python进行编程 界面样式如下： 要让界面实现功能，其实就是要编写控件触发后，应该执行的程序。要实现这个的话，就要用到pyqt4中的信号与槽的机制。简单来说，这个信号与槽就是，当控件触发后，会发出一个信号，然后这信号是与一个函数关联起来的，这样，就会去执行这个函数 回到designer中，对勾选框和按钮创建信号与槽。因为对于勾选框，勾选后，按钮才能使用。对于按钮，按下后，会显示注册信息 实现步骤 一、添加信号与槽 1.选择信号与槽 2.选中勾选框控件，按住鼠标往外拖，会出现一条线和一个接地的符号。释放后，会出现配置界面 3.左边是控件的信号列表，这里选择clicked，表示点击。选择右边的编辑，弹出界面，点击+号，增加一个槽。上面灰色的是控件自带的一些函数。增加后，点击下方的OK 4.选择右边刚刚添加的槽，OK 5.在右下角的信号/槽编辑器中就会出现刚刚建立的信号和槽了 6.同理，再建立按钮的信号和槽。 这样，在designer中，就设计完了，再保存，使用pyuic4将ui转换成py 在代码中，就要多下面两行，设置信号与槽的。都是与控件的点击有关的。当勾选框点击的时候，触发clicked信号，然后执行agree_on函数。当按钮点击的时候，触发clicked信号，执行register函数 然后就实现agree_on和register函数就可以了 二、在类中定义这两个函数 1234567891011121314151617def agree_on(self): if self.checkBox.isChecked(): self.pushButton.setEnabled(True) else: self.pushButton.setEnabled(False)def register(self): text = self.lineEdit.text() if self.radioButton.isChecked(): text += u'\n男\n' else: text += u'\n女\n' text += self.comboBox.currentText() + ' ' text += str(self.spinBox.value()) + ' ' text += str(self.spinBox_2.value()) # print text self.textBrowser.setText(text) 在agree_on函数中，首先判断勾选框是否选中，选中的话，就将按钮的enabled属性给使能，否则不使能 在register函数中，将用户名数据保存在text变量中，然后判断是选择的男还是女，是男的话，将男加入到text中。在读取年月日值。不过要注意，月和日使用的spinBox，value的值是int型，要将int型转化为str型。最后将text写入到文本框中 三、例化类，将界面显示出来 最后一步，也是关键的一步。因为界面是一个类，所以要去例化这个类，才能将界面显示出来。以下是例化的代码： 1234567891011121314151617# !/usr/bin/env python# -*- coding:utf-8 -*-import ui2import sysfrom PyQt4.QtGui import *from PyQt4.QtCore import *class Ui(QWidget, ui2.Ui_Form): def __init__(self, parent=None): super(Ui, self).__init__(parent) self.setupUi(self)app = QApplication(sys.argv)ui = Ui()ui.show()app.exec_() 执行代码，在出现的界面中勾选勾选框，填入数据，点击注册按钮，文本框就显示注册信息了效果如下：]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyQt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyQt4&QtDesigner学习过程（First）]]></title>
    <url>%2F2018%2F03%2F10%2FPyQt4%26QtDesigner%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%EF%BC%88First%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Python在GUI上的实现之前因为追求简单所以直接使用EasyGUI，但实际上在样式上还是比较不全，只能通过一项一项依次的选择达到最后的参数汇集，所以希望通过学习Python评价中最为美观的PyQt，较为简单的实现一些界面注：因为一直Python使用的是2.7版本，所以为了各软件通用且兼容，PyQt的学习使用的版本为PyQt4，PyQt5是在Python3基础上做的优化，不兼容2.7 环境部署 系统：Windows7_64bitIDE：PycharmPython：2.7 1. 安装PyQt4 for python2_64bit 地址： https://sourceforge.net/projects/pyqt/files/PyQt4/ 2. 安装VC for python27 地址： https://www.microsoft.com/en-us/download/confirmation.aspx?id=44266 3. 验证PyQt是否安装成功 使用import PyQt4，调用成功则正确 4. 配置QtDesigner、PyUic和PyRcc4 进入设置中心，选择工具（Tools）-&gt; 外部工具（External Tools）进行新增 依次新增如下： 到此，环境搭建完成 简单的使用 1. 在Pycharm新建的工程上右键选择Extend Tools后，选择QtDesigner 调用成功后会自动弹出Designer界面 2. 使用QtDesigner进行界面设计 3. 保存为ui文件 将ui文件转为py文件 1. 在cmd终端中进入到uic目录 1cd D:\Python27\Lib\site-packages\PyQt4\uic 执行命令： 1python pyuic.py &quot;ui文件路径&quot; -o &quot;py文件路径&quot; 注释： -p （–preview） 预览用户界面 -o （–output） 输出产生的代码到指定文件，而不是console终端上 -x （–execute） 产生额外的代码来测试和显示类 -d （–debug） 显示调试信息 -i （–indent N） 设置缩进的空格数N，N为0时表示使用tab，缺省N为4，即4个空格 -w （–pyqt3-wrapper） 产生PyQt v3 风格的代码格式 –from-imports 控制生成的python代码的一个选项，让产生代码中的导入文件是相对于当前目录 特别注意：执行语句后经常出现提示为安装pyqt5版本，请检查版本，实际上每次执行前需要先替换Pyqt4的uic最新文件，然后把上次执行后产生的pyc后缀文件删除，对应在执行即可生成py文件 调用形成的python文件，显示样式 为Qt生成的代码得要有其它东西调用才能出来界面因此如果想运行出界面还需另外新建一个文件，调用该模块，代码如下： 123456789101112# !/usr/bin/env python# -*- coding:utf-8 -*-from PyQt4 import QtCore, QtGuiimport sysimport ssj # 导入ui文件转换出的python源码模块app = QtGui.QApplication(sys.argv)win = ssj.Ui_MainWindow()win.show()sys.exit(app.exec_()) 本次整体界面的ui转py代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# -*- coding: utf-8 -*-# Form implementation generated from reading ui file 'untitled.ui'## Created by: PyQt4 UI code generator 4.11.4## WARNING! All changes made in this file will be lost!from PyQt4 import QtCore, QtGuitry: _fromUtf8 = QtCore.QString.fromUtf8except AttributeError: def _fromUtf8(s): return stry: _encoding = QtGui.QApplication.UnicodeUTF8 def _translate(context, text, disambig): return QtGui.QApplication.translate(context, text, disambig, _encoding)except AttributeError: def _translate(context, text, disambig): return QtGui.QApplication.translate(context, text, disambig)class Ui_MainWindow(QtGui.QMainWindow): def __init__(self): super(Ui_MainWindow, self).__init__() self.setupUi(self) self.retranslateUi(self) def setupUi(self, MainWindow): MainWindow.setObjectName(_fromUtf8("MainWindow")) MainWindow.resize(480, 530) icon = QtGui.QIcon() icon.addPixmap(QtGui.QPixmap(_fromUtf8("ssj.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off) MainWindow.setWindowIcon(icon) self.env_choose = QtGui.QGroupBox(MainWindow) self.env_choose.setGeometry(QtCore.QRect(20, 20, 221, 71)) # .... 省略，另起文章对该工具进行整理阐述 font.setBold(False) font.setItalic(False) font.setWeight(50) QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), MainWindow.close) QtCore.QMetaObject.connectSlotsByName(MainWindow) def retranslateUi(self, MainWindow): MainWindow.setWindowTitle(_translate("MainWindow", "随手借测试工具", None)) self.env_choose.setTitle(_translate("MainWindow", "测试环境选择", None)) # .... 省略，另起文章对该工具进行整理阐述 self.old_phone.setText(_translate("MainWindow", "指定手机号", None)) self.tabWidget.setTabText(self.tabWidget.indexOf(self.old_user), _translate("MainWindow", "已注册用户", None)) self.copyright.setText(_translate("MainWindow", "© Nolanwu", None)) 执行主函数文件即可看到界面注：整体框架的对象记得更替为MainWindow需要修改该ui转成的py文件内容如下： 1234567def __init__(self): super(Ui_MainWindow, self).__init__() self.setupUi(self) self.retranslateUi(self)def setupUi(self, MainWindow): MainWindow.setObjectName(_fromUtf8("MainWindow")) 执行后，即可看到之前设计好的界面，如下： 接下来就要对窗体的各信号进行事件的编写，进行参数传递，与工具文章另起 本次参考文献：PyQt-Designer生成的UI代码的装配使用Qt-Designer设计师完成PyQt界面图标设计PyQt5使用Designer设计UI的两种实现方式PyQt4教程pyqt4-QtDesigner软件使用教程]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyQt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串&元组&列表&字典互转]]></title>
    <url>%2F2018%2F03%2F08%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%26%E5%85%83%E7%BB%84%26%E5%88%97%E8%A1%A8%26%E5%AD%97%E5%85%B8%E4%BA%92%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[字典 1dict = &#123;'name': 'Zara', 'age': 7, 'class': 'First'&#125; 字典转为字符串 12print type(str(dict)), str(dict)# 返回&lt;type 'str'&gt; &#123;'age': 7, 'name': 'Zara', 'class': 'First'&#125; 字典可以转为元组 12print tuple(dict)# 返回：('age', 'name', 'class') 字典可以转为元组 12print tuple(dict.values())# 返回：(7, 'Zara', 'First') 字典转为列表 1print list(dict) 字典转为列表 1print dict.values 元组 1tup=(1, 2, 3, 4, 5) 元组转为字符串 12print tup.__str__()# 返回：(1, 2, 3, 4, 5) 元组转为列表 12print list(tup)# 返回：[1, 2, 3, 4, 5] 元组不可以转为字典 列表 1nums=[1, 3, 5, 7, 8, 13, 20]; 列表转为字符串 12print str(nums)返回：[1, 3, 5, 7, 8, 13, 20] 列表转为元组 12print tuple(nums)返回：(1, 3, 5, 7, 8, 13, 20) 列表不可以转为字典 字符串 字符串转为元组 12print tuple(eval("(1,2,3)"))# 返回：(1, 2, 3) 字符串转为列表 12print list(eval("(1,2,3)"))返回：[1, 2, 3] 字符串转为字典 12print type(eval("&#123;'name':'ljq', 'age':24&#125;"))返回：&lt;type 'dict'&gt;]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python通过HTTP接口模拟用户注册]]></title>
    <url>%2F2018%2F03%2F08%2FPython%26HTTP%E6%A8%A1%E6%8B%9F%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[需求：想通过requests库直接请求用户注册接口，完成注册的一系列操作，自动生成号码，直接返回我已经注册成功的手机号，用于直接登录，这个过程其实是为了后面跟之前的那块赋予用户哪些授权做铺垫，将两个模块一块挂钩起来，即后面实现点击注册，选择具有哪些权限后，自动运行脚本成功返回我一个账号，该账号具备该能力 扩展库requests 接口测试一般基于HTTP和HTTPS的网络请求，Python中有很多自带原生库和扩展库均可以实现。Python模拟HTTP请求有两种方式，一种是使用httplib模块，一种是使用requests模块，而我本次实现用的是requests库 超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信，它的工作方式是客户机与服务器之间的请求-应答协议它有两种请求方式：GET和POST GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改 POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据 GET请求方式模拟： 12345import requests #调用requests库test_url = 'http://xxx:8080.com' #访问接口的url地址response = requests.get(test_url) #发起一个请求，使用get方法result = response.text #读取请求返回的结果print(result) #打印返回的结果 POST请求方式模拟： 123456789import requests #调用requests库username = 'ningxw' #定义参数usernamepassword = '123456' #定义参数passwordtest_url = 'http://xxx:8080.com' #访问登录接口的url地址datalist = &#123;'uname': username, 'pwd': password&#125; #将参数添加到需求post的data中head = &#123;"Content-Type": "application/Json"&#125; #定义头部response = requests.post(test_url, datas=datalist， headers=head) #发起一个请求，使用post方法result = response.text #读取请求返回的结果print(result) #打印返回的结果 用户注册的实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# !/usr/bin/env python# -*- coding:utf-8 -*-import requestsimport jsonimport reimport random# 拼接请求urlhost = 'http://jenkins.lend51.com:8072'# 通过requests.Session对象，完成请求在上下文传递过程中的Cookie保持一致requests = requests.session()# 构建headers头部headers = &#123; 'Accept-Language': 'zh-cn', 'Content-Type': 'application/json; charset=UTF-8; ', 'Accept-Encoding': 'gzip, deflate', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'User-Agent': 'iPhone;Apple;iPhone9,2;iOS 11.1;640x1136;breeze 2.1.1;',&#125;def user_register(phone): # ------------------------------ 填写验证码页面 ------------------------------------- # 请求注册号码接口 url1 = host + '/JieWebApp/app/security/validatePhone/&#123;&#125;' .format(phone) # 初始化url请求对象 response1 = requests.get(url1, headers=headers) # print response1.text # 请求短信验证码接口 payload2_dict = &#123;'userName': phone&#125; payload2 = json.dumps(payload2_dict) url2 = host + '/JieWebApp/app/common/getSendAuthCodeImageCode' response2 = requests.post(url2, data=payload2, headers=headers) # print response2.text # 请求短信验证码接口 url3 = host + '/JieWebApp/app/common/sendAuthCode/new/&#123;&#125;/1/1234' .format(phone) response3 = requests.post(url3, headers=headers) # print response3.text # ---------------------------- 提交验证码（注册过程） -------------------------------- # 请求PublicKey url4 = host + '/JieWebApp/app/security/getPublicKey/' response4 = requests.post(url4, headers=headers) # 转换获得的result为字典，取result对应值 result4_str = '&#123;' + str(response4.text).split(',')[4] + '&#125;' result4_eval = eval(result4_str)['result'] result4 = str(result4_eval) # print result4 # 请求RSA加密接口 url5 = host + '/JieWebApp/app/common/encryptByPublicKey' payload5_dict = dict(&#123;'publicKey': result4, 'txt': '111111'&#125;) # 字典转为json payload5 = json.dumps(payload5_dict) response5 = requests.post(url5, data=payload5, headers=headers) # print response5.text result5_str = '&#123;' + str(response5.text).split(',')[4] + '&#125;' result5_eval = eval(result5_str)['result'] result5 = str(result5_eval) # 请求注册接口 url6 = host + '/JieWebApp/app/security/register' payload6_dict = dict(&#123;'userName': phone, 'password': result5, 'authCode': '123456', 'invite': '', 'appChannel': 'appstore', 'appType': '1'&#125;) payload6 = json.dumps(payload6_dict) response6 = requests.post(url6, data=payload6, headers=headers) # print response6.text # 判断结果是否正常 result = re.compile(u'null') check_point = response6.text.encode('utf-8') check_null = result.findall(check_point) outcome = check_null.count('null') if outcome == 4: print '注册成功' else: print '注册失败'# 定义自动生成号码的函数def get_random_phone(): phone_start = '1337777' phone_end = random.randint(1000, 9999) phone = phone_start + str(phone_end) # print phone return phoneif __name__ == '__main__': phone_num = get_random_phone() print phone_num user_register(phone_num) 下面依次说明实现如上脚本中，出现的疑问和解决方法 所有的请求以及请求头，请求参数均是之前在jemter上已实现压力测试，然后直接调用之前的数据所得，后期如果要实现接口自动化，还是需要有正规的接口文档会好一点 【1】 在整个注册过程中，需要保持cookie或者session一致，python的方法是通过调用requests中的session方法来实现，在发起请求解析前 1requests = requests.session() 【2】 header是针对服务端有各种限制或特定需求时使用的，一般服务器会进行类似如：X-Requested-With、Content-Length、User-Agent等的验证，所以需要将其以字典的形势发送给服务器 【3】 post方法如果需要带参数，则需要以json的形式传参，但是一般我们获取到的结果或者自己所写的字段，一般都是为dict字典类型，这样传过去会报错，所以这个时候需要引入json库，将字典转为json dict(或对象)与json之间的互相转化 loads()：将json数据转化成dict数据 dumps()：将dict数据转化成json数据 load()：读取json文件数据，转成dict数据 dump()：将dict数据转化成json数据后写入json文件 示例： dict字典转json数据 12345import jsondict = &#123;'name': 'many', 'age': 10, 'sex': 'male'&#125;j = json.dumps(dict)print j 【4】 eval()方法，字符串转为字典 【5】 random.randint()用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限，生成的随机数n: a &lt;= n &lt;= b 本次实现过程参考了如下网址Python入门：模拟登录（二）或注册之requests处理带token请求关于接口自动化的那些事dict(或对象)与json之间的互相转化random模块]]></content>
      <categories>
        <category>实际运用</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫学习过程（Second）]]></title>
    <url>%2F2018%2F03%2F05%2FPython%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%EF%BC%88Second%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第一阶段First主要是学习爬取网站的基本内容，第二阶段的学习，主要是学会爬取大规模数据在第一阶段的基础上，学会把数据存放在MongoDB中，并进行数据的分类和查找python在开发过程中实际上可以将数据存储到不同的数据库中，但mongodb是学习成本最低且储存大量数据有优势的一种数据库 MongoDB教程http://www.runoob.com/mongodb/mongodb-tutorial.html MongoDB环境准备（步骤如下） 1. 安装MongoDB windows7系统在安装之前需要实现安装补丁https://support.microsoft.com/zh-cn/help/2731284/MongoDB官网下载：https://www.mongodb.com/download-center?jmp=nav#community 注：3.6版本安装过程会卡死，所以只能下载安装3.4http://downloads.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-v3.4-latest-signed.msi?_ga=2.7045623.410933966.1512521590-461885398.1512521590 步骤： 1.安装文件2.建立工作目录 建立数据存放目录 D:\mongodb\data 建立日志文件 D:\mongodb\log\mongodb.log3.添加安装路径到path环境变量 D:\Program Files\MongoDB\Server\3.4\bin4.启动mongodb服务 mongod.exe --dbpath=D:\MongoDB\data 若访问 http://localhost:27017 会出现如下提示则表明服务已经启动 1You are trying to access MongoDB on the native driver port. For http diagnostic access, add 1000 to the port number 5.将mongdb作为windows服务随机启动 控制台中输入： mongod.exe --dbpath=D:\mongodb\data --logpath=D:\mongodb\log\mongodb.log --install6.连接mongodb 在控制台中输入 net start mongodb，出现 “Mongo DB 服务已经启动成功”的提示则成功 2. 安装第三方库Pymongo Cmd终端中运行 pip install pymongo 进行安装 3. 安装PyCharm的MongoDB插件 进入Pycharm设置，Plugins中选择Search in repositories，再搜索mongodb插件，安装后重启Pycharm即可 配置mongo插件 在“视图（View）”中打开“工具按钮（ToolButton）”，pycharm右侧可看到扳手标识 在MongoServers中配置新增后即可可视化mongodb 如上即完成了环境的部署 使用MongoDB（建写表/查表/筛选表）（依次如下） 连接/建库建表/存写数据 Python中对MongoDB进行操作需要进行连接，所以需要导入与mongodb连接的一个库pymongo 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-# !/usr/bin/env pythonimport pymongo# 激活mongodb的本地客户端client = pymongo.MongoClient('localhost', 27017)# 1.给数据库命名 == 给Excel文件命名（左边是python中的对象，右边是数据库中的对象）walden = client['walden']# 2.在文件下创建表单 == 在Excel中增加sheetsheet_tab = walden['sheet_tab']path = 'E:/Python/EXE_TEST/walden.txt'with open(path, 'r') as f: lines = f.readlines() for index, line in enumerate(lines): data = &#123; 'index': index, 'line': line, 'words': len(line.split()) &#125; # print data # 把查找出来的字典结构存储到数据库中 # 3.往数据库写入数据 == 在Excel中填写每一行数据 sheet_tab.insert_one(data) 脚本中使用到的函数 enumerate() 内置函数 enumerate在字典上是枚举、列举的意思，作为一个索引在python中enumerate的用法多用于在for循环中得到计数例如如下方法： 12345678list1 = ["这", "是", "一个", "测试"]for index, item in enumerate(list1): print index, item&gt;&gt;&gt;0 这1 是2 一个3 测试 enumerate还可以接收第二个参数，用于指定索引起始值，如： 12345678list1 = ["这", "是", "一个", "测试"]for index, item in enumerate(list1, 1): print index, item&gt;&gt;&gt;1 这2 是3 一个4 测试 .split() 方法 Python split()通过指定分隔符对字符串进行切片，返回分割后的字符串列表 with open 方法 文件的open和close函数过繁琐，用with open (path, ‘r’) as f 简化 查看数据 如上脚本执行后会对应在mongodb数据库中生成一张sheet_tab的表格，对该表格数据的查看和展示方式如下： 12345678import pymongoclient = pymongo.MongoClient('localhost', 27017)walden = client['walden']sheet_tab = walden['sheet_tab']for item in sheet_tab.find(): print item 或者直接通过右侧的mongodb插件进行刷新查看 操作数据 对数据库进行操作，针对数据进行提取筛选 123456789101112131415161718192021# -*- coding:utf-8 -*-# !/usr/bin/env pythonimport pymongoclient = pymongo.MongoClient('localhost', 27017)walden = client['walden']sheet_tab = walden['sheet_tab']# 5.数据库的操作 对换行符的数据进行提取筛选# 在table中要去查找数据，要用find方法，特定数据用字典结构# for item in sheet_tab.find(&#123;'words': 0&#125;):# print item# for item in sheet_tab.find():# print item['line']# $lt / $lte / $gt / $gte / $ne ，依次等价于 &lt; / &lt;= / &gt; / &gt;= /!=# ( l表示less g表示greater e表示equal n表示not )for item in sheet_tab.find(&#123;'words': &#123;'$gt': 10&#125;&#125;): print item mongodb表格内容的查询，要通过find()的方法，查询内容再通过嵌套字典的方式，如下列举简单的集中查询方法 指定返回内容： .find()返回所有的信息 .find({})返回符合where条件的信息，全部列展示 .find({}, {‘列名’: 1, ‘列名’： 0})第一个{}放where条件，第二个{}中列表指的是如name，phone，1表示显示该列信息，0表示不显示 where条件： .find({‘name’: ‘abc’})简单的等于 .find({‘name’: ‘abc’, ‘age’: 18})and语句，同时满足 .find({‘$or’: [{‘age’: 10}, {‘age’: 15}]})or语句，某一条件满足 .find({‘age’: {‘$gte’: 20, ‘$lte’:30}})&lt;, &lt;=, &gt;, &gt;= 等同于 ($lt, $lte, $gt, $gte) .find({‘age’: {‘$in’: [10, 22, 26]}})in, not in 等同于 ($in, $nin) .find({‘age’: null})匹配null 爬取58同城租房信息并存表查表作业原来设定的是：对小猪短租网进行爬取，实际如下自己以爬取58深圳租房的信息，筛选条件为单间整租和价格在1500-2000之间，将爬取到的数据进行存储，存到了新增MongoDB的renting表中，再通过表进行查询，查询筛选在1800以下的房租信息，如下是具体的实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# -*- coding:utf-8 -*-# !/usr/bin/env pythonfrom bs4 import BeautifulSoupimport requestsimport timeimport reimport pymongoheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36', 'Cookie': 'f=n; f=n; f=n; f=n; userid360_xml=1057868E4C3D6E39D7745D4D5F05F047; time_create=1522303572699; id58=c5/njVqP6H5S78e6AwMFAg==; 58home=sz; f=n; city=sz; 58tj_uuid=ac4d317f-6a49-49bc-bbc0-7f4fab091f4a; new_uv=1; utm_source=; spm=; init_refer=https%253A%252F%252Fwww.baidu.com%252Flink%253Furl%253DGOOPbbjEtcSJtZ5ydshMZpqQgU5IiU2BWdNWQ1v0unO%2526wd%253D%2526eqid%253D9187917400047e80000000065a94f544; commontopbar_new_city_info=4%7C%E6%B7%B1%E5%9C%B3%7Csz; commontopbar_ipcity=sz%7C%E6%B7%B1%E5%9C%B3%7C0; als=0; commontopbar_myfeet_tooltip=end; new_session=0; wmda_uuid=f658abda0031d6cb3ba7a4777a4c3747; wmda_new_uuid=1; wmda_session_id_2385390625025=1519711568394-0cf7f423-a9b2-f92d; wmda_visited_projects=%3B2385390625025; xxzl_deviceid=E3MvqKhhfbzwRShu%2BCnSdRAiAHXBuE%2BaBzOUfKroWn1Hw%2B1alcaU4qJT445EhThM'&#125;# 筛选条件为深圳罗湖，单间整租，2000元urls = ['http://sz.58.com/luohu/zufang/0/b11j1/pn%d/?PGTID=0d300008-0071-2fa6-21e1-ee16576effd8&amp;ClickID=4' % i for i in range(1, 4)]# 定义多页爬取的函数def get_housenews(url, data=None): wd_data = requests.get(url, headers=headers) time.sleep(2) wd_data.encoding = 'utf-8' soup = BeautifulSoup(wd_data.text, 'lxml') titles = soup.select('div.des &gt; h2 &gt; a[target="_blank"]') sizes = soup.select('div.des &gt; p.room') descriptions = soup.find_all(onclick=re.compile("from=fcpc_list_sz_biaoti_shangquan")) prices = soup.select('div.money &gt; b') urls = soup.select('div.des &gt; h2 &gt; a[target="_blank"]') if data == None: for title, size, price, description, url in zip(titles, sizes, prices, descriptions, urls): data = &#123; 'title': title.get_text().strip(), 'size': size.get_text().replace(' ', ','), 'price': price.get_text(), 'description': description.get_text().strip(), 'url': url.get('href') &#125; # print data # --------------------------------------- 存储到mongodb中去 ---------------------------------------------- client = pymongo.MongoClient('localhost', 27017) renting = client['renting'] sheet_tab = renting['sheet_tab'] # 插入爬取到的数据 try: sheet_tab.insert_one(data) print "爬取数据插入MongoDB成功！" except: print "数据插入MongoDB数据库失败！"# ------------------------------------------------- 主体程序 -----------------------------------------------------# 调用函数进行数据爬取和数据库的插入# for url in urls:# get_housenews(url)# 对数据库已有数据进行筛选操作client = pymongo.MongoClient('localhost', 27017)renting = client['renting']sheet_tab = renting['sheet_tab']for news in sheet_tab.find(&#123;'price': &#123;'$gt': '1800'&#125;&#125;, &#123;'_id': 0&#125;): print news · 特别注意：爬取网站之前一定要配置Headers（Cookie/User-Agent）以及设置time.sleep，这样才能伪造用户访问的状态，不中反爬取机制！！！ · 如上代码中，使用了soup.find_all的新方法，具体的soup方法，另起日志进行记录.strip()和.replace()方法均另起日志进行学习记录以及使用re库进行了正则表达式匹配，正则表达式后期进行学习 在网页的爬取过程中，有时候会出现爬取到的内容出现乱码，解决这种问题要先确认该网页的编码，右击查看网页的源代码，可以看到HEAD中的，在对应在解析页面前进行编码，如上代码中应用的：wd_data.encoding = &#39;utf-8&#39; 爬取大规模数据的工作流分析（步骤如下） 第1步：观察页面特征 第2步：设计工作流程 以爬取58同城为例：爬取大规模数据，为了程序运行的稳定性，最好是一个爬虫程序制作一件事情，所以设立两个爬虫程序，避免过程中出现的异常而再次进行爬取 1.从列表页爬取信息的url，设定一个爬虫程序，将其存储到表格中去2.从url数据库中取出url依次去访问详情页，然后爬取详情页中的数据 对爬取大规模数据的工作流需要掌握的知识点进行列明： 1.插入MongoDB数据库的数据需为字典的方式，如下： 123456789101112# 第一种title = soup.title.text.strip()price = soup.select('span.price_now &gt; i')[0].text if soup.find_all('span', 'price_now') else Noneitem_info.insert_one(&#123;'title': title, 'price': price&#125;)# 第二种data = &#123; 'title': title.get_text().strip(), 'size': size.get_text().replace(' ', ','), 'description': description.get_text().strip(), 'price': price.get_text()&#125;iten_info.insert_one(data) 2.爬取所需页面字段的时候，要考虑该页面该字段是不是一定存在，为了保证程序爬取的流畅性，所以需要加上对应的字段判断，没有爬取成功以None作为代替 12price = soup.select('span.price_now &gt; i')[0].text if soup.find_all('span', 'price_now') else Nonearea = soup.select('div.palce_li &gt; span &gt; i')[0].text if soup.find_all('div', 'palce_li') else None 3.爬取整个网站的所有页面信息，因为不清楚多分类的具体页码，所以根据链接的形式，再判断页面是否正确出现某些类型，某些固定的css样式，作为判断这个页面是否存在的依据 12345678910# 判断是否到最后页面if soup.find('td', 't'): for link in links: link = link.get('href').split('?')[0] # print link url_list.insert_one(&#123;'link': link&#125;) print '插入数据成功'else: pass # Nothing! 4.针对爬取到的一些链接，存在用户删帖或者商品下线的情况，对应这种情况以及出现的404页面情况，需要做一定的判断处理，仍然是通过soup.find_all()检索页面的一些特定元素，但出现这些元素后直接跳过 123456no_longer_exist = soup.find_all('span', 'soldout_btn')if no_longer_exist: print '无效数据'else: title = soup.title.text.strip() print title 如下是本次爬取的channel频道列表和url及详情的脚本： 1.channel_extract.py 123456789101112131415161718192021222324252627282930313233343536# !/usr/bin/env python# -*- coding:utf-8 -*-from bs4 import BeautifulSoupimport requestsimport time# 1.找到所有频道的连接start_url = 'http://sz.58.com/sale.shtml'url_host = 'http://sz.58.com'# 反爬取机制预防headers = &#123; 'Cookie': 'id58=c5/njVqP6H5S78e6AwMFAg==; 58home=sz; city=sz; 58tj_uuid=ac4d317f-6a49-49bc-bbc0-7f4fab091f4a; als=0; commontopbar_myfeet_tooltip=end; wmda_uuid=f658abda0031d6cb3ba7a4777a4c3747; wmda_new_uuid=1; wmda_visited_projects=%3B2385390625025; xxzl_deviceid=E3MvqKhhfbzwRShu%2BCnSdRAiAHXBuE%2BaBzOUfKroWn1Hw%2B1alcaU4qJT445EhThM; ppStore_fingerprint=68D5AD35AB399AAA2659F248FF1B8D12B1E6236E7CA85E47%EF%BC%BF1519784233552; f=n; commontopbar_new_city_info=4%7C%E6%B7%B1%E5%9C%B3%7Csz; new_uv=3; utm_source=; spm=; init_refer=https%253A%252F%252Fwww.baidu.com%252Flink%253Furl%253Dm0LFygybcur2tdczm5kukJX8Xn0jWKlNHexmykfjmT7%2526wd%253D%2526eqid%253Df1e881b500001004000000065a97666b; commontopbar_ipcity=sz%7C%E6%B7%B1%E5%9C%B3%7C0; new_session=0; sessionid=319858e7-497f-49f2-962e-6d21c2603ac7; myfeet_tooltip=end', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36'&#125;def get_channel_urls(url): wb_data = requests.get(start_url, headers=headers) soup = BeautifulSoup(wb_data.text, 'lxml') time.sleep(2) links = soup.select('ul.ym-submnu &gt; li &gt; b &gt; a') for link in links: link = url_host + link.get('href') print link# get_channel_urls(start_url)channel_list = ''' http://sz.58.com/shouji/ http://sz.58.com/tongxunyw/ http://sz.58.com/danche/ ... http://sz.58.com/tiaozao/ http://sz.58.com/tiaozao/''' 2.page_parsing.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# !/usr/bin/env python# -*- coding:utf-8 -*-from bs4 import BeautifulSoupimport requestsimport pymongoimport time# 2.设置数据库client = pymongo.MongoClient('localhost', 27017)ceshi = client['ceshi']url_list = ceshi['url_list']item_info = ceshi['item_info']headers = &#123; 'Cookie': 'id58=c5/njVqP6H5S78e6AwMFAg==; 58home=sz; city=sz; 58tj_uuid=ac4d317f-6a49-49bc-bbc0-7f4fab091f4a; als=0; commontopbar_myfeet_tooltip=end; wmda_uuid=f658abda0031d6cb3ba7a4777a4c3747; wmda_new_uuid=1; wmda_visited_projects=%3B2385390625025; xxzl_deviceid=E3MvqKhhfbzwRShu%2BCnSdRAiAHXBuE%2BaBzOUfKroWn1Hw%2B1alcaU4qJT445EhThM; ppStore_fingerprint=68D5AD35AB399AAA2659F248FF1B8D12B1E6236E7CA85E47%EF%BC%BF1519784233552; f=n; commontopbar_new_city_info=4%7C%E6%B7%B1%E5%9C%B3%7Csz; new_uv=3; utm_source=; spm=; init_refer=https%253A%252F%252Fwww.baidu.com%252Flink%253Furl%253Dm0LFygybcur2tdczm5kukJX8Xn0jWKlNHexmykfjmT7%2526wd%253D%2526eqid%253Df1e881b500001004000000065a97666b; commontopbar_ipcity=sz%7C%E6%B7%B1%E5%9C%B3%7C0; new_session=0; sessionid=319858e7-497f-49f2-962e-6d21c2603ac7; myfeet_tooltip=end', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36'&#125;# 3.用spider1 爬取商品链接def get_links_from(channel, pages, who_sells=0): # 根据个人/商家以及页面设计模块链接样式http://sz.58.com/shouji/0/pn1/ list_view = '&#123;&#125;&#123;&#125;/pn&#123;&#125;' .format(channel, str(who_sells), str(pages)) wb_data = requests.get(list_view, headers=headers) soup = BeautifulSoup(wb_data.text, 'lxml') time.sleep(1) # 查找要找的链接将其存到数据库 links = soup.select('tr.zzinfo &gt; td.t &gt; a ') # 判断是否到最后页面 if soup.find('td', 't'): for link in links: link = link.get('href').split('?')[0] print link url_list.insert_one(&#123;'link': link&#125;) # print '插入数据成功' else: pass # Nothing!# 4.用spider2 爬取商品详情信息def get_item_info(url): wb_data = requests.get(url, headers=headers) soup = BeautifulSoup(wb_data.text, 'lxml') time.sleep(1) # 针对爬取不到的页面如商品下架页面进行处理 no_longer_exist = soup.find_all('span', 'soldout_btn') if no_longer_exist: print '无效数据' else: # 爬取所要的信息，条件语句判断（如果该字段没有用None表示） title = soup.title.text.strip() price = soup.select('span.price_now &gt; i')[0].text if soup.find_all('span', 'price_now') else None area = soup.select('div.palce_li &gt; span &gt; i')[0].text if soup.find_all('div', 'palce_li') else None # print title, price, area item_info.insert_one(&#123;'title': title, 'price': price, 'area': area&#125;)url = 'http://sz.58.com/shouji/'# get_links_]from(url, 1, 0)get_item_info('http://zhuanzhuan.58.com/detail/969080699825094663z.shtml?fullCate=5%2C36&amp;fullLocal=4&amp;from=pc&amp;metric=null&amp;PGTID=0d300024-0000-447c-b396-16f1471ea40d&amp;ClickID=13') 多进程爬虫的数据抓取进程 &amp; 线程 （类比）一个桌上一个人在吃饭 -&gt; 单进程单线程一个桌上多个人在吃饭 -&gt; 单进程多线程多个桌每桌各一人吃饭 -&gt; 多进程单线程多个卓每桌多个人吃饭 -&gt; 多进程多线程 多进程爬取 为了多进程进行运行爬取，将上面两个文件依次运行，需要借助multiprocessing库的Pool类，帮助python程序调用电脑主机的多个内核完成任务 1234567891011121314151617181920# !/usr/bin/env python# -*- coding:utf-8 -*-# 1.为实现多进程，导入所需新库，可以帮助python程序调用电脑主机的多个内核完成任务from multiprocessing import Pool# 引用自己所写的小程序库from channel_extract import channel_listfrom page_parsing import get_links_from# 2.根据get_links_from，设计用函数填入页码def get_all_links_from(channel): for num in range(1, 101): get_links_from(channel, num)# 实际作用是区分上方的代码，所以用如下的格式if __name__ == '__main__': # 3.创建进程池，电脑上所有的CPU，程序都是需要从进程池中取应被分配到任务 pool = Pool() # map函数指的是将后面的集合/列表一个一个的放进第一个函数中，并且运行 pool.map(get_all_links_from, channel_list.split()) 解释如上代码所用到的函数 map()函数 map() 会根据提供的函数对指定序列做映射语法： map(function, iterable, ...) function 函数，有两个参数 iterable 一个或多个序列 第一个参数function以参数序列中的每一个元素调用function函数，返回包含每次function函数返回值的新列表 举例： def square(x) : # 计算平方数… return x ** 2…map(square, [1,2,3,4,5]) # 计算列表各个元素的平方… [1, 4, 9, 16, 25]map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # 使用 lambda 匿名函数… [1, 4, 9, 16, 25] #提供了两个列表，对相同位置的列表数据进行相加map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])… [3, 7, 11, 15, 19] 监控爬取量 为了方便知道数据爬取的进度以及数量，可以相应的另起python程序，查询对应表格的数据量代码如下： 12345678910# !/usr/bin/env python# -*- coding:utf-8 -*-# 4.创建用来计数的监控程序，目的在于监控目前抓了多少数据import timefrom page_parsing import url_listwhile True: print url_list.find().count() time.sleep(5) 过程爬取加强抵御及优化主要以爬取赶集为学习，整体内容与前面无太大差异，下面列举优化加强的知识点 增加HTTP代理防IP被封 大数据长时间的爬取，可能存在该网对我们的IP进行的封锁，所以可以在request请求中，增加访问过程的HTTP代理，达到从代理池中以不同IP访问的效果 方法如下： 1234567891011121314# 需事先引入random模块import random # 列明代理池proxy_list = [ 'http://210.5.149.43:8090', 'http://210.5.149.33:8090', 'http://210.5.149.32:8090',]# 引用random方法proxy_ip = random.choice(proxy_list)proxies = &#123;'http': proxy_ip&#125;# 在解析过程中使用代理参数wd_data = requests.get(list_view, headers=headers, proxies=proxies) 如上使用了random模块的choice函数代理库原来可使用porxy中国网，但已经被封，现在使用的是xici，质量不高，凑合使用http://www.xicidaili.com/nt 爬取效率的提升 1.多进程 PC为单核的话不奏效，单核则使用多线程，只有PC多核才有用2.页面解析方法 BeautifulSoup的解析是比较慢的，如果直接使用lxml库的话，解析速度会提升10倍，需另外学习3.网络请求的速度使用异步非阻塞的方式进行请求，即过程中同时发起多个请求 解决爬取过程中断 爬取过程如果中断，增加断点续传的功能，及在爬取的过程中，也相应需把url保留下来，然后再后面main脚本中进行对比，代码如下： 1234567891011121314151617181920212223# !/usr/bin/env python# -*- coding:utf-8 -*-from multiprocessing import Poolfrom channel_extract import channel_listfrom page_parsing import get_links_from, item_info, url_list# 使用列表解析式 mongodb的查询方法，查询所有的爬取的urldb_urls = [item['url'] for item in url_list.find()]# 查找已经查询的urlindex_urls = [item['url'] for item in item_info.find()]# 使用集合方式setx = set(db_urls)y = set(index_urls)rest_of_urls = x - ydef get_all_links_from(channel): for num in range(1, 11): get_links_from(channel, num)if __name__ == '__main__': pool = Pool() pool.map(get_all_links_from, rest_of_urls) 如上使用了set方法，不用引入模块，直接调用 set方法简要介绍 123456789101112131415#!/usr/bin/python# -*- coding:utf-8 -*-# 集合的交集/并集/差补/对称差分a = set([1, 2, 3, "a", "b"])b = set([1, 2, 4, "a", "c"])# 交集：等同于a.interseciton(b)print a &amp; b# 补集：等同于a.union(b)print a | b# 差补：d等同于a.diffrence(b)在a集合中去掉所有与b集合中相同的元素，只在a中保留b中没有的结合元素print a - b# 对称差分：找出两个结合中，只属于集合a或者集合b的元素print a ^ b 运行结果如下： 1234set(['a', 1, 2])set(['a', 1, 2, 3, 4, 'c', 'b'])set([3, 'b'])set(['c', 3, 4, 'b']) 如上为Second学习的整体内容]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeautifulSoup用法简列]]></title>
    <url>%2F2018%2F02%2F28%2FBeautifulSoup%E7%94%A8%E6%B3%95%E7%AE%80%E5%88%97%2F</url>
    <content type="text"><![CDATA[find_all()和find()函数实例 soup.find_all()方法介绍 ，soup.find()与之基本类似，只是返回的是第一个值 #查找所有的b标签，返回列表soup.find_all(‘b’) #正则表达式soup.find_all(re.compile(“^b”)) #传入列表参数，找到所有的a标签和b标签soup.find_all([“a”, “b”]) #传入id是link2的参数,Beautiful Soup会搜索每个tag的”id”属性soup.find_all(id=’link2’) #传入正则表达式，查找所有的href标签内容中含有elsie的内容soup.find_all(href=re.compile(“elsie”)) #多层过滤，除了href进行限定之外，对id标签的内容也做了限定soup.find_all(href=re.compile(“elsie”), id=’link1’) #最常用的查找技巧，这里之所以加‘_=’是因为‘class’不仅是html中的tag，也是python语法的关键词，其他的不用加下划线soup.find_all(“div”, class_=”sister”) #针对html5里面的data进行的专项查找data_soup.find_all(attrs={“data-foo”: “value”}) #对text内容进行查找soup.find_all(text=”Elsie”) #列表形式进行查找，与上面name类似soup.find_all(text=[“Tillie”, “Elsie”, “Lacie”]) #正则表达式形式，与上面类似soup.find_all(text=re.compile(“Dormouse”)) #找到前两个a标签， limit用来限定次数soup.find_all(“a”, limit=2) select()函数实例 我们在写 CSS 时，标签名不加任何修饰，类名前加点，id名前加 #，在这里我们也可以利用类似的方法来筛选元素，用到的方法是soup.select()，返回类型是list （1）通过标签名查找soup.select(‘title’) （2）通过类名查找soup.select(‘.sister’) （3）通过 id 名查找soup.select(‘#link1’) （4）组合查找组合查找即和写 class 文件时，标签名与类名、id名进行的组合原理是一样的，例如查找 p 标签中，id 等于 link1的内容，二者需要用空格分开soup.select(‘p #link1’) （5）属性查找查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。soup.select(‘a[class=”sister”]’)soup.select(‘a[href=”http://example.com/elsie“]’) get_text()方法 soup = BeautifulSoup(html.text, ‘lxml’)print (type(soup.select(‘title’)))print (soup.select(‘title’)[0].get_text()) # 获取第一个title标签的对应内容 for title in soup.select(‘title’): print (title.get_text()) # 获取列表中的title对应内容 BeautifulSoup4.4.0文档 http://beautifulsoup.readthedocs.io/zh_CN/latest/]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python替换函数和split函数]]></title>
    <url>%2F2018%2F02%2F28%2FPython%E6%9B%BF%E6%8D%A2%E5%87%BD%E6%95%B0%E5%92%8Csplit%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python中常用的三个“替换”函数是strip()，replace()和re.sub()，以及常用的通过指定分隔符对字符串进行切片的split()函数 replace() 基本用法：对象.replace(rgExp,replaceText,max) rgExp和replaceText是必要参数，max是可选参数 rgExp是指要替换的String对象或文字 replaceText是一个String对象或字符串文字 max表示从左到右最多替换max次 示例： re.sub() 引入re模块后才可以使用re.sub()函数基本用法：re.sub(pattern,repl,string,count,flags) pattern:表示正则表达式中的模式字符串 repl:被替换的字符串（既可以是字符串，也可以是函数） string:要被处理的，要被替换的字符串 count:匹配的次数 flags：标志位，用于控制正则表达式的匹配方式 示例： strip() strip()并不是一个真正意义上的替换函数，它是用来删除一些字符的，所以我们可以把这看作是把字符串中的一些字符替换成空（不是空格，是空） 1.删除位于首位的其他字符，用法：对象.strip（其他字符），如果首位有空格，则无法正常删除这些字符 示例： 2.当参数为空时（即括号里没东西），默认删除空白符（包括’\n’,’\r’, ‘\t’, ‘ ‘)，但是只能删除开头和结尾的，不能删除字符串中间的 示例： 3.lstrip()和rstrip()，分别是用来删除开头和结尾的“其他字符” 示例： split() split()通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串，它返回的是一个列表基本语法：str.split(str=&quot;&quot;, num) str表示分隔符，默认为所有的空字符，包括空格、换行、制表符等 num表示分割次数]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python调用其他py文件的函数]]></title>
    <url>%2F2018%2F02%2F22%2FPython%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96py%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[假设名为A.py的文件需要调用B.py文件内的C(x,y)函数 两文件在同一目录下，则只需： 123import Bif __name__ == "__main__": B.C(x, y) 若只需要调用单个函数，也可以： 123from B import Cif __name__ == "__main__": C(x, y) 两文件在不同目录下，则需要：（假设B.py位于D盘的根目录下） 1.引用所在路径，sys模块 12345import syssys.path.append('D:/')import Bif __name__ = "__main__": B.C(x, y) 2.使用imp模块 12345import impB = imp.load_source('B', 'D:/B.py')import Bif __name__ = "__main__": B.C(x, y)]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫学习过程（First）]]></title>
    <url>%2F2018%2F02%2F09%2FPython%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%EF%BC%88First%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学习计划：四个阶段学习爬虫 如下开始学习视频教程，对应自己觉得需要做笔记的部分，进行记录整体不做编排，就随便记录，最后学习完成以自己设定的一个项目需求做Ending，另起项目日志 整体规划有四个阶段的学习课程，分别起日志进行学习 学习材料：https://pan.baidu.com/s/1mje66BQ FIRST 的知识点 首先要了解HTML网页的基本元素组成，不列明 学习：涉及到的所有的解析库的简要方法，如下作列明 BeautifulSoup库 Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据,Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。你不需要考虑编码方式。 BeautifulSoup3目前已经停止开发，所以现在的项目中使用BeautifulSoup4，对应的安装方式如下： 1pip install beautifulsoup4 BeautifulSoup不仅支持HTML解析器,还支持一些第三方的解析器，如：lxml，XML，html5lib 但是需要安装相应的库。 12$ pip install lxml$ pip install html5lib Requests库 安装方式如下： 1pip install requests 从本地网站通过BeautifulSoup解析网页爬取网页步骤： 第1步：使用BeautifulSoup解析网页Soup = BeautifulSoup(html,’lxml’) 第2步：描述要爬取的东西在哪？？ = Soup.select(‘???’) 第3步：从标签中获得你需要的信息去掉没用的结构，将信息按照一定的格式装在容器中，方便查询 Soup = BeautifulSoup(html,’lxml’) 解析网页有五种库： html.parser lxml HTML lxml XML html5lib lxml （解析速度快，所以以这种为例） 查找图片描述的具体位置，不是说查看图片的可视化位置。具体方法：右击查找元素Copy -&gt; Copy selector （根据元素样式来查找）可以看出具体的描述位置为：body &gt; div.main-content &gt; ul &gt; li:nth-child(1) &gt; img注：选择lxml解析库就只用使用Copy selector 另外一种查找元素形式：Copy -&gt; Copy XpathXpath：元素的绝对路径，对应如上的图片的描述位置为：/html/body/div[2]/ul/li[1]/img 具体的学习代码如下（跟教程有差异，因为使用的是Python2.7）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python#-*- coding:utf-8 -*-from bs4 import BeautifulSoupwith open('E:\\Python\\Learn\\reptile\\web\\new_index.html', 'r') as data_need: Soup = BeautifulSoup(data_need, 'lxml') images = Soup.select('body &gt; div.main-content &gt; ul &gt; li &gt; img') titles = Soup.select('body &gt; div.main-content &gt; ul &gt; li &gt; div.article-info &gt; h3 &gt; a') descs = Soup.select('body &gt; div.main-content &gt; ul &gt; li &gt; div.article-info &gt; p.description') rates = Soup.select('body &gt; div.main-content &gt; ul &gt; li &gt; div.rate &gt; span') cates = Soup.select('body &gt; div.main-content &gt; ul &gt; li &gt; div.article-info &gt; p.meta-info') # print images, titles, descs, rates, cates# 筛选所需信息# for title in titles: # 使用get_text()的方法释放信息 # print title.get_text()# 为了方便查询，将结果放进字典中，建立统一数据结构# 进行字典构造，将其放进zip，进行一次性循环for title, image, desc, rate, cate in zip(titles, images, descs, rates, cates): data = &#123; 'title': title.get_text(), 'desc': desc.get_text(), 'rate': rate.get_text(), 'cate': list(cate.stripped_strings), 'image': image.get('src') &#125; # print data info = [] info.append(data) # print info # 做初步分析，如筛选出大于3分的文章 for i in info: if float(i['rate']) &gt; 3: print i['title'], i['cate'] 解释代码中的引用： zip方法： 就是把几组数组糅在一起x=[‘bob’,’tom’,’kitty’]y=[80,90,95]zip(x, y)就得到了[(‘bob’, 80), (‘tom’, 90), (‘kitty’, 95)]d=dict(zip(x,y))则d[‘bob’]返回80 .get_text()： 获取所有文字内容 .select()： 返回类型是list，上面是使用元素样式来查找“Copy selector” .stripped_strings： 输出的字符串中可能包含了很多空格或空行，使用.stripped_strings可以去除多余空白内容 .get()： 获取链接href属性src内容 运行对应代码后，对应图片的链接并非实际链接，因官网做了反爬机制，通过JS控制了图片的显示，后面再针对图片实际链接的爬取进行学习记录 爬取线上商品当页信息本次学习的是通过用Resquests + Beautifulsoup爬取Tripadvisor网站 爬取网站的步骤： 第1步：了解服务器与本地的交换机制第2步：了解解析真是网页，获取数据的方法 requests的content和text属性的区别 .text返回的是Unicode型的数据。 .content返回的是bytes型也就是二进制的数据。 也就是说，如果你想取文本，可以通过r.text如果想取图片，文件，则可以通过r.content（resp.json()返回的是json格式数据） 通过标签加方括号[]再加特定属性的方法可以更好的定位到元素 123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-# !/usr/bin/env pythonfrom bs4 import BeautifulSoupimport requests# 使用Request向服务器请求获取网页内容url = 'https://www.tripadvisor.cn/Attractions-g60763-Activities-New_York_City_New_York.html'# 返回responsewb_data = requests.get(url)# 开始解析网页soup = BeautifulSoup(wb_data.text, 'lxml')# print soup# 描述要爬取的元素位置titles = soup.select('div.listing_title &gt; a[target="_blank"]')imgs = soup.select('img[width="180"]')cates = soup.select('div.p13n_reasoning_v2')# print titles# 整理并筛选所需信息for title, img, cate in zip(titles, imgs, cates): data = &#123; 'title': title.get_text(), 'img': img.get("src"), 'cate': list(cate.stripped_strings) &#125; print data 如上只能爬取静态的在线信息，如果是动态的信息，则需要用Selenium库来模拟正常浏览网页的行为，Selenium这个另起日志 上方脚本运用了requests库，该库的介绍另起日志，本篇文章以教程的流程往下 构造向服务器提交的参数Headers向服务器提交伪造的Cookie信息，以登录态去访问收藏列表从谷歌浏览器的编辑器中选择Network-Headers-Cookie以及User-Agent 12345678910111213141516171819# -*- coding:utf-8 -*-# !/usr/bin/env pythonfrom bs4 import BeautifulSoupimport requests# 通过伪造cookie来进行模拟登陆状态，获取收藏信息headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36', 'Cookie': 'TASSK=enc%3AAKnvomrzvpa1pcMrrZGZx2mJ5LMx3xACS0sJTQDd0xJCN8FFV%2BxL%2FFpeunWYoHnSs1G%2BWE2s4HdEEBJ23pBrpQVqXDMSTln7C9hjYNUGJ6SY9TpQ5ZUl1MNK0JnVeZuNPA%3D%3D; TAUnique=%1%enc%3AEm4bmPTyg9%2BB0EzI89z20RoTyY1RGWVPiEM0RoyhaOg1jFGw1G8Jhw%3D%3D; _ym_uid=1516344828955196641; _ga=GA1.2.1631474809.1516344828; __gads=ID=e3a3c21db9ff08b3:T=1516348723:S=ALNI_MajjFplu_qiT5EmVr2Ca8rshE5ypw; ki_r=; ServerPool=A; TATravelInfo=V2*A.2*MG.-1*HP.2*FL.3*RS.1; _gid=GA1.2.80105617.1517799398; _ym_isad=2; SecureLogin2=3.4%3AAIthDqydTK1umzywAYkDh7zjolTHquc0Q3lGSs8Lc2H%2BQska%2B4qqNakmXMSys0SZXHE5H6prxRdwj9NPe8INu%2FdUuWP1BPRjla%2BnxP0L8SPQm%2FqaJGyCwgqQNW06IiLTmKbpZkyxAh4%2Bf2YReKTOnUUIOuqLjgsrjpit85Rm1YBeCxyCT6gfJ%2F4SQ%2FY1RdAsMl8REbQUu%2BPGvk4BQuyr%2BiQ%3D; TAAuth3=3%3Afd3d4f587ddedb114eae88cdabe9c2a1%3AACdlAHneIiWDqNOFtkaEb8b028Wf6dhbHTBfRQLYQfI3WeQ03iEYqwWuCtl7vRTd3Vuoe%2BsVErgbLwIweH%2FzzXjTNoS8xXNg0TDSpmDlGjk%2Fjho4bDs3UbDnrfdixGeb4Q7ED4kTR73mEVKkvvtGpI%2B1deW9P3jNZ8dfbbgqyK1m%2BO6XChK9GY%2BWB69NCaaeGQ%3D%3D; CommercePopunder=SuppressAll*1517813765065; _smt_uid=5a7815de.20f5ee33; CM=%1%HanaPersist%2C%2C-1%7CPremiumMobSess%2C%2C-1%7Ct4b-pc%2C%2C-1%7CSPHRSess%2C%2C-1%7CHanaSession%2C%2C-1%7CRestAds%2FRPers%2C%2C-1%7CRCPers%2C%2C-1%7CWShadeSeen%2C%2C-1%7CFtrPers%2C%2C-1%7CTheForkMCCPers%2C%2C-1%7CHomeASess%2C2%2C-1%7CPremiumSURPers%2C%2C-1%7CPremiumMCSess%2C%2C-1%7CRestPartSess%2C%2C-1%7CRestPremRSess%2C%2C-1%7CCCSess%2C%2C-1%7CPremRetPers%2C%2C-1%7CViatorMCPers%2C%2C-1%7Csesssticker%2C%2C-1%7Ct4b-sc%2C%2C-1%7CRestAdsPers%2C%2C-1%7CMC_IB_UPSELL_IB_LOGOS2%2C%2C-1%7Cb2bmcpers%2C%2C-1%7CMC_IB_UPSELL_IB_LOGOS%2C%2C-1%7CPremMCBtmSess%2C%2C-1%7CPremiumSURSess%2C%2C-1%7CLaFourchette+Banners%2C%2C-1%7Csess_rev%2C%2C-1%7Csessamex%2C%2C-1%7CPremiumRRSess%2C%2C-1%7CSaveFtrPers%2C%2C-1%7CSPMCSess%2C%2C-1%7CTheForkORSess%2C%2C-1%7CTheForkRRSess%2C%2C-1%7Cpers_rev%2C%2C-1%7CMetaFtrSess%2C%2C-1%7CRBAPers%2C%2C-1%7CWAR_RESTAURANT_FOOTER_PERSISTANT%2C%2C-1%7CFtrSess%2C%2C-1%7CRestAds%2FRSess%2C%2C-1%7CHomeAPers%2C%2C-1%7CPremiumMobPers%2C%2C-1%7CSPHRPers%2C%2C-1%7CRCSess%2C%2C-1%7CLaFourchette+MC+Banners%2C%2C-1%7CRestAdsCCSess%2C%2C-1%7CRestPartPers%2C%2C-1%7CRestPremRPers%2C%2C-1%7Csh%2C%2C-1%7Cpssamex%2C%2C-1%7CTheForkMCCSess%2C%2C-1%7CCCPers%2C%2C-1%7CWAR_RESTAURANT_FOOTER_SESSION%2C%2C-1%7Cb2bmcsess%2C%2C-1%7CSPMCPers%2C%2C-1%7CPremRetSess%2C%2C-1%7CViatorMCSess%2C%2C-1%7CPremiumMCPers%2C%2C-1%7CPremiumRRPers%2C%2C-1%7CRestAdsCCPers%2C%2C-1%7CTheForkORPers%2C%2C-1%7CPremMCBtmPers%2C%2C-1%7CTheForkRRPers%2C%2C-1%7CSaveFtrSess%2C%2C-1%7CRestAdsSess%2C%2C-1%7CRBASess%2C%2C-1%7CSPORPers%2C%2C-1%7Cperssticker%2C%2C-1%7CMetaFtrPers%2C%2C-1%7C; TAReturnTo=%1%%2FAttractions-g60763-Activities-oa90-New_York_City_New_York.html; roybatty=TNI1625!ABUISmXLvavgjDs%2B8%2FbgTjkEwc60YXi8Jg5ZhxgSfC4IJjC%2B3CrBDbJmV4Y9isInER%2BnWiy9tEfg8en6p6IZ4RKm58vvSXJinJTIUZBgp2IqoMD3fyhE%2Feubq6k%2BAYKfyLULTlvhSRDbnY3PtLQFwi%2Byq2oN3en58IPHKSY47QmW%2C1; TASession=%1%V2ID.0F771B0FF50FE5DD1C33D38805C2F51B*SQ.225*LP.%2FAttractions-g60763-Activities-New_York_City_New_York%5C.html*PR.427%7C*LS.DemandLoadAjax*GR.75*TCPAR.18*TBR.58*EXEX.50*ABTR.3*PHTB.56*FS.6*CPU.74*HS.recommended*ES.popularity*AS.popularity*DS.5*SAS.popularity*FPS.oldFirst*TS.27243C71B324634939C7A9F271099EF8*LF.zhCN*FA.1*DF.0*MS.-1*RMS.-1*FLO.60763*TRA.true*LD.60763; TAUD=LA-1517799398076-1*RDD-1-2018_02_05*LG-26835493-2.1.F.*LD-26835494-.....; ki_t=1516862538617%3B1517799401394%3B1517826233522%3B2%3B44'&#125;urs_saves = 'https://www.tripadvisor.cn/MemberProfile-ccbc-a_uid.27243C71B324634939C7A9F271099EF8'wb_data = requests.get(urs_saves, headers=headers)soup = BeautifulSoup(wb_data.text, 'lxml')# 筛选所需要的信息data = soup.select('div.badgeText')print data 爬取图片的实际地址有些网站难爬取，优先看移动端，通过模拟手机页面获得反爬取信息通过模拟设备User-Agent来实现，实际在爬取过程中，遇到复合型的CSS样式，如果是唯一的类型开头，定位首标识也是可以，如missing lazyMiss hidden这个class样式，定义missing也达到效果 具体的实现方式如下： 12345678910111213141516171819202122# -*- coding:utf-8 -*-# !/usr/bin/env pythonfrom bs4 import BeautifulSoupimport requests# 伪造手机设备来获取图片headers = &#123; 'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/56.0.2924.75 Mobile/14E5239e Safari/602.1',&#125;# 使用Request向服务器请求获取网页内容url = 'https://www.tripadvisor.cn/Attractions-g60763-Activities-New_York_City_New_York.html'wb_data = requests.get(url, headers=headers)soup = BeautifulSoup(wb_data.text, 'lxml')# 描述要爬取的元素位置imgs = soup.select('div.missing ')# print imgsfor i in imgs: print i.get('data-thumburl') 通过字典(Dictionary).get()函数返回指定键的值，获得的结果就是想要的图片实际链接了 爬取多个页面的内容信息爬取多个列表页面的内容，通过观察各个页面链接之间的关系，构造函数，调用函数进行爬取 通过观察链接，然后构造一次性抓取的机制找到规律后，通过列表解析式的方式，完成列表集合的构建 具体的实现方式如下： 123456789101112131415161718192021222324252627282930313233# -*- coding:utf-8 -*-# !/usr/bin/env pythonfrom bs4 import BeautifulSoupimport requestsimport timeurl = 'https://www.tripadvisor.cn/Attractions-g60763-Activities-New_York_City_New_York.html'urls = ['https://www.tripadvisor.cn/Attractions-g60763-Activities-oa&#123;&#125;-New_York_City_New_York.html#FILTERED_LIST' .format(str(i)) for i in range(30, 1140, 30)]def get_attractions(url, data=None): wb_data = requests.get(url) # 作保护手段，避免网站去封IP或者对我们的行为进行限制，通过增加每次请求的延时 time.sleep(2) soup = BeautifulSoup(wb_data.text, 'lxml') # 描述要爬取的元素位置 titles = soup.select('div.listing_title &gt; a[target="_blank"]') imgs = soup.select('img[width="180"]') cates = soup.select('div.p13n_reasoning_v2') # 整理并筛选所需信息 if data == None: for title, img, cate in zip(titles, imgs, cates): data = &#123; 'title': title.get_text(), 'img': img.get("src"), 'cate': list(cate.stripped_strings) &#125; print dataget_attractions(url)for single_url in urls: get_attractions(single_url) 解释代码中的引用： 1urls = ['https://www.tripadvisor.cn/Attractions-g60763-Activities-oa&#123;&#125;-New_York_City_New_York.html#FILTERED_LIST' .format(str(i)) for i in range(30, 1140, 30)] 列表解析式： .format(str(i)) for i in range(30, 1140, 30)另起文章进行学习 字符串格式化： {} .format(str(i))这里用的格式化是format函数，花括号声明{}、用于渲染前的参数引用声明，format参数引入变量；这里也可以使用最简单的‘%’来做映射，方法如下：1urls = ['https://www.tripadvisor.cn/Attractions-g60763-Activities-oa%d-New_York_City_New_York.html#FILTERED_LIST' % i for i in range(30, 1140, 30)] 抓取网站异步加载数据第1步：什么是异步加载？ 存在一些网页不需要点击下一页，不断去加载新的内容，实际上就是异步数据，客户端向服务器发起请求，返回部分数据和主要样式，而不断加载的数据则由JS控制 第2步：如何发现并抓取异步加载数据？ 动态加载的数据应该在Network中的XHR项下进行查看 方法：从监视器中找到对应的Request URL，向它发起请求，然后查看返回的response 具体实现步骤和方式如下：1.向网址请求，并解析网页2.描述要爬取的元素位置，观察Elements在内容加载过程的规律3.筛选所需信息4.爬取连续多页，构造函数 代码如下： 12345678910111213141516171819202122232425262728293031323334353637# -*- coding:utf-8 -*-# !/usr/bin/env pythonfrom bs4 import BeautifulSoupimport requestsimport time# 向网址请求，并解析网页url = 'https://knewone.com/discover?page='# 构建函数进行多页爬取def get_page(url, data = None): wb_data = requests.get(url) soup = BeautifulSoup(wb_data.text, 'lxml') # 描述要爬取的元素位置 imgs = soup.select('a.cover-inner &gt; img') titles = soup.select('section.content &gt; h4 &gt; a') links = soup.select('section.content &gt; h4 &gt; a') # 筛选所需信息 if data == None: for img, title, link in zip(imgs, titles, links): data = &#123; 'img': img.get('src'), 'title': title.get('title'), 'link': link.get('href') &#125; print data# 构建可以自控页码的函数def get_more_pages(start, end): for one in range(start, end): get_page(url + str(one)) time.sleep(2)get_more_pages(1,10) 如上为First学习的整体内容]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python列表解析式和生成器]]></title>
    <url>%2F2018%2F02%2F08%2FPython%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[列表解析式（列表推倒式） 功能：是提供一种方便的列表创建方法，所以，列表解析式返回的是一个列表 举例说明如下： 1234567891011121314151617181920212223lst = [1, 3, 5, 8, 10]ll = [x+x for x in lst if x &lt;= 5]print ll&gt;&gt;&gt; [2, 6, 10]&gt;&gt;&gt; [x for x in range(10)][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; [x**2 for x in range(10)][0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; [x**2 for x in range(10) if x**2 &lt;50][0, 1, 4, 9, 16, 25, 36, 49]&gt;&gt;&gt; [(x+1, y+1) for x in range(2) for y in range(2)][(1, 1),(1, 2),(2, 1),(2, 2)]&gt;&gt;&gt; [ x**2 # 列表解析式断行书写 for x in range(10) if x**2 &lt;50][0, 1, 4, 9, 16, 25, 36, 49] 生成器 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。 python提供两种方式创造生成器： ①生成器函数： 和常规函数一样定义，不过用yield而不是return。yeild会一次返回一个结果，然后挂起，下次从挂起处继续执行，这样就解决了内存的限制。注：其他方式会一次执行完所有的结果，然后再一次返回一个结果，这样，如果数据量大就会受到内存的限制，而且会占用大存储空间。 12345def gen(n): for i in range(n): yeild i + 2for item in gen(10): print item ②生成器生成式： 和列表生成式类似，只是将方括号替换为中括号。 1generators = （x+2 for x in range(10)）]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github主题优化（HEXO）]]></title>
    <url>%2F2018%2F02%2F07%2FGithub%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%88HEXO%EF%BC%89%2F</url>
    <content type="text"><![CDATA[hexo默认的排版有点难看，所以需要对文章以及一些功能进行补充，基本的内置功能官网都给出了详细解释和配置教程http://theme-next.iissnan.com/贴如下几篇文章，通过学习如下文章，把博客大致都配置到自己觉得OK的方式了，后面直接贴自己的所有配置 打造个性超赞博客Hexo+NexT+GithubPages的超深度优化 基于hexo搭建个人免费博客——自定义页面样式一 hexo的next主题个性化教程：打造炫酷网站 如何加快你的博客访问速度 我的custom.styl 位置：~/blog/themes/next/source/css/_custom/custom.styl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Custom styles.// 主页文章添加阴影效果.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; // 去除在页面文章之间的分割线.posts-expand .post-eof &#123; margin: 0px; background-color: rgba(255, 255, 255, 0);&#125;// 去除页面底部页码上面的横线.pagination &#123; border: none; margin: 0px;&#125;// 文章.post &#123; margin-bottom: 50px; padding: 45px 36px 36px 36px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.5); background-color: rgb(255, 255, 255);&#125;// 文章标题字体.posts-expand .post-title &#123; font-size: 26px; font-weight: 700;&#125;// 文章标题动态效果.posts-expand .post-title-link::before &#123; background-image: linear-gradient(90deg, #a166ab 0%, #ef4e7b 25%, #f37055 50%, #ef4e7b 75%, #a166ab 100%);&#125;// 去掉图片边框.posts-expand .post-body img &#123; border: none; padding: 0px;&#125;.post-gallery .post-gallery-img img &#123; padding: 3px;&#125;// 自定义的文章置顶样式.post-sticky-flag &#123; font-size: 15px; float: right; color: rgb(255, 0, 0); cursor: help; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s;&#125;.post-sticky-flag:hover &#123; color: #07b39b;&#125;// 菜单超链接字体大小.menu .menu-item a &#123; font-size: 15px;&#125; 添加右侧sidebar的微信扫描入口 添加CSS样式wechat.styl位置：~\blog\themes\next\source\css_common\components\sidebar 微信样式代码： 123456789101112131415161718192021222324252627282930313233343536373839404142.wechat &#123; position: fixed; right: $b2t-position-right; bottom: 70px; width: 14px; height: 14px; padding: 5px; background: $black-deep; line-height: 0; z-index: $zindex-3; cursor: pointer; -webkit-transform: translateZ(0); a &#123; text-decoration: none; color: $black-deep; border-bottom-color: $black-deep; &amp;:hover &#123; color: $yellow; &#125; &#125; +tablet() &#123; hide() if not hexo-config(&apos;sidebar.onmobile&apos;); &#125; +mobile() &#123; hide() if not hexo-config(&apos;sidebar.onmobile&apos;); &#125; &#125; .wechat-line &#123; position: relative; display: inline-block; vertical-align: top; height: 2px; width: 100%; background: white; margin-top: 3px; &amp;:first-child &#123; margin-top: 0; &#125;&#125; 在sidebar的总体CSS样式sidebar.styl中添加调用，最底部添加位置：~\blog\themes\next\source\css_common\components\sidebar 1@import &quot;wechat&quot;; 修改展示样式，添加微信扫描入口的icon位置修改~\blog\themes\next\layout_macro的sidebar.swig文件在文件顶部添加如下代码 123456&lt;div class=&quot;wechat&quot;&gt; &lt;a title=&quot;微信与我联系&quot; href=&quot;https://nolan-wu.github.io/contact/contact.html&quot; &gt; &lt;i class=&quot;fa fa-weixin&quot; aria-hidden=&quot;true&quot; style=&quot;color:#FFFFFF; font-size:13px;&quot;&gt; &lt;/i&gt; &lt;/a&gt;&lt;/div&gt; 配置完成后提交即可 添加文章访问密码 对文章进行密码设定，具体的实现如下对\themes\next\layout_partials目录下head.swig文件中添加如下代码： 12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 任何位置即可，具体样式如下： 配置完成后再每篇文章开头配置添加如下，即可实现密码才能访问 12345678910---title: Github主体优化（HEXO）date: 2018-02-01tags:- Githubcategories:- 学习随笔sticky: 7password: password--- 使用自定义页面的方法 Hexo默认会对/source/里的所有页面应用主题模板渲染，但有一些前端作品或demo页我们不希望经过渲染，而是能保持完全自定义的样子，解决方法如下 两种方法： 第一种：使用Hexo提供的跳过渲染配置，适用于整个目录的设置具体步骤，打开博客根目录_config.yml，找到其中skip_render项，这个项目用来配置/source/中需要跳过渲染的文件或目录，例如希望跳过/source/projects/里的所有文件渲染，可以配置为： 1skip_render: projects/** 在生成之前执行一下hexo clean命令，清除掉旧的生成文件和缓存 第二种：给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。例如我们的网站如果要使用百度统计，往往需要在根目录放一个html格式的验证文件，这个文件默认也会经过用主题模板渲染，避免渲染的办法就是在文件头部添加如下内容： 123---layout: false--- 访客统计 访客统计插件: 不蒜子参考：http://ibruce.info/2015/04/04/busuanzi/ 打开themes/hexo/layout/_partial/footer.swig添加下述脚本即可 1.引入脚本 1&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 2.引入标签 1.显示站点总访问量 算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数 &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; 人次&lt;/span&gt; 2.显示单页面访问量 要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量 123&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文总阅读量 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次&lt;/span&gt; 整体如下： 1234&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数 &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; 人次&lt;/span&gt; 效果如下： 其他的内容学习参考上文提及的连接]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github搭建个人博客]]></title>
    <url>%2F2018%2F02%2F01%2FGithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本篇内容主要是简单记录下搭建个人博客的整体方式，以防止后面博客迁移过程发生遗忘。不过距离个人博客搭建到现在，还真的是忘了差不多了… 整体博客的方式是Github + HEXO主题文章的编辑器为MarkdownPad，附带额外通过word文档直接转换为markdown格式的插件如下链接，但是该插件转换并不是特别准确http://www.writage.com/ 环境准备 Node.js 安装成功后cmd输入node -v查下版本号git 安装成功后右击鼠标出现“git gul here”则成功github官网注册账号 https://github.com/（备注下账号：name_mail@163.com 密码是namexuehao） git连接github github申请好后新建一个仓库 Repository name为访问域名，最好与Owner保持一致，如Owner为aaa，则设定的Repository name为aaa.github.io 绑定你的邮箱和名字 12$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;your_email@youremail.com&quot; 创建ssh key 在目标文件夹右键Git Bash Here，打开git bash命令工具，输入命令： 1$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 回车运行创建ssh文件，遇到停下来的一路回车即可，运行完成后会在C:\Users\admin\.ssh下生成两个文件： 利用编辑器打开rsa文件，将内容copy到github的设置页面中 配置完成后进行验证，输入如下命令： 1$ ssh -T git@github.com 回车看到：You’ve successfully authenticated, but GitHub does not provide shell access 。表示已成功连上github 将静态页面提交到github 修改_config.yml文件中deploy的参数 Hexo主题安装 安装HEXO主题，有其他主题，但太繁琐了，觉得HEXO已满足自己的需要hexo官网：http://hexo.io/zh-cn/ 安装方式： 12npm install hexo -g #-g表示全局安装, npm默认为当前项目安装npm install hexo-server --save #安装 hexo-server插件 建立一个hexo博客的文件夹，输入命令： 123hexo init &lt;folder&gt; #执行init命令初始化hexo到你指定的目录hexo generate #自动根据当前目录下文件,生成静态网页hexo server #运行本地服务 hexo常用命令 hexo init #初始化 hexo clean #清理临时文件 hexo g # 完整命令为hexo generate，生成静态文件 hexo s #完整命令为hexo server，打开本地服务 hexo d #完整命令为hexo deploy，用于将本地文件发布到github上 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo help #帮助 hexo d -g #同步至github hexo主题配置 修改_config.yml文件中的theme主题 通过修改next主题目录下的_config.yml的scheme字段，可配置不同的风格 打开浏览器输入http://localhost:4000看看你博客页面，搭建完成。]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python SMTP发送邮件]]></title>
    <url>%2F2018%2F01%2F30%2FPythonSMTP%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[SMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。 Python对SMTP支持有smtplib和email两个模块，email负责构造邮件，smtplib负责发送邮件。 本次学习仅针对简单地邮件发送，未对发送内容做定制学习，后续需要再补充学习 使用该模块前，需要确保要使用的SMTP已经开放了权限，对应需要进入邮箱中心的SMTP/POP3中设置 具体的实现代码如下： 12345678910111213141516171819202122232425# !/usr/bin/env python# -*- coding:utf-8 -*-import smtplib # python自带库from email.mime.text import MIMEText # 引入smtplib和MIMETexthost = 'smtp.163.com' # 设置发件服务器地址port = 25 # 设置发件服务器端口号。注意，这里有SSL和非SSL两种形式sender = 'g****@163.com' # 设置发件邮箱，一定要自己注册的邮箱pwd = '*******' # 设置发件邮箱的密码，这里设置的是授权码密码receivers = ['****ail@163.com', '2*****97@qq.com'] # 设置邮件接收人，可以是扣扣邮箱body = '&lt;h1&gt;Hi! Please note!!!&lt;/p&gt;' # 设置邮件正文，这里是支持HTML的msg = MIMEText(body, 'html') # 设置正文为符合邮件格式的HTML内容msg['subject'] = u'已达到设定的预价！ 现在为：' + moneymsg # 设置邮件标题msg['from'] = 'g*****op@163.com' # 设置发送人msg['To'] = ','.join(receivers) # 设置接收人try: s = smtplib.SMTP(host, port) # 注意！如果是使用SSL端口，这里就要改为SMTP_SSL s.login(sender, pwd) # 登陆邮箱 s.sendmail(sender, receivers, msg.as_string()) # 发送邮件！ print 'Done'except smtplib.SMTPException: print "Error: 无法发送邮件" 通过如上方式，即可正常发送邮件 如果运行后出现如下错误，即需要检查发送人信息是否与前面匹配，或者检查发送内容是否含特殊字眼，被邮箱规则拦截过滤或是发生了退信行为。 123456Traceback (most recent call last): File "/Users/xuexiaopeng/Documents/sendmailDemo.py", line 21, in &lt;module&gt; server.sendmail(from_addr, [to_addr], msg.as_string()) File "/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/smtplib.py", line 878, in sendmail raise SMTPDataError(code, resp)smtplib.SMTPDataError: (554, b'DT:SPM 163 smtp10,DsCowAA3h9_QbgZXI9_fCQ--.713S2 1460039376,please see http://mail.163.com/help/help_spam_16.htm?ip=117.114.147.187&amp;hostid=smtp10&amp;time=1460039376')]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线上纸白银价格自动监测小工具]]></title>
    <url>%2F2018%2F01%2F30%2F%E7%BA%BF%E4%B8%8A%E7%BA%B8%E7%99%BD%E9%93%B6%E4%BB%B7%E6%A0%BC%E8%87%AA%E5%8A%A8%E7%9B%91%E6%B5%8B%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[需求：想要监测线上纸白银的报价，设定一个预期值，当达到设定值之下则通过弹窗提示，直接告诉自己需要入手 采用的方法：python爬虫（因为是动态值，所以需要使用Seleium）、Easygui、bat批处理运行、windows自带的“计划任务” –&gt; 更新：实现了邮件通知的效果 实现的方式如下： 建设银行线上报价爬取 爬取建设银行线上白银的报价，然后比较设定的预期报价，如果达到预期之下，则弹窗告知，且显示目前的报价 具体的代码如下： 12345678910111213141516171819202122232425262728293031323334# -*- coding:utf-8 -*-# !/usr/bin/env pythonimport sysfrom selenium import webdriverimport easygui as gurl = 'http://tool.ccb.com/webtran/static/trendchart/index.html?stock_code=020001'driver = webdriver.PhantomJS(executable_path='D:/Python27/Lib/site-packages/phantomjs/phantomjs/bin/phantomjs.exe')driver.get(url)# 通过ID元素来查找具体位置，记得不能使用复合的元素名如（aa bb）中间含空格element_money = driver.find_element_by_css_selector('#newprice')# 查找目前的数值money_get = element_money.text# 对目前的报价进行预期匹配money_get = float(money_get)data_need = money_get + 0.010# 对这个data值进行四舍五入，保留三位小数data = round(data_need, 3)data_want = float(3.520)# 判断大小，吻合则提示if data &gt; data_want: print u"未达到预期，退出程序" sys.exit()else: msg = '已达到设定值，白银现价：', data # print msg title = '白银检测结果达到预期' ok_button = '退出' g.msgbox(msg, title, ok_button) 上方涉及到动态信息的爬取，这个另起日志说明 效果如下： 程序设置想要的预期值 通过Python的Easygui的简单输入框，设定新的预期值，且打开程序要显示目前的设定值，其实际的方式是利用python的os去对文件进行修改内容，具体的在文件的某行插入某信息的方法另起日志 具体的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/python# -*- coding:utf-8 -*-import easygui as gimport sys# 定义函数用来输入预期值class Numbwant(): def numb_want(self): numb = self.numb # 对文件内容进行修改替换 # 打开文件 fo = open("E:\\Python\\EXE_TEST\\Silver_quote.py", "r+") alldata = fo.readlines() # 修改对应改行的信息 data_want = float(3.520) msg1 = 'data_want = float(' msg2 = numb + ')\n' msg_change = msg1 + msg2 alldata[21] = msg_change # print alldata[21] # 关闭打开的文件 fo.close() # 将修改完的信息，全部再次写入文件生效 fo = open("E:\\Python\\EXE_TEST\\Silver_quote.py", "w+") fo.writelines(alldata) # 关闭打开的文件 fo.close() # 校验结果并做返回 fo = open("E:\\Python\\EXE_TEST\\Silver_quote.py", "r+") checkdata = fo.readlines() result = checkdata[21] re = result[18:-2] # print re if re == numb: g.msgbox('预期价位设置成功', title='设定白银检测的预期值', ok_button='退出') else: g.msgbox('预期价位设置失败', title='设定白银检测的预期值', ok_button='退出') return def __init__(self, numb): self.numb = numb# ----------------------------------------------------------------# 主体程序如下# 打开文件fo = open("E:\\Python\\EXE_TEST\\Silver_quote.py", "r")alldata = fo.readlines()nu = alldata[21]setnumb = nu[18:-2]# 关闭打开的文件fo.close()# 新建窗口提示目前的预期设置msg = '是否修改当前设定的预期值：', setnumbtitle = '设定白银检测的预期值'fieldNames = ['']fieldValues = []fieldValues = g.multenterbox(msg, title, fieldNames, fieldValues)if fieldValues == None: sys.exit()new_numb = fieldValues[0]# 调用函数setup = Numbwant(new_numb)setup.numb_want() 效果如下： 这里是使用了Easygui的multenterbox模块函数，两项按钮则是通过修改easygui的源代码的按钮文案实现 打包预期设定为exe程序 因为“程序设置想要的预期值”这一块修改了Easygui的源码，所以需要将其打包成exe直接调用运行，才好恢复Easygui 打包方式仍然选择pyinstaller方式进行打包，这里为了区分这个小工具，修改了icon，需要自定义了一个图片，通过http://www.ico.la/网站做了转换格式，具体的打包在pyinstaller目录下执行如下语句： 1pyintaller -F -w --hidden-import=queue -i "test.ico" "Silver_set.py" 打包完成后则可以在dist目录下查看到该工具 用批处理运行白银现价的爬取脚本 本来是通过任务管理直接运行python脚本，但发现因为使用的selenium的第三方插件phantomjs，运行会失败，所以改用批处理的形式 批处理选择在后台运行，不出运行框具体的代码如下： 12python Silver_quote.pyexit 另起vbs文件用来后台调用该bat文件具体的代码如下： 12Set ws = CreateObject("Wscript.Shell") ws.run "cmd /c E:\Python\EXE_TEST\sliver\silver_check.bat",vbhide 配置任务计划自动运行 通过配置windows自带的“任务计划”自动运行爬虫程序和预设值程序控制面板\系统和安全\计划任务 到这里就完成了监测价格，到达预期则弹窗提示的功能，后面研究实现通过邮件来进行通知 实现了邮件通知的效果 引入python的邮件模块smtplib，所以优化了实现模式，除了弹窗提醒，还通过邮件进行通知，具体的实效代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# -*- coding:utf-8 -*-# !/usr/bin/env pythonimport sysfrom selenium import webdriverimport easygui as gimport smtplib # python自带库from email.mime.text import MIMEText # 引入smtplib和MIMEText# ----------------------------------------- 引入邮件发送的函数 ---------------------------------------------class Email: # 定义邮件发送的调用函数 def sendemail(self): host = 'smtp.163.com' # 设置发件服务器地址 port = 25 # 设置发件服务器端口号。注意，这里有SSL和非SSL两种形式 sender = 'goo****@163.com' # 设置发件邮箱，一定要自己注册的邮箱 pwd = '******2' # 设置发件邮箱的密码，等会登陆会用到 receivers = ['****@163.com', '279****97@qq.com'] # 设置邮件接收人，可以是扣扣邮箱 body = '&lt;h1&gt;Hi! Please note that quote !!!&lt;/p&gt;' # 设置邮件正文，这里是支持HTML的 # 调用爬取到的价钱 moneymsg = '%s' % self.money msg = MIMEText(body, 'html') # 设置正文为符合邮件格式的HTML内容 msg['subject'] = u'已达到设定的预价！ 现在为：' + moneymsg # 设置邮件标题 msg['from'] = 'goo*****p@163.com' # 设置发送人 msg['To'] = ','.join(receivers) # 设置接收人 s = smtplib.SMTP(host, port) # 注意！如果是使用SSL端口，这里就要改为SMTP_SSL s.login(sender, pwd) # 登陆邮箱 s.sendmail(sender, receivers, msg.as_string()) # 发送邮件！ print 'Done' return def __init__(self, money): self.money = money# ---------------------------------------------- 主体程序 --------------------------------------------------url = 'http://tool.ccb.com/webtran/static/trendchart/index.html?stock_code=020001'driver = webdriver.PhantomJS(executable_path='D:/Python27/Lib/site-packages/phantomjs/phantomjs/bin/phantomjs.exe')driver.get(url)# 通过ID元素来查找具体位置，记得不能使用复合的元素名如（aa bb）中间含空格element_money = driver.find_element_by_css_selector('#newprice')# 查找目前的数值money_get = element_money.text# 对目前的报价进行预期匹配money_get = float(money_get)data_need = money_get + 0.010# 对这个data值进行四舍五入，保留三位小数data = round(data_need, 3)data_want = float(3.580)# 判断大小，吻合则提示if data &gt; data_want: print u"未达到预期，退出程序" sys.exit()else: # 调用邮件函数Emai print data sendem = Email(data) sendem.sendemail() # windows窗口提示 msg = '已达到设定值，白银现价：', data # print msg title = '白银检测结果达到预期' ok_button = '退出' g.msgbox(msg, title, ok_button) 因为考虑到在邮件标题上显示报价，所以使用了类和函数，对应修改设定金额的脚本也需要调整修改的行数位置。运行即可成功发送邮件。]]></content>
      <categories>
        <category>实际运用</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Selenium</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python修改文件指定行]]></title>
    <url>%2F2018%2F01%2F29%2FPython%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[使用python进行简单的文件读写 例一： 12345678#!/usr/bin/python import sys import re if __name__=="__main__": f=file("hi.txt","w+") li=["hello\n","hi\n"] f.writelines(li) f.close() “W+”模式：如果没有hi.txt则创建文件写入；如果存在，则清空hi.txt内容，重新写入。 例二：修改文件指定行 用的方法比较笨，将文件内容按行读入到一个列表中，修改指定行即给列表中元素赋值；修改完后，用writelines将列表重新写入文件。 123456789#!/usr/bin/python import sys,os f=open('hi.txt','r+') flist=f.readlines() flist[4]='hi\n' f=open('hi.txt','w+') f.writelines(flist) 将hi.txt第五行内容修改为hi]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取js动态生成的网页信息]]></title>
    <url>%2F2018%2F01%2F29%2FPython%E7%88%AC%E5%8F%96js%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[需求场景：针对那些动态信息，通过简单地BeautifulSoup或者Requests均无法获取到所需要的信息，也就是标签内的内容是js生成的，源网页不存在。所以需要通过Selenium模拟正常浏览行为，配合工具Phantomjs来获取该动态值 selenium是一个用于web应用程测试的工具，后面再自己展开学习 安装方式： pip install selenium PhantomJS是一个基于webkit的JavaScript API。它使用QtWebKit作为它核心浏览器的功能，使用webkit来编译解释执行JavaScript代码。任何你可以在基于webkit浏览器做的事情，它都能做到。它不仅是个隐形的浏览器，提供了诸如CSS选择器、支持Web标准、DOM操作、JSON、HTML5、Canvas、SVG等，同时也提供了处理文件I/O的操作，从而使你可以向操作系统读写文件等。PhantomJS的用处可谓非常广泛，诸如网络监测、网页截屏、无需浏览器的Web 测试、页面访问自动化等。 下载地址：http://phantomjs.org/download.html链接：https://pan.baidu.com/s/1ghmzlT5 密码：00si使用方法：解压后找到bin目录下的phantomjs.exe，把该位置配置到环境变量的PATH路径下代码实现方式 12345from selenium import webdriverurl = "http://www.eshow365.com/zhanhui/html/120062_0.html"driver = webdriver.PhantomJS(executable_path='E:/phantomjs/bin/phantomjs.exe')//这个路径就是你添加到PATH的路径driver.get(url)print (driver.page_source) 运行改代码就可以爬取到相应信息但是要获取到该值，则需要采用.text去获取 如下为学习爬取某动态信息的方法： 12345678910from selenium import webdriverurl = 'http://to.cb.com/'driver = webdriver.PhantomJS(executable_path='D:/Python27/Lib/site-packages/phantomjs/phantomjs/bin/phantomjs.exe')driver.get(url)# 通过ID元素来查找具体位置，记得不能使用复合的元素名如（aa bb）中间含空格element_money = driver.find_element_by_css_selector('#newprice')# 查找目前的数值money_get = element_money.text]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python跳出多重循环]]></title>
    <url>%2F2018%2F01%2F16%2FPython%E8%B7%B3%E5%87%BA%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[Python跳出多重循环，可以利用全局变量，这样就算有3个for或者4个for都是一样的，具体的格式如下立flag： 12345678exit_flag = falsefor 循环: for 循环: if 条件: exit_flag = true break # 跳出内部循环 if exit_flag: break # 跳出外部循环 举例，以本次小工具开发中使用的场景做备注： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364elif sqlsource == u"测试环境（ssj0513库）": while 1: firstbos_msg = "请问你希望做如下哪些操作？" firstbos_title = "随手借测试小工具" firstbos_choices = ["*提交身份认证", "*提交三项基本资料项", "*具备直接借款的能力", \ "提交运营商资料", "提交芝麻信用资料", "提交深圳社保资料"] reply = g.choicebox(firstbos_msg, firstbos_title, firstbos_choices) if reply == u"*提交身份认证": iden_msg = "请输入如下关键信息：\n 注：若需要使用芝麻信用，请确保提交的姓名和身份证相匹配 \n" iden_title = "随手借测试小工具" iden_fieldNames = ["手机号码", "用户姓名", "身份证号"] fieldValues = [] # we start with blanks for the values fieldValues = g.multenterbox(iden_msg, iden_title, iden_fieldNames) exit_flag = 'false' while 1: if fieldValues == None: exit_flag = 'true' break errmsg = "" for i in range(len(iden_fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" 为必填项！\n\n' % iden_fieldNames[i]) if errmsg == "": break # no problems found fieldValues = g.multenterbox(errmsg, iden_title, iden_fieldNames, fieldValues) if exit_flag == 'true': continue #print "Reply was:", fieldValues source = '2' # 调用数据库函数userid_get phone = fieldValues[0] userid_result = UserID(source, phone) userid = userid_result.userid_get() time.sleep(1) # 调用数据库函数identity_in name = fieldValues[1] identityno = fieldValues[2] identity_result = Identity(source, userid, name, identityno) identity_in_result = identity_result.identity_in() print identity_in_result if identity_in_result == '身份认证成功': msg = "执行成功，是否继续进行操作？" title = "随手借测试小工具" boolbox = g.boolbox(msg, title, choices=('继续', '退出')) if boolbox == 1: continue else: sys.exit() else: g.msgbox("执行失败，请联系测试人员！", title="随手借测试小工具", ok_button="退出") sys.exit()]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象]]></title>
    <url>%2F2018%2F01%2F16%2FPython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象技术简介 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 实例变量：定义在方法中的变量，只作用于当前实例的类。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 创建类 使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾： 123class ClassName: '类的帮助信息' #类文档字符串 class_suite #类体 类的帮助信息可以通过ClassName.doc查看。class_suite 由类成员，方法，数据属性组成。 实例 1234567891011121314151617#!/usr/bin/python# -*- coding: UTF-8 -*- class Employee: '所有员工的基类' empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print "Total Employee %d" % Employee.empCount def displayEmployee(self): print "Name : ", self.name, ", Salary: ", self.salary empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。 第一种方法__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法 self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。 self代表类的实例，而非类类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 1234567class Test: def prt(self): print(self) print(self.__class__) t = Test()t.prt() 以上实例执行结果为： 12&lt;__main__.Test instance at 0x10d066878&gt;__main__.Test 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的: 实例 1234567class Test: def prt(runoob): print(runoob) print(runoob.__class__) t = Test()t.prt() 以上实例执行结果为： 12&lt;__main__.Test instance at 0x10d066878&gt;__main__.Test 创建实例对象 实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。以下使用类的名称 Employee 来实例化，并通过 __init__ 方法接受参数。 1234"创建 Employee 类的第一个对象"emp1 = Employee("Zara", 2000)"创建 Employee 类的第二个对象"emp2 = Employee("Manni", 5000) 访问属性 您可以使用点(.)来访问对象的属性。使用如下类的名称访问类变量: 123emp1.displayEmployee()emp2.displayEmployee()print "Total Employee %d" % Employee.empCount 实例 12345678910111213141516171819202122232425#!/usr/bin/python# -*- coding: UTF-8 -*- class Employee: '所有员工的基类' empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print "Total Employee %d" % Employee.empCount def displayEmployee(self): print "Name : ", self.name, ", Salary: ", self.salary "创建 Employee 类的第一个对象"emp1 = Employee("Zara", 2000)"创建 Employee 类的第二个对象"emp2 = Employee("Manni", 5000)emp1.displayEmployee()emp2.displayEmployee()print "Total Employee %d" % Employee.empCount 执行以上代码输出结果如下： 123Name : Zara ,Salary: 2000Name : Manni ,Salary: 5000Total Employee 2 你可以添加，删除，修改类的属性，如下所示： 123emp1.age = 7 # 添加一个 'age' 属性emp1.age = 8 # 修改 'age' 属性del emp1.age # 删除 'age' 属性 你也可以使用以下函数的方式来访问属性： getattr(obj, name[, default]) : 访问对象的属性。 hasattr(obj,name) : 检查是否存在一个属性。 setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。 delattr(obj, name) : 删除属性。 1234hasattr(emp1, 'age') # 如果存在 'age' 属性返回 True。getattr(emp1, 'age') # 返回 'age' 属性的值setattr(emp1, 'age', 8) # 添加属性 'age' 值为 8delattr(emp1, 'age') # 删除属性 'age' Python内置类属性 __dict__: 类的属性（包含一个字典，由类的数据属性组成） __doc__:类的文档字符串 __name__: 类名 __module__: 类定义所在的模块（类的全名是’__main__.className‘，如果类位于一个导入模块mymod中，那么className.module 等于 mymod） __bases__: 类的所有父类构成元素（包含了一个由所有父类组成的元组） Python内置类属性调用实例如下： 1234567891011121314151617181920212223#!/usr/bin/python# -*- coding: UTF-8 -*- class Employee: '所有员工的基类' empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print "Total Employee %d" % Employee.empCount def displayEmployee(self): print "Name : ", self.name, ", Salary: ", self.salary print "Employee.__doc__:", Employee.__doc__print "Employee.__name__:", Employee.__name__print "Employee.__module__:", Employee.__module__print "Employee.__bases__:", Employee.__bases__print "Employee.__dict__:", Employee.__dict__ 执行以上代码输出结果如下： 12345Employee.__doc__: 所有员工的基类Employee.__name__: EmployeeEmployee.__module__: __main__Employee.__bases__: ()Employee.__dict__: &#123;'__module__': '__main__', 'displayCount': &lt;function displayCount at 0x10a939c80&gt;, 'empCount': 0, 'displayEmployee': &lt;function displayEmployee at 0x10a93caa0&gt;, '__doc__': '\xe6\x89\x80\xe6\x9c\x89\xe5\x91\x98\xe5\xb7\xa5\xe7\x9a\x84\xe5\x9f\xba\xe7\xb1\xbb', '__init__': &lt;function __init__ at 0x10a939578&gt;&#125; python对象销毁(垃圾回收) Python 使用了引用计数这一简单技术来跟踪和回收垃圾。在 Python 内部记录着所有使用中的对象各有多少引用。一个内部跟踪变量，称为一个引用计数器。当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时，它被垃圾回收。但是回收不是”立即”的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。 1234567a = 40 # 创建对象 &lt;40&gt;b = a # 增加引用， &lt;40&gt; 的计数c = [b] # 增加引用. &lt;40&gt; 的计数del a # 减少引用 &lt;40&gt; 的计数b = 100 # 减少引用 &lt;40&gt; 的计数c[0] = -1 # 减少引用 &lt;40&gt; 的计数 垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来，试图清理所有未引用的循环。 析构函数 __del__ ，__del__在对象销毁的时候被调用，当对象不再被使用时，__del__方法运行： 123456789101112131415161718#!/usr/bin/python# -*- coding: UTF-8 -*- class Point: def __init__( self, x=0, y=0): self.x = x self.y = y def __del__(self): class_name = self.__class__.__name__ print class_name, "销毁" pt1 = Point()pt2 = pt1pt3 = pt1print id(pt1), id(pt2), id(pt3) # 打印对象的iddel pt1del pt2del pt3 以上实例运行结果如下： 123083401324 3083401324 3083401324Point 销毁 注意：通常你需要在单独的文件中定义一个类 类的继承 面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。继承完全可以理解成类之间的类型和子类型关系。需要注意的地方：继承语法 class 派生类名（基类名）：//… 基类名写在括号里，基本类是在类定义的时候，在元组之中指明的。在python中继承中的一些特点： 1：在继承中基类的构造（__init__()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用。 2：在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别在于类中调用普通函数时并不需要带上self参数 3：Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。 如果在继承元组中列了一个以上的类，那么它就被称作”多重继承”。语法：派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示： 123class SubClassName (ParentClass1[, ParentClass2, ...]): 'Optional class documentation string' class_suite 实例 1234567891011121314151617181920212223242526272829#!/usr/bin/python# -*- coding: UTF-8 -*- class Parent: # 定义父类 parentAttr = 100 def __init__(self): print "调用父类构造函数" def parentMethod(self): print '调用父类方法' def setAttr(self, attr): Parent.parentAttr = attr def getAttr(self): print "父类属性 :", Parent.parentAttr class Child(Parent): # 定义子类 def __init__(self): print "调用子类构造方法" def childMethod(self): print '调用子类方法' c = Child() # 实例化子类c.childMethod() # 调用子类的方法c.parentMethod() # 调用父类方法c.setAttr(200) # 再次调用父类的方法 - 设置属性值c.getAttr() # 再次调用父类的方法 - 获取属性值 以上代码执行结果如下： 1234调用子类构造方法调用子类方法调用父类方法父类属性 : 200 你可以继承多个类 12345678class A: # 定义类 A.....class B: # 定义类 B.....class C(A, B): # 继承类 A 和 B..... 你可以使用issubclass()或者isinstance()方法来检测。 issubclass() 布尔函数判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub,sup) isinstance(obj, Class) 布尔函数如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true 方法重写 如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法： 实例 12345678910111213#!/usr/bin/python# -*- coding: UTF-8 -*- class Parent: # 定义父类 def myMethod(self): print '调用父类方法' class Child(Parent): # 定义子类 def myMethod(self): print '调用子类方法' c = Child() # 子类实例c.myMethod() # 子类调用重写方法 执行以上代码输出结果如下： 1调用子类方法 基础重载方法 方法 描述 &amp; 简单的调用 __init__(self [,args...]) 构造函数 简单的调用方法: obj = className(args) __del__(self) 析构方法, 删除一个对象 简单的调用方法 : del obj __repr__(self) 转化为供解释器读取的形式 简单的调用方法 : repr(obj) __str__(self) 用于将值转化为适于人阅读的形式 简单的调用方法 : str(obj) __cmp__ (self, x) 对象比较 简单的调用方法 : cmp(obj, x) 运算符重载 Python同样支持运算符重载，实例如下： 12345678910111213141516#!/usr/bin/python class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print v1 + v2 以上代码执行结果如下所示: 1Vector(7,8) 类属性与方法 类的私有属性 **__private_attrs**：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。 类的方法 在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数 类的私有方法 **__private_method**：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.__private_methods 实例 1234567891011121314151617#!/usr/bin/python# -*- coding: UTF-8 -*- class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print self.__secretCount counter = JustCounter()counter.count()counter.count()print counter.publicCountprint counter.__secretCount # 报错，实例不能访问私有变量 Python 通过改变名称来包含类名: 1234567122Traceback (most recent call last): File "test.py", line 17, in &lt;module&gt; print counter.__secretCount # 报错，实例不能访问私有变量AttributeError: JustCounter instance has no attribute '__secretCount' Python不允许实例化的类访问私有数据，但你可以使用 object._className__attrName 访问属性，将如下代码替换以上代码的最后一行代码： 12.........................print counter._JustCounter__secretCount 执行以上代码，执行结果如下： 12341222 单下划线、双下划线、头尾双下划线说明： __foo__: 定义的是特殊方法，一般是系统定义名字，类似__init__()之类的 _foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import * __foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试项目小工具开发（针对目前项目APP）]]></title>
    <url>%2F2018%2F01%2F15%2FPython%E9%A1%B9%E7%9B%AE%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[需求： 想通过Python与MySQLdb模块，实现输入简易的信息，完成身份认证 实现注册、身份认证、工作资料、通讯录等的验证信息提交，实现一步到位可以直接验证某个新功能的效果 工具的开发结合了可视化界面的学习，通过可视化工具来实现，使用了新的图形模块EasyGUI，实现了简易的图形界面 本次工具涉及到如下的知识点: Mysqldb easygui python面向对象和类/函数的使用 小工具实现效果如下： 全部代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753#!/usr/bin/python# -*- coding: UTF-8 -*-import timeimport MySQLdbimport easygui as gimport sys############################### 用户userid查询 ###################################class UserID: # 用来查询UserID def userid_get(self): q = self.source if q == '1': # 打开数据库连接 db = MySQLdb.connect("120.24.67.22", "root", "Audaque2017", "test", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 查询输入手机号的UserID p = self.phone.encode('utf-8') sql3 = "SELECT a.`ID` FROM `user_base_info` a WHERE a.`Phone` = '%s' " % (p) try: # 执行sql语句 cursor.execute(sql3) result = cursor.fetchall() for row in result: userid = row[0] # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "用户UserID查询成功" print result # 关闭数据库连接 db.close() return userid elif q == '2': # 打开数据库连接 db = MySQLdb.connect("172.16.1.81", "root", "Audaque2017.com", "ssj0513", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 查询输入手机号的UserID p = self.phone.encode('utf-8') sql3 = "SELECT a.`ID` FROM `user_base_info` a WHERE a.`Phone` = '%s' " % (p) try: # 执行sql语句 cursor.execute(sql3) result = cursor.fetchall() for row in result: userid = row[0] # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "用户UserID查询成功" print result # 关闭数据库连接 db.close() return userid else: print "fail" sys.exit() def __init__(self, source, phone): self.source = source self.phone = phone############################## 姓名/身份证查询 ###################################class Info: # 根据用户userid来查询姓名和身份证号 def info_search(self): q = self.source if q == '1': # 打开数据库连接 db = MySQLdb.connect("120.24.67.22", "root", "Audaque2017", "test", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 查询用户的身份证和姓名 b = self.userid sql = "SELECT a.`Identity_Name`, a.`Identity_No` FROM `user_identity_info` AS a WHERE a.`UserID` = '%s' " % (b) try: # 执行sql语句 cursor.execute(sql) result = cursor.fetchall() for row in result: name = row[0] identity = row[1] # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "查询姓名身份证成功" print result # print name # print identity # 关闭数据库连接 db.close() return row elif q == '2': # 打开数据库连接 db = MySQLdb.connect("172.16.1.81", "root", "Audaque2017.com", "ssj0513", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 查询用户的身份证和姓名 b = self.userid sql = "SELECT a.`Identity_Name`, a.`Identity_No` FROM `user_identity_info` AS a WHERE a.`UserID` = '%s' " % (b) try: # 执行sql语句 cursor.execute(sql) result = cursor.fetchall() for row in result: name = row[0] identity = row[1] # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "查询姓名身份证成功" print result # print name # print identity # 关闭数据库连接 db.close() return row else: print "fail" sys.exit() def __init__(self, source, userid): self.source = source self.userid = userid############################### 身份认证提交 ###################################class Identity: # 用来添加身份认证信息 def identity_in(self): q = self.source if q == '1': # 打开数据库连接 db = MySQLdb.connect("120.24.67.22", "root", "Audaque2017", "test", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 针对时间进行特殊处理 usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 global userid a = self.userid b = self.name.encode('utf-8') c = self.identityno.encode('utf-8') # 插入身份证信息SQL语句 sql1 = "INSERT INTO `user_identity_info` (UserID, Identity_Name, Identity_Sex, Identity_Birthday, \ Identity_No, Identity_Addr, Identity_Validity, Identity_LiveArea, Identity_LiveAddr, Identity_SubmitTime, \ Identity_AuthState, Identity_ReviewUser, Identity_ReviewTime, Identity_CloseTime, WideTableID) \ VALUE ('%s', '%s', '1','1986年07月08日', '%s', '软件大厦', '20170808-20270808', \ '222312', '科技中三路靠近软件大厦', '%s', '5', '2', '%s', \ '2920-08-30 13:20:00', 'BC07FC0D9A3BE739E9E65DB831E3EED8') " % \ (a, b, c, usertime, usertime) # 修改身份证认证状态SQL语句 sql2 = "UPDATE `user_base_info` AS a SET a.`Auth_Identity` = '5' WHERE a.`ID` = '%s' " % (a) try: # 执行sql语句 cursor.execute(sql1) cursor.execute(sql2) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "身份认证成功" print result # 关闭数据库连接 db.close() return result elif q == '2': # 打开数据库连接 db = MySQLdb.connect("172.16.1.81", "root", "Audaque2017.com", "ssj0513", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 针对时间进行特殊处理 usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 global userid a = self.userid b = self.name.encode('utf-8') c = self.identityno.encode('utf-8') # 插入身份证信息SQL语句 sql1 = "INSERT INTO `user_identity_info` (UserID, Identity_Name, Identity_Sex, Identity_Birthday, \ Identity_No, Identity_Addr, Identity_Validity, Identity_LiveArea, Identity_LiveAddr, Identity_SubmitTime, \ Identity_AuthState, Identity_ReviewUser, Identity_ReviewTime, Identity_CloseTime, WideTableID) \ VALUE ('%s', '%s', '1','1986年07月08日', '%s', '软件大厦', '20170808-20270808', \ '222312', '科技中三路靠近软件大厦', '%s', '5', '2', '%s', \ '2920-08-30 13:20:00', 'BC07FC0D9A3BE739E9E65DB831E3EED8') " % \ (a, b, c, usertime, usertime) # 修改身份证认证状态SQL语句 sql2 = "UPDATE `user_base_info` AS a SET a.`Auth_Identity` = '5' WHERE a.`ID` = '%s' " % (a) try: # 执行sql语句 cursor.execute(sql1) cursor.execute(sql2) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "身份认证成功" print result # 关闭数据库连接 db.close() return result else: print "fail" sys.exit() def __init__(self, source, userid, name, identityno): self.source = source self.userid = userid self.name = name self.identityno = identityno############################### 提交基本资料项的通讯录/工作 ###################################class ContactsWork: # 用来添加work def contacts_work_in(self): q = self.source if q == '1': # 打开数据库连接 db = MySQLdb.connect("120.24.67.22", "root", "Audaque2017", "test", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 针对时间进行特殊处理 usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 a = self.userid # 插入工作信息SQL语句 sql1 = "INSERT INTO `user_work_info` (UserID, Work_Company, Work_Phone, Work_Position, Work_SubmitTime, \ Work_AuthState, Work_ReviewUser, Work_ReviewTime, Work_CloseTime, work_phoneaddress, Work_CompanyType) \ VALUE ('%s', 'audaque', '0755-88888888', '5', '%s', '5', '9999', '%s', '2920-08-30 13:20:00', \ '2223', '2') " % (a, usertime, usertime) # 插入联系人信息SQL语句 sql2 = "INSERT INTO `user_contacts_info` (UserID, Contacts1_Relation, Contacts1_Name, Contacts1_Phone, \ Contacts2_Relation, Contacts2_Name, Contacts2_Phone, Contacts_SubmitTime, Contacts_AuthState, \ Contacts_ReviewUser, Contacts_ReviewTime, Contacts_CloseTime, contacts1_phone_address, contacts2_phone_address) \ VALUE ('%s', '2', '小明', '15817366666', '4', '小红', '15817377777', '%s', '5', \ '9999', '%s', '2920-08-30 13:20:00', '2223', '2223') " % (a, usertime, usertime) # 修改用户工作和联系人状态SQL语句 sql3 = "UPDATE `user_base_info` AS a SET a.`Auth_Work` = '5' , a.`Auth_Contacts` = '5' WHERE a.`ID` = '%s'" % ( a) try: # 执行sql语句 cursor.execute(sql1) cursor.execute(sql2) cursor.execute(sql3) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "两项资料项提交成功" print result # 关闭数据库连接 db.close() return result elif q == '2': # 打开数据库连接 db = MySQLdb.connect("172.16.1.81", "root", "Audaque2017.com", "ssj0513", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 针对时间进行特殊处理 usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 a = self.userid # 插入工作信息SQL语句 sql1 = "INSERT INTO `user_work_info` (UserID, Work_Company, Work_Phone, Work_Position, Work_SubmitTime, \ Work_AuthState, Work_ReviewUser, Work_ReviewTime, Work_CloseTime, work_phoneaddress, Work_CompanyType) \ VALUE ('%s', 'audaque', '0755-88888888', '5', '%s', '5', '9999', '%s', '2920-08-30 13:20:00', \ '2223', '2') " % (a, usertime, usertime) # 插入联系人信息SQL语句 sql2 = "INSERT INTO `user_contacts_info` (UserID, Contacts1_Relation, Contacts1_Name, Contacts1_Phone, \ Contacts2_Relation, Contacts2_Name, Contacts2_Phone, Contacts_SubmitTime, Contacts_AuthState, \ Contacts_ReviewUser, Contacts_ReviewTime, Contacts_CloseTime, contacts1_phone_address, contacts2_phone_address) \ VALUE ('%s', '2', '小明', '15817366666', '4', '小红', '15817377777', '%s', '5', \ '9999', '%s', '2920-08-30 13:20:00', '2223', '2223') " % (a, usertime, usertime) # 修改用户工作和联系人状态SQL语句 sql3 = "UPDATE `user_base_info` AS a SET a.`Auth_Work` = '5' , a.`Auth_Contacts` = '5' WHERE a.`ID` = '%s'" % ( a) try: # 执行sql语句 cursor.execute(sql1) cursor.execute(sql2) cursor.execute(sql3) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "两项资料项提交成功" print result # 关闭数据库连接 db.close() return result else: print "fail" sys.exit() def __init__(self, source, userid): self.source = source self.userid = userid############################### 提交芝麻信用750达到借款条件 ###################################class ZMXY: # 用来芝麻信用认证 def zmxy_in(self): q = self.source if q == '1': # 打开数据库连接 db = MySQLdb.connect("120.24.67.22", "root", "Audaque2017", "test", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 针对时间进行特殊处理 usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 global userid a = self.userid # 插入芝麻信用信息SQL语句 sql1 = "INSERT INTO `user_zmxy_info` (UserID, open_id, zmScore, bizNo, transactionId, ZMXY_SubmitTime, \ ZMXY_AuthState, ZMXY_ReviewUser, ZMXY_ReviewTime, ZMXY_CloseTime) \ VALUES ('%s', '268814283732545550065852222', '750', 'ZM201708013000000839700494250121', \ 'd9f937ff-d470-4650-ab23-035b823965fd', '%s', '5', '9999', '%s', '2920-08-30 13:20:00') " % ( a, usertime, usertime) # 修改芝麻信用认证状态SQL语句 sql2 = "UPDATE `user_base_info` AS a SET a.`Auth_ZMXY` = '5' WHERE a.`ID` = '%s' " % (a) # 修改额度表的使用数值 sql3 = "UPDATE `user_account_info` AS c SET c.`MaxAmount` = '7600', c.`SurplusAmount` = '7600' \ WHERE c.`ID` = '%s'" % (a) # 增加银行卡SQL sql4 = "INSERT INTO `user_bank_account` (UserID, BankCode, AccountNo, Phone, AuthState, UseState, \ ADDTIME, isMainCard) \ VALUES ('%s', '11', '6226220601230123123', '13800000000', \ '6', '1', '%s', '1') " % (a, usertime) try: # 执行sql语句 cursor.execute(sql1) cursor.execute(sql2) cursor.execute(sql3) cursor.execute(sql4) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "借款能力已具备" print result # 关闭数据库连接 db.close() return result elif q == '2': # 打开数据库连接 db = MySQLdb.connect("172.16.1.81", "root", "Audaque2017.com", "ssj0513", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 针对时间进行特殊处理 usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 global userid a = self.userid # 插入芝麻信用信息SQL语句 sql1 = "INSERT INTO `user_zmxy_info` (UserID, open_id, zmScore, bizNo, transactionId, ZMXY_SubmitTime, \ ZMXY_AuthState, ZMXY_ReviewUser, ZMXY_ReviewTime, ZMXY_CloseTime) \ VALUES ('%s', '268814283732545550065852222', '750', 'ZM201708013000000839700494250121', \ 'd9f937ff-d470-4650-ab23-035b823965fd', '%s', '5', '9999', '%s', '2920-08-30 13:20:00') " % ( a, usertime, usertime) # 修改芝麻信用认证状态SQL语句 sql2 = "UPDATE `user_base_info` AS a SET a.`Auth_ZMXY` = '5' WHERE a.`ID` = '%s' " % (a) # 修改额度表的使用数值 sql3 = "UPDATE `user_account_info` AS c SET c.`MaxAmount` = '7600', c.`SurplusAmount` = '7600' \ WHERE c.`ID` = '%s'" % (a) # 增加银行卡SQL sql4 = "INSERT INTO `user_bank_account` (UserID, BankCode, AccountNo, Phone, AuthState, UseState, \ ADDTIME, isMainCard) \ VALUES ('%s', '11', '6226220601230123123', '13800000000', \ '6', '1', '%s', '1') " % (a, usertime) try: # 执行sql语句 cursor.execute(sql1) cursor.execute(sql2) cursor.execute(sql3) cursor.execute(sql4) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "借款能力已具备" print result # 关闭数据库连接 db.close() return result else: print "fail" sys.exit() def __init__(self, source, userid): self.source = source self.userid = userid############################### 提交运营商授权 ###################################class Operator: # 用来添加身份认证信息 def operator_in(self): q = self.source if q == '1': # 打开数据库连接 db = MySQLdb.connect("120.24.67.22", "root", "Audaque2017", "test", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 针对时间进行特殊处理 usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 global userid a = self.userid b = self.phone.encode('utf-8') c = self.name.encode('utf-8') d = self.month.encode('utf-8') # 插入运营商详情信息SQL语句 sql1 = "INSERT INTO `nq_co_base` (UserId, userName, userPwd, CustName, OcType, OpenDate, OpenDateSrc, \ TotalMonth, TotalMonthSrc, AccountBalance, AccountBalanceSrc, FlowBalance, FlowBalanceSrc, \ CityCode, CityName, ShowOcType) \ VALUES ('%s', '%s', '123456', '%s', '2', '2016-01-01 00:00:00', '20160101', '%s', \ '%s', '1000.00', '1000.00', '2000.00', '2000.00', '2223', '广东-深圳市', '中国移动') " % \ (a, b, c, d, d) # 插入运营商用户信息SQL语句 sql2 = "INSERT INTO `user_co_info` (UserID, ValidatePhone, ServiceCode, CityCode, cityName, CO_Type, \ CO_Type_Name, CO_SubmitTime, CO_AuthState, CO_ReviewUser, CO_ReviewTime, CO_CloseTime) \ VALUES ('%s', '%s', '123456', '2223', '广东-深圳市', '2', '中国移动', \ '%s', '5', '9999', '%s', '2920-08-30 13:20:00')" % (a, b, usertime, usertime) # 修改用户的运营商状态SQL语句 sql3 = "UPDATE `user_base_info` AS a SET a.`Auth_Phone` = '5' WHERE a.`ID` = '%s'" % (a) try: # 执行sql语句 cursor.execute(sql1) cursor.execute(sql2) cursor.execute(sql3) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "运营商提交成功" print result # 关闭数据库连接 db.close() return result elif q == '2': # 打开数据库连接 db = MySQLdb.connect("172.16.1.81", "root", "Audaque2017.com", "ssj0513", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 针对时间进行特殊处理 usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 global userid a = self.userid b = self.phone.encode('utf-8') c = self.name.encode('utf-8') d = self.month.encode('utf-8') # 插入运营商详情信息SQL语句 sql1 = "INSERT INTO `nq_co_base` (UserId, userName, userPwd, CustName, OcType, OpenDate, OpenDateSrc, \ TotalMonth, TotalMonthSrc, AccountBalance, AccountBalanceSrc, FlowBalance, FlowBalanceSrc, \ CityCode, CityName, ShowOcType) \ VALUES ('%s', '%s', '123456', '%s', '2', '2016-01-01 00:00:00', '20160101', '%s', \ '%s', '1000.00', '1000.00', '2000.00', '2000.00', '2223', '广东-深圳市', '中国移动') " % \ (a, b, c, d, d) # 插入运营商用户信息SQL语句 sql2 = "INSERT INTO `user_co_info` (UserID, ValidatePhone, ServiceCode, CityCode, cityName, CO_Type, \ CO_Type_Name, CO_SubmitTime, CO_AuthState, CO_ReviewUser, CO_ReviewTime, CO_CloseTime) \ VALUES ('%s', '%s', '123456', '2223', '广东-深圳市', '2', '中国移动', \ '%s', '5', '9999', '%s', '2920-08-30 13:20:00')" % (a, b, usertime, usertime) # 修改用户的运营商状态SQL语句 sql3 = "UPDATE `user_base_info` AS a SET a.`Auth_Phone` = '5' WHERE a.`ID` = '%s'" % (a) try: # 执行sql语句 cursor.execute(sql1) cursor.execute(sql2) cursor.execute(sql3) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "运营商提交成功" print result # 关闭数据库连接 db.close() return result else: print "fail" sys.exit() def __init__(self, source, userid, phone, name, month): self.source = source self.userid = userid self.phone = phone self.name = name self.month = month############################### 提交芝麻信用 ###################################class Userzmxy: # 用来芝麻信用认证 def userzmxy_in(self): q = self.source if q == '1': # 打开数据库连接 db = MySQLdb.connect("120.24.67.22", "root", "Audaque2017", "test", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 针对时间进行特殊处理 usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 global userid a = self.userid b = self.score.encode('utf-8') # 插入芝麻信用信息SQL语句 sql1 = "INSERT INTO `user_zmxy_info` (UserID, open_id, zmScore, bizNo, transactionId, ZMXY_SubmitTime, \ ZMXY_AuthState, ZMXY_ReviewUser, ZMXY_ReviewTime, ZMXY_CloseTime) \ VALUES ('%s', '268814283732545550065852222', '%s', 'ZM201708013000000839700494250121', \ 'd9f937ff-d470-4650-ab23-035b823965fd', '%s', '5', '9999', '%s', '2920-08-30 13:20:00') " % \ (a, b, usertime, usertime) # 修改芝麻信用认证状态SQL语句 sql2 = "UPDATE `user_base_info` AS a SET a.`Auth_ZMXY` = '5' WHERE a.`ID` = '%s' " % (a) try: # 执行sql语句 cursor.execute(sql1) cursor.execute(sql2) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "芝麻信用插入成功" print result # 关闭数据库连接 db.close() return result elif q == '2': # 打开数据库连接 db = MySQLdb.connect("172.16.1.81", "root", "Audaque2017.com", "ssj0513", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 针对时间进行特殊处理 usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 global userid a = self.userid b = self.score.encode('utf-8') # 插入芝麻信用信息SQL语句 sql1 = "INSERT INTO `user_zmxy_info` (UserID, open_id, zmScore, bizNo, transactionId, ZMXY_SubmitTime, \ ZMXY_AuthState, ZMXY_ReviewUser, ZMXY_ReviewTime, ZMXY_CloseTime) \ VALUES ('%s', '268814283732545550065852222', '%s', 'ZM201708013000000839700494250121', \ 'd9f937ff-d470-4650-ab23-035b823965fd', '%s', '5', '9999', '%s', '2920-08-30 13:20:00') " % \ (a, b, usertime, usertime) # 修改芝麻信用认证状态SQL语句 sql2 = "UPDATE `user_base_info` AS a SET a.`Auth_ZMXY` = '5' WHERE a.`ID` = '%s' " % (a) try: # 执行sql语句 cursor.execute(sql1) cursor.execute(sql2) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "芝麻信用插入成功" print result # 关闭数据库连接 db.close() return result else: print "fail" sys.exit() def __init__(self, source, userid, score): self.source = source self.userid = userid self.score = score############################### 提交深圳社保 ###################################class Social: # 用来提交社保资料，仅深圳 def social_in(self): q = self.source if q == '1': # 打开数据库连接 db = MySQLdb.connect("120.24.67.22", "root", "Audaque2017", "test", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 针对时间进行特殊处理 usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 global userid a = self.userid b = self.name.encode('utf-8') c = self.identity.encode('utf-8') d = self.salary.encode('utf-8') # 插入深圳社保详情信息SQL语句 sql1 = "INSERT INTO `nq_sb_base_shenzhen` (userName, userPwd, userId, NAME, sex, computerNo, identityNo, \ domicileType, cardStatus, medicalNo, employeeType, companyCode, companyName, salary, yangLaoStatus, \ gongShangStatus, shengYuStatus, yiLiaoStatus, shiYeStatus, payStatus, yangLaoSum, yiLiaoSum, \ isNewest, operateTime) \ VALUES ('ssj', 'MTIzNDU2', '%s', '%s', '男', '624217903', '%s', \ '深户', '正常', '6049002966', '合同工', '638417', '深圳市华傲数据技术有限公司', '%s', \ '参加', '参加', '参加', '基本医疗保险一档', '参加', '正常', '100000.00', '50000.00', '1', '2017-06-07 14:18:11') " % \ (a, b, c, d) # 插入深圳社保用户信息SQL语句 sql2 = "INSERT INTO `user_socia_info` (UserID, Social_City, Social_SubmitTime, Social_AuthState, \ Social_ReviewUser, Social_ReviewTime, Social_CloseTime, Social_NewData) \ VALUES ('%s', '2223', '%s', '5', '9999', '%s', '2920-08-30 13:20:00', '1') " % \ (a, usertime, usertime) # 修改用户的社保状态SQL语句 sql3 = "UPDATE `user_base_info` AS a SET a.`Auth_Social` = '5' WHERE a.`ID` = '%s' " % (a) try: # 执行sql语句 cursor.execute(sql1) cursor.execute(sql2) cursor.execute(sql3) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "深圳社保信息插入成功" print result # 关闭数据库连接 db.close() return result elif q == '2': # 打开数据库连接 db = MySQLdb.connect("172.16.1.81", "root", "Audaque2017.com", "ssj0513", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 针对时间进行特殊处理 usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 对输入的进行转码 global userid a = self.userid b = self.name.encode('utf-8') c = self.identity.encode('utf-8') d = self.salary.encode('utf-8') # 插入深圳社保详情信息SQL语句 sql1 = "INSERT INTO `nq_sb_base_shenzhen` (userName, userPwd, userId, NAME, sex, computerNo, identityNo, \ domicileType, cardStatus, medicalNo, employeeType, companyCode, companyName, salary, yangLaoStatus, \ gongShangStatus, shengYuStatus, yiLiaoStatus, shiYeStatus, payStatus, yangLaoSum, yiLiaoSum, \ isNewest, operateTime) \ VALUES ('ssj', 'MTIzNDU2', '%s', '%s', '男', '624217903', '%s', \ '深户', '正常', '6049002966', '合同工', '638417', '深圳市华傲数据技术有限公司', '%s', \ '参加', '参加', '参加', '基本医疗保险一档', '参加', '正常', '100000.00', '50000.00', '1', '2017-06-07 14:18:11') " % \ (a, b, c, d) # 插入深圳社保用户信息SQL语句 sql2 = "INSERT INTO `user_socia_info` (UserID, Social_City, Social_SubmitTime, Social_AuthState, \ Social_ReviewUser, Social_ReviewTime, Social_CloseTime, Social_NewData) \ VALUES ('%s', '2223', '%s', '5', '9999', '%s', '2920-08-30 13:20:00', '1') " % \ (a, usertime, usertime) # 修改用户的社保状态SQL语句 sql3 = "UPDATE `user_base_info` AS a SET a.`Auth_Social` = '5' WHERE a.`ID` = '%s' " % (a) try: # 执行sql语句 cursor.execute(sql1) cursor.execute(sql2) cursor.execute(sql3) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: result = "深圳社保信息插入成功" print result # 关闭数据库连接 db.close() return result else: print "fail" sys.exit() def __init__(self, source, userid, name, identity, salary): self.source = source self.userid = userid self.name = name self.identity = identity self.salary = salary######################### EasyGUI界面 #######################g.msgbox("Hello，欢迎使用随手借测试小工具！", title="随手借测试小工具", ok_button="确定")sqlsource_msg = "请选择你要操作的数据库？"sqlsource_title = "随手借测试小工具"sqlsource_choices = ["测试环境（test库）", "测试环境（ssj0513库）"]sqlsource = g.choicebox(sqlsource_msg, sqlsource_title, sqlsource_choices)if sqlsource == u"测试环境（test库）": while 1: firstbos_msg = "请问你希望做如下哪些操作？" firstbos_title = "随手借测试小工具" firstbos_choices = ["*提交身份认证", "*提交三项基本资料项", "*具备直接借款的能力", \ "提交运营商资料", "提交芝麻信用资料", "提交深圳社保资料"] reply = g.choicebox(firstbos_msg, firstbos_title, firstbos_choices) if reply == u"*提交身份认证": iden_msg = "请输入如下关键信息：\n 注：若需要使用芝麻信用，请确保提交的姓名和身份证相匹配 \n" iden_title = "随手借测试小工具" iden_fieldNames = ["手机号码", "用户姓名", "身份证号"] fieldValues = [] # we start with blanks for the values fieldValues = g.multenterbox(iden_msg, iden_title, iden_fieldNames) exit_flag = 'false' while 1: if fieldValues == None: exit_flag = 'true' break errmsg = "" for i in range(len(iden_fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" 为必填项！\n\n' % iden_fieldNames[i]) if errmsg == "": break # no problems found fieldValues = g.multenterbox(errmsg, iden_title, iden_fieldNames, fieldValues) if exit_flag == 'true': continue #print "Reply was:", fieldValues source = '1' # 调用数据库函数userid_get phone = fieldValues[0] userid_result = UserID(source, phone) userid = userid_result.userid_get() time.sleep(1) # 调用数据库函数identity_in name = fieldValues[1] identityno = fieldValues[2] identity_result = Identity(source, userid, name, identityno) identity_in_result = identity_result.identity_in() print identity_in_result if identity_in_result == '身份认证成功': msg = "执行成功，是否继续进行操作？" title = "随手借测试小工具" boolbox = g.boolbox(msg, title, choices=('继续', '退出')) if boolbox == 1: continue else: sys.exit() else: g.msgbox("执行失败，请联系测试人员！", title="随手借测试小工具", ok_button="退出") sys.exit() elif reply == u"*提交三项基本资料项": iden_msg = "请输入要注册的关键信息：\n 注：若需要使用芝麻信用，请确保提交的姓名和身份证相匹配 \n" iden_title = "随手借测试小工具" iden_fieldNames = ["手机号码", "用户姓名", "身份证号"] fieldValues = [] # we start with blanks for the values fieldValues = g.multenterbox(iden_msg, iden_title, iden_fieldNames) exit_flag = 'false' while 1: if fieldValues == None: exit_flag = 'true' break errmsg = "" for i in range(len(iden_fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" 为必填项！\n\n' % iden_fieldNames[i]) if errmsg == "": break # no problems found fieldValues = g.multenterbox(errmsg, iden_title, iden_fieldNames, fieldValues) if exit_flag == 'true': continue # print "Reply was:", fieldValues source = '1' # 调用数据库函数userid_get phone = fieldValues[0] userid_result = UserID(source, phone) userid = userid_result.userid_get() name = fieldValues[1] identityno = fieldValues[2] # 调用数据库函数identity_in identity_result = Identity(source, userid, name, identityno) identity_in_result = identity_result.identity_in() # 调用函数contacts_work_in contacts_work_result = ContactsWork(source, userid) CWresult = contacts_work_result.contacts_work_in() # print CWresult if CWresult == '两项资料项提交成功': msg = "执行成功，是否继续进行操作？" title = "随手借测试小工具" boolbox = g.boolbox(msg, title, choices=('继续', '退出')) if boolbox == 1: continue else: sys.exit() else: g.msgbox("执行失败，请联系测试人员！", title="随手借测试小工具", ok_button="退出") sys.exit() elif reply == u"*具备直接借款的能力": iden_msg = "请输入如下关键信息：\n 注：因需要使用芝麻信用，请确保提交的姓名和身份证相匹配 \n" iden_title = "随手借测试小工具" iden_fieldNames = ["手机号码", "用户姓名", "身份证号"] fieldValues = [] # we start with blanks for the values fieldValues = g.multenterbox(iden_msg, iden_title, iden_fieldNames) exit_flag = 'false' while 1: if fieldValues == None: exit_flag = 'true' break errmsg = "" for i in range(len(iden_fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" 为必填项！\n\n' % iden_fieldNames[i]) if errmsg == "": break # no problems found fieldValues = g.multenterbox(errmsg, iden_title, iden_fieldNames, fieldValues) if exit_flag == 'true': continue # print "Reply was:", fieldValues source = '1' # 调用数据库函数userid_get phone = fieldValues[0] userid_result = UserID(source, phone) userid = userid_result.userid_get() name = fieldValues[1] identityno = fieldValues[2] # 调用数据库函数identity_in identity_result = Identity(source, userid, name, identityno) identity_in_result = identity_result.identity_in() # 调用函数contacts_work_in contacts_work_result = ContactsWork(source, userid) CWresult = contacts_work_result.contacts_work_in() # print CWresult # 调用函数zmxy_in zmxy_result = ZMXY(source, userid) ZMresult = zmxy_result.zmxy_in() # print ZMresult if ZMresult == '借款能力已具备': msg = "执行成功，是否继续进行操作？" title = "随手借测试小工具" boolbox = g.boolbox(msg, title, choices=('继续', '退出')) if boolbox == 1: continue else: sys.exit() else: g.msgbox("执行失败，请联系测试人员！", title="随手借测试小工具", ok_button="退出") sys.exit() elif reply == u"提交运营商资料": iden_msg = "请输入如下关键信息：\n" iden_title = "随手借测试小工具" iden_fieldNames = ["手机号码", "在网时长"] fieldValues = [] # we start with blanks for the values fieldValues = g.multenterbox(iden_msg, iden_title, iden_fieldNames) exit_flag = 'false' while 1: if fieldValues == None: exit_flag = 'true' break errmsg = "" for i in range(len(iden_fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" 为必填项！\n' % iden_fieldNames[i]) if errmsg == "": break # no problems found fieldValues = g.multenterbox(errmsg, iden_title, iden_fieldNames, fieldValues) if exit_flag == 'true': continue #print "Reply was:", fieldValues source = '1' # 调用数据库函数userid_get phone = fieldValues[0] userid_result = UserID(source, phone) userid = userid_result.userid_get() time.sleep(1) # 调用数据库函数info_search info_result = Info(source, userid) userinfo = info_result.info_search() username = userinfo[0] # 调用数据库函数identity_in zwmonth = fieldValues[1] co_result = Operator(source, userid, phone, username, zwmonth) user_co_result = co_result.operator_in() # print user_co_result if user_co_result == '运营商提交成功': msg = "执行成功，是否继续进行操作？" title = "随手借测试小工具" boolbox = g.boolbox(msg, title, choices=('继续', '退出')) if boolbox == 1: continue else: sys.exit() else: g.msgbox("执行失败，请联系测试人员！", title="随手借测试小工具", ok_button="退出") sys.exit() elif reply == u"提交芝麻信用资料": iden_msg = "请输入如下关键信息：\n" iden_title = "随手借测试小工具" iden_fieldNames = ["手机号码", "芝麻分数"] fieldValues = [] # we start with blanks for the values fieldValues = g.multenterbox(iden_msg, iden_title, iden_fieldNames) exit_flag = 'false' while 1: if fieldValues == None: exit_flag = 'true' break errmsg = "" for i in range(len(iden_fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" 为必填项！\n' % iden_fieldNames[i]) if errmsg == "": break # no problems found fieldValues = g.multenterbox(errmsg, iden_title, iden_fieldNames, fieldValues) if exit_flag == 'true': continue #print "Reply was:", fieldValues source = '1' # 调用数据库函数userid_get phone = fieldValues[0] userid_result = UserID(source, phone) userid = userid_result.userid_get() time.sleep(1) # 调用数据库函数identity_in zmxyf = fieldValues[1] userzmxy_result = Userzmxy(source, userid, zmxyf) userzmxyin = userzmxy_result.userzmxy_in() print userzmxyin if userzmxyin == '芝麻信用插入成功': msg = "执行成功，是否继续进行操作？" title = "随手借测试小工具" boolbox = g.boolbox(msg, title, choices=('继续', '退出')) if boolbox == 1: continue else: sys.exit() else: g.msgbox("执行失败，请联系测试人员！", title="随手借测试小工具", ok_button="退出") sys.exit() elif reply == u"提交深圳社保资料": iden_msg = "请输入如下关键信息：\n" iden_title = "随手借测试小工具" iden_fieldNames = ["手机号码", "缴纳基数"] fieldValues = [] # we start with blanks for the values fieldValues = g.multenterbox(iden_msg, iden_title, iden_fieldNames) exit_flag = 'false' while 1: if fieldValues == None: exit_flag = 'true' break errmsg = "" for i in range(len(iden_fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" 为必填项！\n' % iden_fieldNames[i]) if errmsg == "": break # no problems found fieldValues = g.multenterbox(errmsg, iden_title, iden_fieldNames, fieldValues) if exit_flag == 'true': continue #print "Reply was:", fieldValues source = '1' # 调用数据库函数userid_get phone = fieldValues[0] userid_result = UserID(source, phone) userid = userid_result.userid_get() time.sleep(1) # 调用数据库函数info_search info_result = Info(source, userid) userinfo = info_result.info_search() username = userinfo[0] useriden = userinfo[1] salary = fieldValues[1] # 调用数据库函数social_in sb_result = Social(source, userid, username, useriden, salary) usersocial = sb_result.social_in() # print usersocial if usersocial == '深圳社保信息插入成功': msg = "执行成功，是否继续进行操作？" title = "随手借测试小工具" boolbox = g.boolbox(msg, title, choices=('继续', '退出')) if boolbox == 1: continue else: sys.exit() else: g.msgbox("执行失败，请联系测试人员！", title="随手借测试小工具", ok_button="退出") sys.exit() else: print "退出" sys.exit()elif sqlsource == u"测试环境（ssj0513库）": while 1: firstbos_msg = "请问你希望做如下哪些操作？" firstbos_title = "随手借测试小工具" firstbos_choices = ["*提交身份认证", "*提交三项基本资料项", "*具备直接借款的能力", \ "提交运营商资料", "提交芝麻信用资料", "提交深圳社保资料"] reply = g.choicebox(firstbos_msg, firstbos_title, firstbos_choices) if reply == u"*提交身份认证": iden_msg = "请输入如下关键信息：\n 注：若需要使用芝麻信用，请确保提交的姓名和身份证相匹配 \n" iden_title = "随手借测试小工具" iden_fieldNames = ["手机号码", "用户姓名", "身份证号"] fieldValues = [] # we start with blanks for the values fieldValues = g.multenterbox(iden_msg, iden_title, iden_fieldNames) exit_flag = 'false' while 1: if fieldValues == None: exit_flag = 'true' break errmsg = "" for i in range(len(iden_fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" 为必填项！\n\n' % iden_fieldNames[i]) if errmsg == "": break # no problems found fieldValues = g.multenterbox(errmsg, iden_title, iden_fieldNames, fieldValues) if exit_flag == 'true': continue #print "Reply was:", fieldValues source = '2' # 调用数据库函数userid_get phone = fieldValues[0] userid_result = UserID(source, phone) userid = userid_result.userid_get() time.sleep(1) # 调用数据库函数identity_in name = fieldValues[1] identityno = fieldValues[2] identity_result = Identity(source, userid, name, identityno) identity_in_result = identity_result.identity_in() print identity_in_result if identity_in_result == '身份认证成功': msg = "执行成功，是否继续进行操作？" title = "随手借测试小工具" boolbox = g.boolbox(msg, title, choices=('继续', '退出')) if boolbox == 1: continue else: sys.exit() else: g.msgbox("执行失败，请联系测试人员！", title="随手借测试小工具", ok_button="退出") sys.exit() elif reply == u"*提交三项基本资料项": iden_msg = "请输入要注册的关键信息：\n 注：若需要使用芝麻信用，请确保提交的姓名和身份证相匹配 \n" iden_title = "随手借测试小工具" iden_fieldNames = ["手机号码", "用户姓名", "身份证号"] fieldValues = [] # we start with blanks for the values fieldValues = g.multenterbox(iden_msg, iden_title, iden_fieldNames) exit_flag = 'false' while 1: if fieldValues == None: exit_flag = 'true' break errmsg = "" for i in range(len(iden_fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" 为必填项！\n\n' % iden_fieldNames[i]) if errmsg == "": break # no problems found fieldValues = g.multenterbox(errmsg, iden_title, iden_fieldNames, fieldValues) if exit_flag == 'true': continue # print "Reply was:", fieldValues source = '2' # 调用数据库函数userid_get phone = fieldValues[0] userid_result = UserID(source, phone) userid = userid_result.userid_get() name = fieldValues[1] identityno = fieldValues[2] # 调用数据库函数identity_in identity_result = Identity(source, userid, name, identityno) identity_in_result = identity_result.identity_in() # 调用函数contacts_work_in contacts_work_result = ContactsWork(source, userid) CWresult = contacts_work_result.contacts_work_in() # print CWresult if CWresult == '两项资料项提交成功': msg = "执行成功，是否继续进行操作？" title = "随手借测试小工具" boolbox = g.boolbox(msg, title, choices=('继续', '退出')) if boolbox == 1: continue else: sys.exit() else: g.msgbox("执行失败，请联系测试人员！", title="随手借测试小工具", ok_button="退出") sys.exit() elif reply == u"*具备直接借款的能力": iden_msg = "请输入如下关键信息：\n 注：因需要使用芝麻信用，请确保提交的姓名和身份证相匹配 \n" iden_title = "随手借测试小工具" iden_fieldNames = ["手机号码", "用户姓名", "身份证号"] fieldValues = [] # we start with blanks for the values fieldValues = g.multenterbox(iden_msg, iden_title, iden_fieldNames) exit_flag = 'false' while 1: if fieldValues == None: exit_flag = 'true' break errmsg = "" for i in range(len(iden_fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" 为必填项！\n\n' % iden_fieldNames[i]) if errmsg == "": break # no problems found fieldValues = g.multenterbox(errmsg, iden_title, iden_fieldNames, fieldValues) if exit_flag == 'true': continue # print "Reply was:", fieldValues source = '2' # 调用数据库函数userid_get phone = fieldValues[0] userid_result = UserID(source, phone) userid = userid_result.userid_get() name = fieldValues[1] identityno = fieldValues[2] # 调用数据库函数identity_in identity_result = Identity(source, userid, name, identityno) identity_in_result = identity_result.identity_in() # 调用函数contacts_work_in contacts_work_result = ContactsWork(source, userid) CWresult = contacts_work_result.contacts_work_in() # print CWresult # 调用函数zmxy_in zmxy_result = ZMXY(source, userid) ZMresult = zmxy_result.zmxy_in() # print ZMresult if ZMresult == '借款能力已具备': msg = "执行成功，是否继续进行操作？" title = "随手借测试小工具" boolbox = g.boolbox(msg, title, choices=('继续', '退出')) if boolbox == 1: continue else: sys.exit() else: g.msgbox("执行失败，请联系测试人员！", title="随手借测试小工具", ok_button="退出") sys.exit() elif reply == u"提交运营商资料": iden_msg = "请输入如下关键信息：\n" iden_title = "随手借测试小工具" iden_fieldNames = ["手机号码", "在网时长"] fieldValues = [] # we start with blanks for the values fieldValues = g.multenterbox(iden_msg, iden_title, iden_fieldNames) exit_flag = 'false' while 1: if fieldValues == None: exit_flag = 'true' break errmsg = "" for i in range(len(iden_fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" 为必填项！\n' % iden_fieldNames[i]) if errmsg == "": break # no problems found fieldValues = g.multenterbox(errmsg, iden_title, iden_fieldNames, fieldValues) if exit_flag == 'true': continue #print "Reply was:", fieldValues source = '2' # 调用数据库函数userid_get phone = fieldValues[0] userid_result = UserID(source, phone) userid = userid_result.userid_get() time.sleep(1) # 调用数据库函数info_search info_result = Info(source, userid) userinfo = info_result.info_search() username = userinfo[0] # 调用数据库函数identity_in zwmonth = fieldValues[1] co_result = Operator(source, userid, phone, username, zwmonth) user_co_result = co_result.operator_in() # print user_co_result if user_co_result == '运营商提交成功': msg = "执行成功，是否继续进行操作？" title = "随手借测试小工具" boolbox = g.boolbox(msg, title, choices=('继续', '退出')) if boolbox == 1: continue else: sys.exit() else: g.msgbox("执行失败，请联系测试人员！", title="随手借测试小工具", ok_button="退出") sys.exit() elif reply == u"提交芝麻信用资料": iden_msg = "请输入如下关键信息：\n" iden_title = "随手借测试小工具" iden_fieldNames = ["手机号码", "芝麻分数"] fieldValues = [] # we start with blanks for the values fieldValues = g.multenterbox(iden_msg, iden_title, iden_fieldNames) exit_flag = 'false' while 1: if fieldValues == None: exit_flag = 'true' break errmsg = "" for i in range(len(iden_fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" 为必填项！\n' % iden_fieldNames[i]) if errmsg == "": break # no problems found fieldValues = g.multenterbox(errmsg, iden_title, iden_fieldNames, fieldValues) if exit_flag == 'true': continue #print "Reply was:", fieldValues source = '2' # 调用数据库函数userid_get phone = fieldValues[0] userid_result = UserID(source, phone) userid = userid_result.userid_get() time.sleep(1) # 调用数据库函数identity_in zmxyf = fieldValues[1] userzmxy_result = Userzmxy(source, userid, zmxyf) userzmxyin = userzmxy_result.userzmxy_in() print userzmxyin if userzmxyin == '芝麻信用插入成功': msg = "执行成功，是否继续进行操作？" title = "随手借测试小工具" boolbox = g.boolbox(msg, title, choices=('继续', '退出')) if boolbox == 1: continue else: sys.exit() else: g.msgbox("执行失败，请联系测试人员！", title="随手借测试小工具", ok_button="退出") sys.exit() elif reply == u"提交深圳社保资料": iden_msg = "请输入如下关键信息：\n" iden_title = "随手借测试小工具" iden_fieldNames = ["手机号码", "缴纳基数"] fieldValues = [] # we start with blanks for the values fieldValues = g.multenterbox(iden_msg, iden_title, iden_fieldNames) exit_flag = 'false' while 1: if fieldValues == None: exit_flag = 'true' break errmsg = "" for i in range(len(iden_fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" 为必填项！\n' % iden_fieldNames[i]) if errmsg == "": break # no problems found fieldValues = g.multenterbox(errmsg, iden_title, iden_fieldNames, fieldValues) if exit_flag == 'true': continue #print "Reply was:", fieldValues source = '2' # 调用数据库函数userid_get phone = fieldValues[0] userid_result = UserID(source, phone) userid = userid_result.userid_get() time.sleep(1) # 调用数据库函数info_search info_result = Info(source, userid) userinfo = info_result.info_search() username = userinfo[0] useriden = userinfo[1] salary = fieldValues[1] # 调用数据库函数social_in sb_result = Social(source, userid, username, useriden, salary) usersocial = sb_result.social_in() # print usersocial if usersocial == '深圳社保信息插入成功': msg = "执行成功，是否继续进行操作？" title = "随手借测试小工具" boolbox = g.boolbox(msg, title, choices=('继续', '退出')) if boolbox == 1: continue else: sys.exit() else: g.msgbox("执行失败，请联系测试人员！", title="随手借测试小工具", ok_button="退出") sys.exit() else: print "退出" sys.exit()else: sys.exit() Mysql连接数据库，实现插入数据和修改身份证状态 具体的实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python# -*- coding: UTF-8 -*-import timeimport MySQLdb# 打开数据库连接db = MySQLdb.connect("120.24.67.22","root","Audaque2017","test",charset="utf8")# 使用cursor()方法获取操作游标cursor = db.cursor()# 针对身份证插入数据定义变量，对四个字段进行特殊处理userid = raw_input("请输入用户UserID：")name = raw_input("请输入用户姓名：")identityno = raw_input("请输入用户身份证号：")usertime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())# 插入身份证信息SQL语句sql1 = "INSERT INTO `user_identity_info` (UserID, Identity_Name, Identity_Sex, Identity_Birthday, \ Identity_No, Identity_Addr, Identity_Validity, Identity_LiveArea, Identity_LiveAddr, Identity_SubmitTime, \ Identity_AuthState, Identity_ReviewUser, Identity_ReviewTime, Identity_CloseTime, WideTableID) \ VALUE ('%s', '%s', '1','1986年07月08日', '%s', '软件大厦', '20170808-20270808', \ '222312', '科技中三路靠近软件大厦', '%s', '5', '9999', '%s', \ '2920-08-30 13:20:00', 'BC07FC0D9A3BE739E9E65DB831E3EED8') " % \ (userid, name, identityno, usertime, usertime)# 修改身份证认证状态SQL语句sql2 = "UPDATE `user_base_info` AS a SET a.`Auth_Identity` = '5' WHERE a.`ID` = '%s' " % (userid)try: # 执行sql语句 cursor.execute(sql1) time.sleep(1) cursor.execute(sql2) # 提交到数据库执行 db.commit()except: # 发生错误时回滚 db.rollback()else: print "执行成功"# 关闭数据库连接db.close() 效果如下： Python结合模块SQL实现了根据手机号查询到UserID 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdbphone = raw_input("请输入手机号码：")class UserID: # 用来查询UserID def userid_get(self): # 打开数据库连接 db = MySQLdb.connect("120.24.67.22", "root", "Audaque2017", "test", charset="utf8") # 使用cursor()方法获取操作游标 cursor = db.cursor() # 查询输入手机号的UserID p = self.phone.encode('utf-8') sql3 = "SELECT a.`ID` FROM `user_base_info` a WHERE a.`Phone` = '%s' " % (self.phone) try: # 执行sql语句 cursor.execute(sql3) result = cursor.fetchall() for row in result: userid = row[0] # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() else: print "执行成功" # 关闭数据库连接 db.close() return userid def __init__(self, phone): self.phone = phone# 调用数据库函数userid_getresult = UserID(phone)re = result.userid_get()print "结果是：", re]]></content>
      <categories>
        <category>实际运用</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将python文件打包为exe文件]]></title>
    <url>%2F2018%2F01%2F09%2F%E5%B0%86python%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%BAexe%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[需求：脚本编写完成后，想要在任一电脑上运行该脚本，直接执行exe文件可运行 实现方法：pyinstaller 安装方法： pip install pyinstaller 打包方法如下： 1.进入python安装目录的库文件夹 \Python27\Lib\site-packages\PyInstaller2.把脚本放置到该目录下3.在当前目录下打开命令运行窗口，执行命令1pyinstaller -D -w --hidden-import=queue setup.py 4.执行命令后在当前PyInstaller目录下会生成“dist”和“build”两个目录文件夹5.生成的exe程序处于dist目录下，运行即可 运行命令说明： -F， –onefile 打包成一个exe文件。 -D， –onedir 创建一个目录，包含exe文件，但会依赖很多文件（默认选项）。 -c， –console， –nowindowed 使用控制台，无界面(默认) -w， –windowed， –noconsole 使用窗口，无控制台 –hidden-import=queue，解决运行程序后报错”failed to execute script main” 设置自定义图标： 下载图片：https://www.easyicon.net图片改为ico：http://www.ico.la/ 1pyinstaller -F -i "图标.ico" "脚本.py" 注：命令格式一定是先图标路径，再程序路径]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python简易GUI界面模块EasyGUI]]></title>
    <url>%2F2018%2F01%2F09%2FPython%E7%AE%80%E6%98%93GUI%E7%95%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97EasyGUI%2F</url>
    <content type="text"><![CDATA[情况：想实现Python脚本的可视化，原来是打算学习Tkinter，但是后来发现Python有一个简易的GUI库，EsayGUI，虽然该库已淘汰，但是对应简单的功能需要已满足，所以暂时学习使用该模块。 EasyGUI是运行在Tkinter上并拥有自身的时间循环，所以本身安装该模块后也可以根据Tkinter的模式对该脚本进行优化，后面也对该easygui脚本进行了优化。 安装EasyGUI： 官网：http://easygui.sourceforge.net/软件包：https://pan.baidu.com/s/1htn1Gw8 密码: rryy 方法：1.进入到下载包的目录下2.执行命令python setup.py install 导入EasyGUI： 最简单的导入语句： import easygui使用这种方式的话导入函数的模式： easygui.msgbox() 导入整个EasyGUI包： from easygui import *使用这种方式的话导入函数的模式： msgbox() 在使用的导入方法： import easygui as g使用这种方式的话导入函数的模式： g.msgbox() EasyGUI所包含的函数 如下列明所包含的函数，案例直接摘自官网http://easygui.sourceforge.net/tutorial.htmlEasyGui函数的默认参数，EasyGui函数的大多数参数都有默认值。几乎所有的框都显示一个消息和一个标题。标题默认为空字符串，并且消息通常具有简单的默认值。后面可以直接编写源文件修改默认值。 msgbox msgbox显示一条消息并提供一个OK按钮。可以发送任何你想要的信息，以及任何你想要的标题。可以覆盖按钮上的“确定”的默认文本。msgbox函数的使用： 12msgbox （msg = “（Your message goes here）” ， title = “” ， ok_button = “OK” ）： .... ccbox ccbox提供了“继续”和“取消”选项，并返回True（继续）或False（取消）。 ynbox ynbox提供了“Yes”和“No”的选择，并返回“True”为“False”。 buttonbox 要在buttonbox中指定您自己的一组按钮，请使用buttonbox（）函数。buttonbox可以用来显示你选择的一组按钮。当用户点击一个按钮时，buttonbox（）返回选择的文本。如果用户取消或关闭了buttonbox，则返回默认选项（第一个选项）。buttonbox显示一条消息，一个标题和一组按钮。返回用户选择的按钮的文本。 indexbox indexbox显示一条消息，一个标题和一组按钮。返回用户选择的索引。例如，如果您调用带有三个选项（A，B，C）的索引框，则如果用户选择A，indexbox将返回0；如果选择B，indexbox将返回1；如果选择C，indexbox将返回2。 boolbox boolbox显示消息，标题和一组按钮。如果选择了第一个按钮，则返回1。否则返回0。这里是一个boolbox（）的简单例子： 123456message = "What does she say?"title = ""if boolbox(message, title, ["She loves me", "She loves me not"]): sendher("Flowers") # This is just a sample function that you might write.else: pass buttonbox添加图片 当您调用buttonbox函数（或显示按钮框的其他函数，如msgbox，indexbox，ynbox等）时，您可以指定关键字参数image = xxx，其中xxx是图像的文件名。该文件可以是.gif。通常，您可以使用其他图像，如.png。 注意 支持的文件类型取决于你如何安装python。如果其他格式不起作用，则可能需要安装PIL库。 如果指定了图像参数，图像文件将在消息之后显示。以下是EasyGui演示程序的一些示例代码： 1234image = "python_and_check_logo.gif"msg = "Do you like this picture?"choices = ["Yes","No","No opinion"]reply = buttonbox(msg, image=image, choices=choices) choicebox Buttonboxes很适合为用户提供一小段选择。但是如果有很多选择，或者选择的文本很长，那么更好的策略就是把它们作为一个列表。choicebox为用户提供了一种从选择列表中进行选择的方法。选择是按顺序（元组或列表）指定的。在呈现之前，这些选择将被区分大小写。键盘可以用来选择列表的一个元素。例如，按键盘上的“g”会将选择跳转到以“g”开头的第一个元素。再次按下“g”，将光标跳到以“g”开头的下一个元素。在以“g”开始的元素的末尾，再次按下“g”将导致选择环绕到列表的开头，并跳转到以“g”开头的第一个元素。如果没有以“g”开始的元素，则选择在发生“g”的位置之前出现的最后一个元素。如果“g”之前没有元素，则选择列表中的第一个元素。 1234msg ="What is your favorite flavor?"title = "Ice Cream Survey"choices = ["Vanilla", "Chocolate", "Strawberry", "Rocky Road"]choice = choicebox(msg, title, choices) multchoicebox multchoicebox()函数为用户提供了一种从选项列表中进行选择的方法。界面看起来就像选择框，但是用户可以选择零个，一个或多个选择。选择是按顺序（元组或列表）指定的。在呈现之前，这些选择将被区分大小写。 enterbox enterbox是从用户获取字符串的简单方法 integerbox integerbox是从用户获取整数的简单方法 multenterbox multenterbox是在单个屏幕上显示多个输入框的简单方法 在multenterbox中： 如果值比名称更少，则值的列表将填充空字符串，直到值的数量与名称的数量相同 如果有比名称更多的值，值的列表将被截断，以便有与名称一样多的值 返回字段值的列表，如果用户取消操作，则返回None 下面是一些示例代码，它显示了从multenterbox返回的值在接受之前可以检查其有效性： 12345678910111213141516msg = "Enter your personal information"title = "Credit Card Application"fieldNames = ["Name","Street Address","City","State","ZipCode"]fieldValues = [] # we start with blanks for the valuesfieldValues = multenterbox(msg,title, fieldNames)# make sure that none of the fields was left blankwhile 1: if fieldValues == None: break errmsg = "" for i in range(len(fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i]) if errmsg == "": break # no problems found fieldValues = multenterbox(errmsg, title, fieldNames, fieldValues)print "Reply was:", fieldValues multpasswordbox multpasswordbox与multenterbox具有相同的界面，但在显示时，最后一个字段被假定为密码，并用星号标记。 以下是一些示例代码，它显示了如何在接受之前检查从multpasswordbox返回的值的有效性： 12345678910111213141516msg = "Enter logon information"title = "Demo of multpasswordbox"fieldNames = ["Server ID", "User ID", "Password"]fieldValues = [] # we start with blanks for the valuesfieldValues = multpasswordbox(msg,title, fieldNames)# make sure that none of the fields was left blankwhile 1: if fieldValues == None: break errmsg = "" for i in range(len(fieldNames)): if fieldValues[i].strip() == "": errmsg = errmsg + ('"%s" is a required field.\n\n' % fieldNames[i]) if errmsg == "": break # no problems found fieldValues = multpasswordbox(errmsg, title, fieldNames, fieldValues)print "Reply was:", fieldValues textbox textbox()函数以比例字体显示文本。文本将自动换行。 codebox codebox()函数以等宽字体显示文本，不包装。 请注意，您可以传递codebox()和textbox()一个字符串或一个字符串列表。在显示之前，字符串列表将被转换为文本。这意味着您可以使用这些函数以这种方式显示文件的内容： 12345filename = os.path.normcase("c:/autoexec.bat")f = open(filename, "r")text = f.readlines()f.close()codebox("Contents of file " + filename, "Show File Contents", text) diropenbox diropenbox返回一个目录的名称 fileopenbox fileopenbox返回文件的名称 filesavebox filesavebox返回文件的名称 EgStore 为了使存储和恢复用户设置的过程，EasyGui提供了一个名为EgStore的类。为了记住一些设置，你的应用程序必须定义一个从EgStore继承的类（我们称之为Settings，尽管你可以调用它）。您的应用程序还必须创建该类的对象（让我们调用对象设置）。 Settings类的构造函数（__init__方法）必须初始化所有你想记住的值。 完成此操作后，只需将值分配给设置对象中的实例变量即可记住设置，并使用settings.store()方法将设置对象保存到磁盘。 以下是创建Settings类的代码示例： 12345678910111213141516171819#-----------------------------------------------------------------------# define a class named Settings as a subclass of EgStore#-----------------------------------------------------------------------class Settings(EgStore): def __init__(self, filename): # filename is required #------------------------------------------------- # Specify default/initial values for variables that # this particular application wants to remember. #------------------------------------------------- self.userId = "" self.targetServer = "" #------------------------------------------------- # For subclasses of EgStore, these must be # the last two statements in __init__ #------------------------------------------------- self.filename = filename # this is required self.restore() # restore values from the storage file if possible 以下是创建设置对象的代码示例： 1234567#-----------------------------------------------------------------------# create "settings", a persistent Settings object# Note that the "filename" argument is required.# The directory for the persistent file must already exist.#-----------------------------------------------------------------------settingsFilename = os.path.join("C:", "myApp", "settings.txt") # Windows examplesettings = Settings(settingsFilename) 使用设置对象的示例代码： 123456789101112131415# we initialize the "user" and "server" variables# In a real application, we'd probably have the user enter them via enterboxuser = "obama_barak"server = "whitehouse1"# we save the variables as attributes of the "settings" objectsettings.userId = usersettings.targetServer = serversettings.store() # persist the settings# run code that gets a new value for userId# then persist the settings with the new valueuser = "biden_joe"settings.userId = usersettings.store() exceptionbox EasyGui提供了一个通过exceptionbox处理异常的方法。Exceptionbox在代码框中显示堆栈跟踪，并可能允许您继续处理。代码示例： 1234try: someFunction() # this may raise an exceptionexcept: exceptionbox() EasyGUI优化 对模块easygui的脚本文件直接进行编辑优化 优化程序的字体显示 文字的大小和字体通过配置如下可实现： 123456PROPORTIONAL_FONT_FAMILY = ("微软雅黑")MONOSPACE_FONT_FAMILY = ("Courier")PROPORTIONAL_FONT_SIZE = 10MONOSPACE_FONT_SIZE = 9 #a little smaller, because it it more legible at a smaller sizeTEXT_ENTRY_FONT_SIZE = 12 # a little larger makes it easier to see 优化程序的默认按钮文案 默认按钮的文案为OK和Cancel，修改为中文文案，记得修改中文需要加对应的utf-8的调用解释 12345678910111213141516171819202122232425# ------------------ ok button -------------------------------buttonsFrame = Frame(master=boxRoot)buttonsFrame.pack(side=BOTTOM, fill=BOTH)okButton = Button(buttonsFrame, takefocus=1, text="确定")bindArrows(okButton)okButton.pack(expand=1, side=LEFT, padx='3m', pady='3m', ipadx='2m', ipady='1m')# for the commandButton, bind activation events to the activation event handlercommandButton = okButtonhandler = __multenterboxGetTextfor selectionEvent in STANDARD_SELECTION_EVENTS: commandButton.bind("&lt;%s&gt;" % selectionEvent, handler)# ------------------ cancel button -------------------------------cancelButton = Button(buttonsFrame, takefocus=1, text="退出")bindArrows(cancelButton)cancelButton.pack(expand=1, side=RIGHT, padx='3m', pady='3m', ipadx='2m', ipady='1m')# for the commandButton, bind activation events to the activation event handlercommandButton = cancelButtonhandler = __multenterboxCancelfor selectionEvent in STANDARD_SELECTION_EVENTS: commandButton.bind("&lt;%s&gt;" % selectionEvent, handler) 优化程序的窗口显示位置 默认程序的显示位置比较杂乱，所以需要对各自的函数进行编辑，如对buttonbox函数的窗口进行定义，主要是根据TKinter的方式，对.geometry这个参数进行修改，实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#-------------------------------------------------------------------# buttonbox#-------------------------------------------------------------------def buttonbox(msg="",title=" " ,choices=("Button1", "Button2", "Button3") , image=None , root=None ): """ Display a msg, a title, and a set of buttons. The buttons are defined by the members of the choices list. Return the text of the button that the user selected. @arg msg: the msg to be displayed. @arg title: the window title @arg choices: a list or tuple of the choices to be displayed """ global boxRoot, __replyButtonText, __widgetTexts, buttonsFrame # Initialize __replyButtonText to the first choice. # This is what will be used if the window is closed by the close button. __replyButtonText = choices[0] if root: root.withdraw() boxRoot = Toplevel(master=root) boxRoot.withdraw() else: boxRoot = Tk() boxRoot.withdraw() # 修改窗口，使其居中显示，获取屏幕 宽、高 w = 400 #定义窗口的宽 h = 100 #定义窗口的高 ws = boxRoot.winfo_screenwidth() hs = boxRoot.winfo_screenheight() # 计算 x, y 位置 x = (ws / 2) - (w / 2) y = (hs / 2) - (h / 2) boxRoot.geometry('%dx%d+%d+%d' % (w, h, x, y) )#center window on desktop boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose ) boxRoot.title(title) boxRoot.iconname('Dialog') boxRoot.minsize(400, 100)]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python&MySQL]]></title>
    <url>%2F2018%2F01%2F08%2FPython%26MySQL%2F</url>
    <content type="text"><![CDATA[什么是MySQLdb MySQLdb是用于Python链接Mysql数据库的接口，它实现了Python数据库API规范V2.0，基于MySQL C API 上建立的 貌似Python2.7连接Mysql数据库只能使用MySQLdb，而Python3可以使用更便捷的pymysql库 windows下安装MySQLdb 下载地址：python2.7，http://www.codegood.com/archives/129win32下载 MySQL-python-1.2.3.win32-py2.7.exe (1,023.1 KiB)win64下载 MySQL-python-1.2.3.win-amd64-py2.7.exe (1.0 MiB) 步骤： 1.安装setuptools 在安装MySQLdb之前必须安装setuptools，要不然会出现编译错误地址：http://pypi.python.org/pypi/setuptools64位系统使用如下方式安装：http://peak.telecommunity.com/dist/ 中下载ez_setup.py 2.确保存在python环境和Mysql数据库 3.安装MySQLdb 4.检查是否可用 1234#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb 如运行后无如下提示错误则表示调用成功 1234Traceback (most recent call last): File "test.py", line 3, in &lt;module&gt; import MySQLdbImportError: No module named MySQLdb 数据库连接 如下以案例和连接项目测试数据库为学习对象，不另外建Mysql本地库 案例 连接数据库前，请先确认以下事项： 已经创建了数据库 TESTDB 在TESTDB数据库中您已经创建了表 EMPLOYEE EMPLOYEE表字段为 FIRST_NAME, LAST_NAME, AGE, SEX 和 INCOME 连接数据库TESTDB使用的用户名为 “testuser” ，密码为 “test123”,Mysql数据库用户授权请使用Grant命令 机子上已经安装了Python MySQLdb模块 实例： 以下实例链接Mysql的TESTDB数据库： 123456789101112131415161718192021#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect("localhost","testuser","test123","TESTDB" )# 使用cursor()方法获取操作游标 cursor = db.cursor()# 使用execute方法执行SQL语句cursor.execute("SELECT VERSION()")# 使用 fetchone() 方法获取一条数据data = cursor.fetchone()print "Database version : %s " % data# 关闭数据库连接db.close() 执行以上脚本输出结果如下： 1Database version : 5.0.45 实操：测试环境连接 123456789101112131415161718192021#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect("120.24.67.22","root","Audaque2017","test" )# 使用cursor()方法获取操作游标cursor = db.cursor()# 使用execute方法执行SQL语句cursor.execute("SELECT VERSION()")# 使用 fetchone() 方法获取一条数据data = cursor.fetchone()print "Database version : %s " % data# 关闭数据库连接db.close() 实际运用后发现报如下的错误： 123456789D:\Python27\python.exe E:/Python/Learn/test/test.pyTraceback (most recent call last): File "E:/Python/Learn/test/test.py", line 7, in &lt;module&gt; db = MySQLdb.connect("120.24.67.22","root","Audaque2017","test" ) File "D:\Python27\lib\site-packages\MySQLdb\__init__.py", line 81, in Connect return Connection(*args, **kwargs) File "D:\Python27\lib\site-packages\MySQLdb\connections.py", line 187, in __init__ super(Connection, self).__init__(*args, **kwargs2)_mysql_exceptions.OperationalError: (1045, "Access denied for user 'root'@'183.14.31.70' (using password: YES)") 尝试解决方法 查找测试环境的Mysql安装路径1ps -ef |grep mysql 找到Mysql的位置，对应进入/var/lib/mysql目录，执行mysql -u root -p连接数据库，但是报异常“ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: YES)” 解决方法如下： 密码正确仍显示报错的原因：Mysql5.6版本以上加强了安全策略，不允许外部带密码方式直接访问 1.跳过MySQL的密码认证过程，方法如下： LINUX #vim /etc/my.cnf (注：windows下修改的是my.ini)在 [mysqld] 文本段下添加语句skip-grant-tables，如下图： Esc+wq保存后退出 2.重启MySQL /etc/init.d/mysql restart(有些用户可能需要使用/etc/init.d/mysqld restart) 如下图： 3.重启之后输入#mysql即可进入mysql 目前到这里，再次执行如上的python脚本，可以正常连接返回版本结果，但是实际上可能再次授权新增一个用户会好一点，具体后续咨询运营同学是否可给予账号 重新执行脚本后效果如下： 创建数据库表 如果数据库连接存在我们可以使用 execute() 方法来为数据库创建表，如下所示创建表EMPLOYEE： 1234567891011121314151617181920212223242526#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect("localhost","testuser","test123","TESTDB" )# 使用cursor()方法获取操作游标 cursor = db.cursor()# 如果数据表已经存在使用 execute() 方法删除表。cursor.execute("DROP TABLE IF EXISTS EMPLOYEE")# 创建数据表SQL语句sql = """CREATE TABLE EMPLOYEE ( FIRST_NAME CHAR(20) NOT NULL, LAST_NAME CHAR(20), AGE INT, SEX CHAR(1), INCOME FLOAT )"""cursor.execute(sql)# 关闭数据库连接db.close() 数据库插入操作 如下以案例和连接项目测试数据库为学习对象，不另外建Mysql本地库 案例 实例使用执行 SQL INSERT 语句向表 EMPLOYEE 插入记录： 1234567891011121314151617181920212223242526#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect("localhost","testuser","test123","TESTDB" )# 使用cursor()方法获取操作游标 cursor = db.cursor()# SQL 插入语句sql = """INSERT INTO EMPLOYEE(FIRST_NAME, LAST_NAME, AGE, SEX, INCOME) VALUES ('Mac', 'Mohan', 20, 'M', 2000)"""try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # Rollback in case there is any error db.rollback()# 关闭数据库连接db.close() 以上例子也可以写成如下形式： 123456789101112131415161718192021222324252627#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect("localhost","testuser","test123","TESTDB" )# 使用cursor()方法获取操作游标 cursor = db.cursor()# SQL 插入语句sql = "INSERT INTO EMPLOYEE(FIRST_NAME, \ LAST_NAME, AGE, SEX, INCOME) \ VALUES ('%s', '%s', '%d', '%c', '%d' )" % \ ('Mac', 'Mohan', 20, 'M', 2000)try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # 发生错误时回滚 db.rollback()# 关闭数据库连接db.close() 转换说明符 %c 字符 %d 有符号十进制整数 %f 浮点数(包括float和doulbe) %i 有符号十进制整数(与%d相同) %u 无符号十进制整数 %s 字符串 实例： 以下代码使用变量向SQL语句中传递参数: 1234567..................................user_id = "test123"password = "password"con.execute('insert into Login values("%s", "%s")' % \ (user_id, password)).................................. 实操：测试环境插入数据 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect("120.24.67.22","root","Audaque2017","test" )# 使用cursor()方法获取操作游标cursor = db.cursor()# SQL插入语句sql = "INSERT INTO `user_identity_info` (UserID, Identity_Name, Identity_Sex, Identity_Birthday, \ Identity_No, Identity_Addr, Identity_Validity, Identity_LiveArea, Identity_LiveAddr, Identity_SubmitTime, \ Identity_AuthState, Identity_ReviewUser, Identity_ReviewTime, Identity_CloseTime, WideTableID) \ VALUE ('234327', u'随手借', '1','1986年07月08日', '440582199401230072', '软件大厦', '20170808-20270808', \ '222312', '科技中三路靠近软件大厦', '2017-12-27 18:20:12', '5', '9999', '2017-12-28 01:00:05', \ '2920-08-30 13:20:00', 'BC07FC0D9A3BE739E9E65DB831E3EED8') "try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # 发生错误时回滚 db.rollback()else: print "执行成功"# 关闭数据库连接db.close() 执行脚本后，数据能够正常插入，但是出现中文乱码的现象，故需要解决中文编码的问题 解决方法 1.查看mysql的编码： 命令：show variables like &#39;character_set_%&#39;; 可以看到如下结果：character_set_client为客户端编码方式；character_set_connection为建立连接使用的编码；character_set_database数据库的编码；character_set_results结果集的编码；character_set_server数据库服务器的编码； 只要保证以上四个采用的编码方式一样，就不会出现乱码问题。 2.在链接数据库的时候直接指定编码： 1sql_con = MySQLdb.connect(host=MYSQL_ADDR , user=MYSQL_USER , passwd=MYSQL_PWD , db=MYSQL_DB , charset="utf8") 3.修改原来的脚本，调整为如下： 12# 打开数据库连接db = MySQLdb.connect("120.24.67.22","root","Audaque2017","test",charset="utf8") 修改后能再次执行脚本能正常插入数据，数据无乱码现象 数据库查询操作 Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall()方法获取多条数据。 fetchone(): 该方法获取下一个查询结果集。结果集是一个对象 fetchall():接收全部的返回结果行 rowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数 案例 查询EMPLOYEE表中salary（工资）字段大于1000的所有数据： 123456789101112131415161718192021222324252627282930313233#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect("localhost","testuser","test123","TESTDB" )# 使用cursor()方法获取操作游标 cursor = db.cursor()# SQL 查询语句sql = "SELECT * FROM EMPLOYEE \ WHERE INCOME &gt; '%d'" % (1000)try: # 执行SQL语句 cursor.execute(sql) # 获取所有记录列表 results = cursor.fetchall() for row in results: fname = row[0] lname = row[1] age = row[2] sex = row[3] income = row[4] # 打印结果 print "fname=%s,lname=%s,age=%d,sex=%s,income=%d" % \ (fname, lname, age, sex, income )except: print "Error: unable to fecth data"# 关闭数据库连接db.close() 以上脚本执行结果如下： 1fname=Mac, lname=Mohan, age=20, sex=M, income=2000 注意如下获取SQL查询结果，如果使用.fetchall()方法的话，则结果以列表的形式显示，故单个值则用列表的获取方法，如下： 12345678conn=pymssql.connect(server,user,password,database) cur = conn.cursor() sql = "select * from Province" cur.execute(sql) rows = cur.fetchall() conn.close() for row in rows: print row[0] 数据库更新操作 更新操作用于更新数据表的的数据，以下实例将 EMPLOYEE 表中的 SEX 字段为 ‘M’ 的 AGE 字段递增 1： 123456789101112131415161718192021222324#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect("localhost","testuser","test123","TESTDB" )# 使用cursor()方法获取操作游标 cursor = db.cursor()# SQL 更新语句sql = "UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = '%c'" % ('M')try: # 执行SQL语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # 发生错误时回滚 db.rollback()# 关闭数据库连接db.close() 删除操作 删除操作用于删除数据表中的数据，以下实例演示了删除数据表 EMPLOYEE 中 AGE 大于 20 的所有数据： 123456789101112131415161718192021222324#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect("localhost","testuser","test123","TESTDB" )# 使用cursor()方法获取操作游标 cursor = db.cursor()# SQL 删除语句sql = "DELETE FROM EMPLOYEE WHERE AGE &gt; '%d'" % (20)try: # 执行SQL语句 cursor.execute(sql) # 提交修改 db.commit()except: # 发生错误时回滚 db.rollback()# 关闭连接db.close() 执行事务 事务机制可以确保数据一致性。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。 原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做 一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的 隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰 持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响 Python DB API 2.0 的事务提供了两个方法 commit 或 rollback。 案例 12345678910# SQL删除记录语句sql = "DELETE FROM EMPLOYEE WHERE AGE &gt; '%d'" % (20)try: # 执行SQL语句 cursor.execute(sql) # 向数据库提交 db.commit()except: # 发生错误时回滚 db.rollback() 对于支持事务的数据库， 在Python数据库编程中，当游标建立之时，就自动开始了一个隐形的数据库事务。commit() 方法游标的所有更新操作，rollback() 方法回滚当前游标的所有操作。每一个方法都开始了一个新的事务。 错误处理 DB API中定义了一些数据库操作的错误及异常，下表列出了这些错误和异常： 异常 描述 Warning 当有严重警告时触发，例如插入数据是被截断等等。必须是 StandardError 的子类 Error 警告以外所有其他错误类。必须是 StandardError 的子类 InterfaceError 当有数据库接口模块本身的错误（而不是数据库的错误）发生时触发。必须是Error的子类 DatabaseError 和数据库有关的错误发生时触发。必须是Error的子类 DataError 当有数据处理时的错误发生时触发，例如：除零错误，数据超范围等等。必须是DatabaseError的子类 OperationalError 指非用户控制的，而是操作数据库时发生的错误。例如：连接意外断开、数据库名未找到、事务处理失败、内存分配错误等等操作数据库是发生的错误。必须是DatabaseError的子类 IntegrityError 完整性相关的错误，例如外键检查失败等。必须是DatabaseError子类 InternalError 数据库的内部错误，例如游标（cursor）失效了、事务同步失败等等。必须是DatabaseError子类 ProgrammingError 程序错误，例如数据表（table）没找到或已存在、SQL语句语法错误、参数数量错误等等。必须是DatabaseError的子类 NotSupportedError 不支持错误，指使用了数据库不支持的函数或API等。例如在连接对象上使用.rollback()函数，然而数据库并不支持事务或者事务已关闭。必须是DatabaseError的子类]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python异常处理]]></title>
    <url>%2F2018%2F01%2F04%2FPython%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[python提供了两个非常重要的功能来处理python程序在运行中出现的异常和错误。你可以使用该功能来调试python程序。 异常处理 断言(Assertions) python标准异常 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告 什么是异常？ 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。异常是Python对象，表示一个错误。当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。 异常处理 捕捉异常可以使用try/except语句。try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。如果你不想在异常发生时结束你的程序，只需在try里捕获它。 语法：以下为简单的try….except…else的语法： 12345678try:&lt;语句&gt; #运行别的代码except &lt;名字&gt;：&lt;语句&gt; #如果在try部份引发了'name'异常except &lt;名字&gt;，&lt;数据&gt;:&lt;语句&gt; #如果引发了'name'异常，获得附加的数据else:&lt;语句&gt; #如果没有异常发生 try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。 如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常） 如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印缺省的出错信息） 如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句 实例 下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，且并未发生异常： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open("testfile", "w") fh.write("这是一个测试文件，用于测试异常!!")except IOError: print "Error: 没有找到文件或读取文件失败"else: print "内容写入文件成功" fh.close() 以上程序输出结果： 1234$ python test.py 内容写入文件成功$ cat testfile # 查看写入的内容这是一个测试文件，用于测试异常!! 实例 下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，但文件没有写入权限，发生了异常： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open("testfile", "w") fh.write("这是一个测试文件，用于测试异常!!")except IOError: print "Error: 没有找到文件或读取文件失败"else: print "内容写入文件成功" fh.close() 在执行代码前为了测试方便，我们可以先去掉 testfile 文件的写权限，命令如下： 1chmod -w testfile 再执行以上代码： 12$ python test.py Error: 没有找到文件或读取文件失败 使用except而不带任何异常类型 你可以不带任何异常类型使用except，如下实例： 12345678try: 正常的操作 ......................except: 发生异常，执行这块代码 ......................else: 如果没有异常执行这块代码 以上方式try-except语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。 使用except而带多种异常类型 你也可以使用相同的except语句来处理多个异常信息，如下所示： 12345678try: 正常的操作 ......................except(Exception1[, Exception2[,...ExceptionN]]]): 发生以上多个异常中的一个，执行这块代码 ......................else: 如果没有异常执行这块代码 try-finally语句 try-finally 语句无论是否发生异常都将执行最后的代码。 12345try:&lt;语句&gt;finally:&lt;语句&gt; #退出try时总会执行raise 实例 12345678#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open("testfile", "w") fh.write("这是一个测试文件，用于测试异常!!")finally: print "Error: 没有找到文件或读取文件失败" 如果打开的文件没有可写权限，输出如下所示： 12$ python test.py Error: 没有找到文件或读取文件失败 同样的例子也可以写成如下方式： 123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open("testfile", "w") try: fh.write("这是一个测试文件，用于测试异常!!") finally: print "关闭文件" fh.close()except IOError: print "Error: 没有找到文件或读取文件失败" 当在try块中抛出一个异常，立即执行finally块代码。finally块中的所有语句执行后，异常被再次触发，并执行except块代码。参数的内容不同于异常。 异常的参数 一个异常可以带上参数，可作为输出的异常信息参数。你可以通过except语句来捕获异常的参数，如下所示： 12345try: 正常的操作 ......................except ExceptionType, Argument: 你可以在这输出 Argument 的值... 变量接收的异常值通常包含在异常的语句中。在元组的表单中变量可以接收一个或者多个值。元组通常包含错误字符串，错误数字，错误位置。 实例 以下为单个异常的实例： 123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*-# 定义函数def temp_convert(var): try: return int(var) except ValueError, Argument: print "参数没有包含数字\n", Argument# 调用函数temp_convert("xyz"); 以上程序执行结果如下： 123$ python test.py 参数没有包含数字invalid literal for int() with base 10: 'xyz' 触发异常 我们可以使用raise语句自己触发异常 raise语法格式如下： 1raise [Exception [, args [, traceback]]] 语句中Exception是异常的类型（例如，NameError）参数是一个异常参数值。该参数是可选的，如果不提供，异常的参数是”None”。最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。 实例 一个异常可以是一个字符串，类或对象。 Python的内核提供的异常，大多数都是实例化的类，这是一个类的实例的参数。 定义一个异常非常简单，如下所示： 1234def functionName( level ): if level &lt; 1: raise Exception("Invalid level!", level) # 触发异常后，后面的代码就不会再执行 注意：为了能够捕获异常，”except”语句必须有用相同的异常来抛出类对象或者字符串。例如我们捕获以上异常，”except”语句如下所示： 123456try: 正常逻辑except "Invalid level!": 触发自定义异常 else: 其余代码 实例 123456789101112131415#!/usr/bin/python# -*- coding: UTF-8 -*-# 定义函数def mye( level ): if level &lt; 1: raise Exception("Invalid level!", level) # 触发异常后，后面的代码就不会再执行try: mye(0) // 触发异常except "Invalid level!": print 1else: print 2 执行以上代码，输出结果为： 1234567$ python test.py Traceback (most recent call last): File "test.py", line 11, in &lt;module&gt; mye(0) File "test.py", line 7, in mye raise Exception("Invalid level!", level)Exception: ('Invalid level!', 0) 用户自定义异常 通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。 123class Networkerror(RuntimeError): def __init__(self, arg): self.args = arg 在你定义以上类后，你可以触发该异常，如下所示： 1234try: raise Networkerror("Bad hostname")except Networkerror,e: print e.args]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件/目录相关的方法]]></title>
    <url>%2F2018%2F01%2F03%2FPython%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[File 对象方法: file对象提供了操作文件的一系列方法OS 对象方法: 提供了处理文件及目录的一系列方法 Python File(文件)方法file.close()关闭文件。关闭后文件不能再进行读写操作。 file.flush()刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 file.fileno()返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 file.isatty()如果文件连接到一个终端设备返回 True，否则返回 False。 file.next()返回文件下一行。 file.read([size])从文件读取指定的字节数，如果未给定或为负则读取所有。 file.readline([size])读取整行，包括 “\n” 字符。 file.readlines([sizehint])读取所有行并返回列表，若给定sizeint&gt;0，则是设置一次读多少字节，这是为了减轻读取压力。 file.seek(offset[, whence])设置文件当前位置 file.tell()返回文件当前位置。 file.truncate([size])截取文件，截取的字节通过size指定，默认为当前文件位置。 file.write(str)将字符串写入文件，没有返回值。 file.writelines(sequence)向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 Python OS文件/目录方法os 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示： os.access(path, mode)检验权限模式 os.chdir(path)改变当前工作目录 os.chflags(path, flags)设置路径的标记为数字标记。 os.chmod(path, mode)更改权限 os.chown(path, uid, gid)更改文件所有者 os.chroot(path)改变当前进程的根目录 os.close(fd)关闭文件描述符 fd os.closerange(fd_low, fd_high)关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略 os.dup(fd)复制文件描述符 fd os.dup2(fd, fd2)将一个文件描述符 fd 复制到另一个 fd2 os.fchdir(fd)通过文件描述符改变当前工作目录 os.fchmod(fd, mode)改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。 os.fchown(fd, uid, gid)修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。 os.fdatasync(fd)强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。 os.fdopen(fd[, mode[, bufsize]])通过文件描述符 fd 创建一个文件对象，并返回这个文件对象 os.fpathconf(fd, name)返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。 os.fstat(fd)返回文件描述符fd的状态，像stat()。 os.fstatvfs(fd)返回包含文件描述符fd的文件的文件系统的信息，像 statvfs() os.fsync(fd)强制将文件描述符为fd的文件写入硬盘。 os.ftruncate(fd, length)裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。 os.getcwd()返回当前工作目录 os.getcwdu()返回一个当前工作目录的Unicode对象 os.isatty(fd)如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。 os.lchflags(path, flags)设置路径的标记为数字标记，类似 chflags()，但是没有软链接 os.lchmod(path, mode)修改连接文件权限 os.lchown(path, uid, gid)更改文件所有者，类似 chown，但是不追踪链接。 os.link(src, dst)创建硬链接，名为参数 dst，指向参数 src os.listdir(path)返回path指定的文件夹包含的文件或文件夹的名字的列表。 os.lseek(fd, pos, how)设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效 os.lstat(path)像stat(),但是没有软链接 os.major(device)从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。 os.makedev(major, minor)以major和minor设备号组成一个原始设备号 os.makedirs(path[, mode])递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。 os.minor(device)从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。 os.mkdir(path[, mode])以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。 os.mkfifo(path[, mode])创建命名管道，mode 为数字，默认为 0666 (八进制) os.mknod(filename[, mode=0600, device])创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。 os.open(file, flags[, mode])打开一个文件，并且设置需要的打开选项，mode参数是可选的 os.openpty()打开一个新的伪终端对。返回 pty 和 tty的文件描述符。 os.pathconf(path, name)返回相关文件的系统配置信息。 os.pipe()创建一个管道. 返回一对文件描述符(r, w) 分别为读和写 os.popen(command[, mode[, bufsize]])从一个 command 打开一个管道 os.read(fd, n)从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。 os.readlink(path)返回软链接所指向的文件 os.remove(path)删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。 os.removedirs(path)递归删除目录。 os.rename(src, dst)重命名文件或目录，从 src 到 dst os.renames(old, new)递归地对目录进行更名，也可以对文件进行更名。 os.rmdir(path)删除path指定的空目录，如果目录非空，则抛出一个OSError异常。 os.stat(path)获取path指定的路径的信息，功能等同于C API中的stat()系统调用。 os.stat_float_times([newvalue])决定stat_result是否以float对象显示时间戳 os.statvfs(path)获取指定路径的文件系统统计信息 os.symlink(src, dst)创建一个软链接 os.tcgetpgrp(fd)返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组 os.tcsetpgrp(fd, pg)设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。 os.tempnam([dir[, prefix]])返回唯一的路径名用于创建临时文件。 os.tmpfile()返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。 os.tmpnam()为创建一个临时文件返回一个唯一的路径 os.ttyname(fd)返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。 os.unlink(path)删除文件路径 os.utime(path, times)返回指定的path文件的访问和修改的时间。 os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])输出在文件夹中的文件名通过在树中游走，向上或者向下。 os.write(fd, str)写入字符串到文件描述符 fd中. 返回实际写入的字符串长度]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python内置函数]]></title>
    <url>%2F2018%2F01%2F03%2FPython%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[跳转引用]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块]]></title>
    <url>%2F2018%2F01%2F03%2FPython%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Python 模块(Module)，是一个Python文件，以.py结尾，包含了Python对象定义和Python语句。模块让你能够有逻辑地组织你的 Python 代码段。把相关的代码分配到一个模块里能让你的代码更好用，更易懂。模块能定义函数，类和变量，模块里也能包含可执行的代码。 例子 support.py 模块： 123def print_func( par ): print "Hello : ", par return import语句 模块的引入 模块定义好后，我们可以使用 import 语句来引入模块，语法如下： 1import module1[, module2[,... moduleN] 比如要引用模块 math，就可以在文件最开始的地方用 import math 来引入。在调用 math 模块中的函数时，必须这样引用： 1模块名.函数名 当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support.py，需要把命令放在脚本的顶端： test.py 文件代码： 12345678#!/usr/bin/python# -*- coding: UTF-8 -*- # 导入模块import support # 现在可以调用模块里包含的函数了support.print_func("Runoob") 以上实例输出结果： 1Hello : Runoob 一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。 From…import语句 Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下： 1from modname import name1[, name2[, ... nameN]] 例如，要导入模块 fib 的 fibonacci 函数，使用如下语句： 1from fib import fibonacci 这个声明不会把整个 fib 模块导入到当前的命名空间中，它只会将 fib 里的 fibonacci 单个引入到执行这个声明的模块的全局符号表。 From…import*语句 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： 1from modname import * 这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。例如我们想一次性引入 math 模块中所有的东西，语句如下： 1from math import * 搜索路径 当你导入一个模块，Python 解析器对模块位置的搜索顺序是： 1、当前目录 2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录 3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/ 模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 PYTHONPATH变量 作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。在 Windows 系统，典型的 PYTHONPATH 如下： 1set PYTHONPATH=c:\python27\lib; 在 UNIX 系统，典型的 PYTHONPATH 如下： 1set PYTHONPATH=/usr/local/lib/python 命名空间和作用域 变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。因此，如果要给函数内的全局变量赋值，必须使用 global 语句。global VarName 的表达式会告诉 Python， VarName 是一个全局变量，这样 Python 就不会在局部命名空间里寻找这个变量了。 例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。取消 global 语句的注释就能解决这个问题。 123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- Money = 2000def AddMoney(): # 想改正代码就取消以下注释: # global Money Money = Money + 1 print MoneyAddMoney()print Money dir()函数 dir() 函数一个排好序的字符串列表，内容是一个模块里定义过的名字。返回的列表容纳了在一个模块里定义的所有模块，变量和函数。如下一个简单的实例： 123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 导入内置math模块import math content = dir(math) print content; 以上实例输出结果： 12345['__doc__', '__file__', '__name__', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'cosh', 'degrees', 'e', 'exp', 'fabs', 'floor', 'fmod', 'frexp', 'hypot', 'ldexp', 'log','log10', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'] 在这里，特殊字符串变量name指向模块的名字，file指向该模块的导入文件名。 globals() 和 locals() 函数 根据调用地方的不同，globals() 和 locals() 函数可被用来返回全局和局部命名空间里的名字。如果在函数内部调用 locals()，返回的是所有能在该函数里访问的命名。如果在函数内部调用 globals()，返回的是所有在该函数里能访问的全局名字。两个函数的返回类型都是字典。所以名字们能用 keys() 函数摘取。 reload()函数 当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。因此，如果你想重新执行模块里顶层部分的代码，可以用 reload() 函数。该函数会重新导入之前导入过的模块。语法如下： 1reload(module_name) 在这里，module_name要直接放模块的名字，而不是一个字符串形式。比如想重载 hello 模块，如下： 1reload(hello) Python中的包 包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。简单来说，包就是文件夹，但该文件夹下必须存在 __init__.py 文件, 该文件的内容可以为空。 __int__.py 用于标识当前文件夹是一个包。考虑一个在 package_runoob 目录下的 runoob1.py、runoob2.py、__init__.py 文件，test.py 为测试调用包的代码，目录结构如下： 12345test.pypackage_runoob|-- __init__.py|-- runoob1.py|-- runoob2.py 源代码如下： package_runoob/runoob1.py 12345#!/usr/bin/python# -*- coding: UTF-8 -*- def runoob1(): print "I'm in runoob1" package_runoob/runoob2.py 12345#!/usr/bin/python# -*- coding: UTF-8 -*- def runoob2(): print "I'm in runoob2" 现在，在 package_runoob 目录下创建 __init__.py： package_runoob/__init__.py 1234567#!/usr/bin/python# -*- coding: UTF-8 -*- if __name__ == '__main__': print '作为主程序运行'else: print 'package_runoob 初始化' 然后我们在 package_runoob 同级目录下创建 test.py 来调用 package_runoob 包 test.py 123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 导入 Phone 包from package_runoob.runoob1 import runoob1from package_runoob.runoob2 import runoob2 runoob1()runoob2() 以上实例输出结果： 123package_runoob 初始化I'm in runoob1I'm in runoob2 如上，为了举例，我们只在每个文件里放置了一个函数，但其实你可以放置许多函数。你也可以在这些文件里定义Python的类，然后为这些类建一个包。 常用模块和函数 系统相关的信息模块: import sys 1234567sys.argv 是一个 list,包含所有的命令行参数. sys.stdout sys.stdin sys.stderr 分别表示标准输入输出,错误输出的文件对象. sys.stdin.readline() 从标准输入读一行 sys.stdout.write("a") 屏幕输出a sys.exit(exit_code) 退出程序 sys.modules 是一个dictionary，表示系统中所有可用的module sys.platform 得到运行的操作系统环境 sys.path 是一个list,指明所有查找module，package的路径. 操作系统相关的调用和操作: import os 1234567891011121314os.environ 一个dictionary 包含环境变量的映射关系 os.environ["HOME"] 可以得到环境变量HOME的值 os.chdir(dir) 改变当前目录 os.chdir('d:\\outlook') 注意windows下用到转义 os.getcwd() 得到当前目录 os.getegid() 得到有效组id os.getgid() 得到组id os.getuid() 得到用户id os.geteuid() 得到有效用户id os.setegid os.setegid() os.seteuid() os.setuid() os.getgruops() 得到用户组名称列表 os.getlogin() 得到用户登录名称 os.getenv 得到环境变量 os.putenv 设置环境变量 os.umask 设置umask os.system(cmd) 利用系统调用，运行cmd命令 内置模块(不用import就可以直接使用)常用 内置函数： 123456789101112131415161718192021222324252627282930313233help(obj) 在线帮助, obj可是任何类型 callable(obj) 查看一个obj是不是可以像函数一样调用 repr(obj) 得到obj的表示字符串，可以利用这个字符串eval重建该对象的一个拷贝 eval_r(str) 表示合法的python表达式，返回这个表达式 dir(obj) 查看obj的name space中可见的name hasattr(obj,name) 查看一个obj的name space中是否有name getattr(obj,name) 得到一个obj的name space中的一个name setattr(obj,name,value) 为一个obj的name space中的一个name指向vale这个object delattr(obj,name) 从obj的name space中删除一个name vars(obj) 返回一个object的name space。用dictionary表示 locals() 返回一个局部name space,用dictionary表示 globals() 返回一个全局name space,用dictionary表示 type(obj) 查看一个obj的类型 isinstance(obj,cls) 查看obj是不是cls的instance issubclass(subcls,supcls) 查看subcls是不是supcls的子类 ################## 类型转换 ##################chr(i) 把一个ASCII数值,变成字符 ord(i) 把一个字符或者unicode字符,变成ASCII数值 oct(x) 把整数x变成八进制表示的字符串 hex(x) 把整数x变成十六进制表示的字符串 str(obj) 得到obj的字符串描述 list(seq) 把一个sequence转换成一个list tuple(seq) 把一个sequence转换成一个tuple dict(),dict(list) 转换成一个dictionary int(x) 转换成一个integer long(x) 转换成一个long interger float(x) 转换成一个浮点数 complex(x) 转换成复数 max(...) 求最大值 min(...) 求最小值]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件I/O]]></title>
    <url>%2F2018%2F01%2F03%2FPython%E6%96%87%E4%BB%B6I-O%2F</url>
    <content type="text"><![CDATA[仅列基本的I/O函数 打印到屏幕最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下： 1234#!/usr/bin/python# -*- coding: UTF-8 -*- print "Python 是一个非常棒的语言，不是吗？"; 你的标准屏幕上会产生以下结果： 1Python 是一个非常棒的语言，不是吗？ 读取键盘输入Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下： raw_input input raw_input函数raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）： 12345#!/usr/bin/python# -*- coding: UTF-8 -*- str = raw_input("请输入：");print "你输入的内容是: ", str 这将提示你输入任意字符串，然后在屏幕上显示相同的字符串。当我输入”Hello Python！”，它的输出如下： 12请输入：Hello Python！你输入的内容是: Hello Python！ input函数input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回。 12345#!/usr/bin/python# -*- coding: UTF-8 -*- str = input("请输入：");print "你输入的内容是: ", str 这会产生如下的对应着输入的结果： 12请输入：[x*5 for x in range(2,10,2)]你输入的内容是: [10, 20, 30, 40] 打开和关闭文件Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。 open函数你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。 语法： 1file object = open(file_name [, access_mode][, buffering]) 各个参数的细节如下： file_name：file_name变量是一个包含了你要访问的文件名称的字符串值 access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r) buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认 不同模式打开文件的完全列表： 下图很好的总结了这几种模式： File对象的属性一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。以下是和file对象相关的所有属性的列表： 属性 描述 file.closed 返回true如果文件已被关闭，否则返回false file.mode 返回被打开文件的访问模式 file.name 返回文件的名称 file.softspace 如果用print输出后，必须跟一个空格符，则返回false。否则返回true 如下实例： 123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open("foo.txt", "wb")print "文件名: ", fo.nameprint "是否已关闭 : ", fo.closedprint "访问模式 : ", fo.modeprint "末尾是否强制加空格 : ", fo.softspace 以上实例输出结果： 1234文件名: foo.txt是否已关闭 : False访问模式 : wb末尾是否强制加空格 : 0 close()方法File 对象的 close() 方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close() 方法关闭文件是一个很好的习惯。 语法： 1fileObject.close(); 例子： 123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open("foo.txt", "wb")print "文件名: ", fo.name # 关闭打开的文件fo.close() 以上实例输出结果： 1文件名: foo.txt 重点 Python文件读写，可用with open语句来代替繁琐每次都要写file.close()太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法： 12with open('/path/to/file', 'r') as f: print(f.read()) 读写文件：file对象提供了一系列方法，能让我们的文件访问更轻松。来看看如何使用read()和write()方法来读取和写入文件。 write()方法write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。write()方法不会在字符串的结尾添加换行符(‘\n’) 语法： 1fileObject.write(string); 在这里，被传递的参数是要写入到已打开文件的内容。例子： 123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open("foo.txt", "wb")fo.write("www.runoob.com!\nVery good site!\n"); # 关闭打开的文件fo.close() 上述方法会创建foo.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容: 123$ cat foo.txt www.runoob.com!Very good site! read()方法read()方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。 语法： 1fileObject.read([count]); 在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。 例子：用到以上创建的 foo.txt 文件 123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open("foo.txt", "r+")str = fo.read(10);print "读取的字符串是 : ", str# 关闭打开的文件fo.close() 以上实例输出结果： 1读取的字符串是 : www.runoob 文件定位tell() 方法告诉你文件内的当前位置；换句话说，下一次的读写会发生在文件开头这么多字节之后。 seek（offset [,from]） 方法改变当前文件的位置。 Offset变量表示要移动的字节数 From变量指定开始移动字节的参考位置设为0，则将文件的开头作为移动字节的参考位置设为1，则使用当前的位置作为参考位置设为2，那么该文件的末尾将作为参考位置 例子：就用我们上面创建的文件foo.txt 12345678910111213141516171819#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open("foo.txt", "r+")str = fo.read(10);print "读取的字符串是 : ", str # 查找当前位置position = fo.tell();print "当前文件位置 : ", position # 把指针再次重新定位到文件开头position = fo.seek(0, 0);str = fo.read(10);print "重新读取字符串 : ", str# 关闭打开的文件fo.close() 以上实例输出结果： 123读取的字符串是 : www.runoob当前文件位置 : 10重新读取字符串 : www.runoob 重命名和删除文件Python的 os模块 提供了帮你执行文件处理操作的方法，比如重命名和删除文件。要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。 rename()方法rename()方法需要两个参数，当前的文件名和新文件名。 语法： 1os.rename(current_file_name, new_file_name) 例子：下例将重命名一个已经存在的文件test1.txt 1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 重命名文件test1.txt到test2.txt。os.rename( "test1.txt", "test2.txt" ) remove()方法可以用 remove() 方法删除文件，需要提供要删除的文件名作为参数。 语法： 1os.remove(file_name) 例子：下例将删除一个已经存在的文件test2.txt 1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 删除一个已经存在的文件test2.txtos.remove("test2.txt") Python里的目录所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。 mkdir()方法可以使用os模块的 mkdir() 方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。 语法： 1os.mkdir("newdir") 例子：下例将在当前目录下创建一个新目录test 1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 创建目录testos.mkdir("test") chdir()方法可以用 chdir() 方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。 语法： 1os.chdir("newdir") 例子：下例将进入”/home/newdir”目录 1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 将当前目录改为"/home/newdir"os.chdir("/home/newdir") getcwd()方法getcwd()方法显示当前的工作目录。 语法： 1os.getcwd() 例子：下例给出当前目录 1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 给出当前的目录print os.getcwd() rmdir()方法rmdir()方法删除目录，目录名称以参数传递。在删除这个目录之前，它的所有内容应该先被清除。 语法： 1os.rmdir('dirname') 例子：以下是删除” /tmp/test”目录的例子。目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。 1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 删除”/tmp/test”目录os.rmdir( "/tmp/test" )]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腊香土豆焖饭]]></title>
    <url>%2F2018%2F01%2F03%2F%E8%85%8A%E9%A6%99%E5%9C%9F%E8%B1%86%E7%84%96%E9%A5%AD%2F</url>
    <content type="text"><![CDATA[使用腊味本身煎出的油，将土豆与香菇丁同炒断生，再入电饭锅，按下煮饭钮即成 食材： 乡熏腊肉、干香菇、土豆、长粒香米配料： 干辣椒、生抽、盐 制作步骤： 1.将腊肉用清水洗净表面，入锅煮熟2.将煮好的腊肉切片，再改切丁3.肥瘦相间的腊肉丁，待会煎一下会更香 4.土豆去皮切丁，干香菇泡发切丁，干辣椒剪段5.热油锅，不用放油，直接倒出切好的腊肉丁，中火翻炒6.使用腊味本身煎出的油，会让味道更为简单纯粹，饭粒沾染上腊香7.直到腊肉丁的肥肉收缩，表皮变焦，腊肉的油煸炒出来8.加入土豆丁、香菇丁、辣椒段，继续翻炒9.食材慢慢变色，这时加入生抽和盐调味，咸度要比炒菜咸一点 10.继续煸炒至断生，转入电饭锅内胆11.淘洗好米，与炒好的食材混合，加入平时正常煮饭的水量，按下煮饭键 12.待饭焖好，开盖搅拌均匀，再关上盖子焖几分钟，舀出即成 小贴士 腊鱼、腊肉、腊肠，手边有什么皆可入锅 肥瘦不一决定是否放油，使用食材本身的油会更香 注意腊味的咸度，如果比较咸，煮肉中途可以换水一次 香菇和土豆，一个增香一个吸味，可使用自己喜欢的食材，比如豌豆、胡萝卜等 干辣椒主要为增香，喜欢原味可去掉，葱花亦然 焖饭不建议加新鲜辣椒，会导致成品粘稠 煮饭水的控制，主要是看食材含水量，正常水量即可 来源：https://www.douban.com/note/651006268/]]></content>
      <categories>
        <category>舌尖上的菜谱</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python函数]]></title>
    <url>%2F2018%2F01%2F02%2FPython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。Python提供了许多内建函数，比如print()。自己创建函数，这被叫做用户自定义函数。 定义一个函数 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 () 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明 函数内容以 冒号 起始，并且 缩进 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的 return 相当于返回 None 语法 1234def functionname( parameters ): "函数_文档字符串" function_suite return [expression] 默认情况下，参数值和参数名称是按函数声明中定义的的顺序匹配起来的。 实例 以下为一个简单的Python函数，它将一个字符串作为传入参数，再打印到标准显示设备上。 1234def printme( str ): "打印传入的字符串到标准显示设备上" print str return 函数调用定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行。 如下实例调用了 printme() 函数： 123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- # 定义函数def printme( str ): "打印任何传入的字符串" print str; return; # 调用函数printme("我要调用用户自定义函数!");printme("再次调用同一函数"); 以上实例输出结果： 12我要调用用户自定义函数!再次调用同一函数 参数传递在 python 中，类型属于对象，变量是没有类型的： 123a=[1,2,3]a="Runoob" 以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。 可更改(mutable)与不可更改(immutable)对象 在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象 python 传不可变对象实例: 123456789#!/usr/bin/python# -*- coding: UTF-8 -*- def ChangeInt( a ): a = 10b = 2ChangeInt(b)print b # 结果是 2 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。 传可变对象实例: 1234567891011121314#!/usr/bin/python# -*- coding: UTF-8 -*- # 可写函数说明def changeme( mylist ): "修改传入的列表" mylist.append([1,2,3,4]); print "函数内取值: ", mylist return # 调用changeme函数mylist = [10,20,30];changeme( mylist );print "函数外取值: ", mylist 实例中传入函数的和在末尾添加新内容的对象用的是同一个引用，故输出结果如下： 12函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4]] 参数以下是调用函数时可使用的正式参数类型： 必备参数 关键字参数 默认参数 不定长参数 必备参数必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。调用printme()函数，你必须传入一个参数，不然会出现语法错误： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*- #可写函数说明def printme( str ): "打印任何传入的字符串" print str; return; #调用printme函数printme(); 以上实例输出结果： 1234Traceback (most recent call last): File "test.py", line 11, in &lt;module&gt; printme();TypeError: printme() takes exactly 1 argument (0 given) 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。以下实例在函数 printme() 调用时使用参数名： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*- #可写函数说明def printme( str ): "打印任何传入的字符串" print str; return; #调用printme函数printme( str = "My string"); 以上实例输出结果： 1My string 下例能将关键字参数顺序不重要展示得更清楚： 123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- #可写函数说明def printinfo( name, age ): "打印任何传入的字符串" print "Name: ", name; print "Age ", age; return; #调用printinfo函数printinfo( age=50, name="miki" ); 以上实例输出结果： 12Name: mikiAge 50 缺省参数调用函数时，缺省参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入： 12345678910111213#!/usr/bin/python# -*- coding: UTF-8 -*- #可写函数说明def printinfo( name, age = 35 ): "打印任何传入的字符串" print "Name: ", name; print "Age ", age; return; #调用printinfo函数printinfo( age=50, name="miki" );printinfo( name="miki" ); 以上实例输出结果： 1234Name: mikiAge 50Name: mikiAge 35 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下： 1234def functionname([formal_args,] *var_args_tuple ): "函数_文档字符串" function_suite return [expression] 加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下： 123456789101112131415#!/usr/bin/python# -*- coding: UTF-8 -*- # 可写函数说明def printinfo( arg1, *vartuple ): "打印任何传入的参数" print "输出: " print arg1 for var in vartuple: print var return; # 调用printinfo 函数printinfo( 10 );printinfo( 70, 60, 50 ); 以上实例输出结果： 123456输出:10输出:706050 匿名函数 python 使用 lambda 来创建匿名函数 lambda只是一个表达式，函数体比def简单很多 lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去 lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率 语法 lambda函数的语法只包含一个语句，如下： 1lambda [arg1 [,arg2,.....argn]]:expression 如下实例： 123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 可写函数说明sum = lambda arg1, arg2: arg1 + arg2; # 调用sum函数print "相加后的值为 : ", sum( 10, 20 )print "相加后的值为 : ", sum( 20, 20 ) 以上实例输出结果： 12相加后的值为 : 30相加后的值为 : 40 return语句return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，下例便告诉你怎么做： 123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- # 可写函数说明def sum( arg1, arg2 ): # 返回2个参数的和." total = arg1 + arg2 print "函数内 : ", total return total; # 调用sum函数total = sum( 10, 20 ); 以上实例输出结果： 1函数内 : 30 变量作用域一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下： 全局变量 局部变量 全局变量和局部变量 定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例： 1234567891011121314#!/usr/bin/python# -*- coding: UTF-8 -*-total = 0; # 这是一个全局变量# 可写函数说明def sum( arg1, arg2 ): #返回2个参数的和." total = arg1 + arg2; # total在这里是局部变量. print "函数内是局部变量 : ", total return total; #调用sum函数sum( 10, 20 );print "函数外是全局变量 : ", total 以上实例输出结果： 12函数内是局部变量 : 30函数外是全局变量 : 0]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字典Dictionary]]></title>
    <url>%2F2017%2F12%2F29%2FPython%E5%AD%97%E5%85%B8Dictionary%2F</url>
    <content type="text"><![CDATA[字典是另一种可变容器模型，且可存储任意类型对象。字典的每个键值(key=&gt;value)对用冒号 (:) 分割，每个对之间用逗号 (,) 分割，整个字典包括在花括号 ({}) 中 ,格式如下所示： 1d = &#123;key1 : value1, key2 : value2 &#125; 键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。一个简单的字典实例： 1dict = &#123;'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'&#125; 也可如此创建字典： 12dict1 = &#123; 'abc': 456 &#125;;dict2 = &#123; 'abc': 123, 98.6: 37 &#125;; 访问字典里的值 把相应的键放入熟悉的方括弧，如下实例: 123456#!/usr/bin/python dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; print "dict['Name']: ", dict['Name'];print "dict['Age']: ", dict['Age']; 以上实例输出结果： 12dict['Name']: Zaradict['Age']: 7 如果用字典里没有的键访问数据，会输出错误如下： 12345#!/usr/bin/python dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; print "dict['Alice']: ", dict['Alice']; 以上实例输出结果： 12345dict['Alice']: Traceback (most recent call last): File "test.py", line 5, in &lt;module&gt; print "dict['Alice']: ", dict['Alice'];KeyError: 'Alice' 修改字典 向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例: 123456789#!/usr/bin/python dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; dict['Age'] = 8; # update existing entrydict['School'] = "DPS School"; # Add new entry print "dict['Age']: ", dict['Age'];print "dict['School']: ", dict['School']; 以上实例输出结果： 12dict['Age']: 8dict['School']: DPS School 修改字典 向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例: 123456789#!/usr/bin/python dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; dict['Age'] = 8; # update existing entrydict['School'] = "DPS School"; # Add new entry print "dict['Age']: ", dict['Age'];print "dict['School']: ", dict['School']; 以上实例输出结果： 12dict['Age']: 8dict['School']: DPS School 删除字典元素 能删单一的元素也能清空字典，清空只需一项操作。显示删除一个字典用 del 命令，如下实例： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*- dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; del dict['Name']; # 删除键是'Name'的条目dict.clear(); # 清空词典所有条目del dict ; # 删除词典 print "dict['Age']: ", dict['Age'];print "dict['School']: ", dict['School']; 但这会引发一个异常，因为用del后字典不再存在： 12345dict['Age']:Traceback (most recent call last): File "test.py", line 8, in &lt;module&gt; print "dict['Age']: ", dict['Age'];TypeError: 'type' object is unsubscriptable 字典键的特性 字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。两个重要的点需要记住： 1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例： 12345#!/usr/bin/python dict = &#123;'Name': 'Zara', 'Age': 7, 'Name': 'Manni'&#125;; print "dict['Name']: ", dict['Name']; 以上实例输出结果： 1dict['Name']: Manni 2）键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行，如下实例： 12345#!/usr/bin/python dict = &#123;['Name']: 'Zara', 'Age': 7&#125;; print "dict['Name']: ", dict['Name']; 以上实例输出结果： 1234Traceback (most recent call last): File "test.py", line 3, in &lt;module&gt; dict = &#123;['Name']: 'Zara', 'Age': 7&#125;;TypeError: list objects are unhashable 字典键的特性 Python字典包含了以下内置函数： 函数 描述 cmp(dict1, dict2) 比较两个字典元素，相同返回0，如果字典dict1大于字典dict2返回1，如果字典dict1小于字典dict2返回-1 len(dict) 计算字典元素个数，即键的总数 str(dict) 输出字典可打印的字符串表示 type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型 Python字典包含了以下内置方法： 函数 描述 dict.clear() 删除字典内所有元素 dict.copy() 返回一个字典的浅复制 dict.fromkeys(seq[, val]) 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值 dict.get(查找的键, default=None) 返回指定键的值，如果值不在字典中返回default值 dict.has_key(查找的键) 如果键在字典dict里返回true，否则返回false dict.items() 以列表返回可遍历的(键, 值) 元组数组 dict.keys() 以列表返回一个字典所有的键 dict.setdefault(查找的键值, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default dict.update(dict2) 把字典dict2的键/值对更新到dict里 dict.values() 以列表返回字典中的所有值 pop(删除的键值[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值 popitem() 随机返回并删除字典中的一对键和值]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python日期和时间]]></title>
    <url>%2F2017%2F12%2F29%2FPython%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间，学习仅以time作介绍时间间隔是以秒为单位的浮点小数 Python 的 time 模块下有很多函数可以转换常见日期格式。如函数time.time()用于获取当前时间戳, 如下实例： 1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import time; # 引入time模块ticks = time.time()print "当前时间戳为:", ticks 以上实例输出结果： 1当前时间戳为: 1459994552.51 获取当前时间从返回浮点数的时间辍方式向时间元组转换，只要将浮点数传递给如localtime之类的函数。 1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import timelocaltime = time.localtime(time.time())print "本地时间为 :", localtime 以上实例输出结果： 1本地时间为 : time.struct_time(tm_year=2016, tm_mon=4, tm_mday=7, tm_hour=10, tm_min=3, tm_sec=27, tm_wday=3, tm_yday=98, tm_isdst=0) 获取格式化的时间最简单的获取可读的时间模式的函数是 asctime() : 1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import timelocaltime = time.asctime( time.localtime(time.time()) )print "本地时间为 :", localtime 以上实例输出结果： 1本地时间为 : Thu Apr 7 10:05:21 2016 格式化日期使用 time 模块的 strftime 方法来格式化日期： 1time.strftime(format[, t]) 举例： 12345678910#!/usr/bin/python# -*- coding: UTF-8 -*-import time# 格式化成2016-03-20 11:45:39形式print time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 格式化成Sat Mar 28 22:24:24 2016形式print time.strftime("%a %b %d %H:%M:%S %Y", time.localtime()) 以上实例输出结果： 122016-04-07 10:25:09Thu Apr 07 10:25:09 2016 python中时间日期格式化符号（列常用）： %y 两位数的年份表示（00-99） %Y 四位数的年份表示（000-9999） %m 月份（01-12） %d 月内中的一天（0-31） %H 24小时制小时数（0-23） Time模块仅列觉得常用容易记住的函数： 函数 描述 time.asctime([tupletime]) 接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2008”（2008年12月11日 周二18时07分14秒）的24个字符的字符串 time.ctime([secs]) 作用相当于asctime(localtime(secs))，未给参数相当于asctime() time.localtime([secs]) 接收时间辍（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时） time.sleep(secs) 推迟调用线程的运行，secs指秒数 time.time() 返回当前时间的时间戳 举例： 123456#!/usr/bin/pythonimport timeprint "time.time(): %f " % time.time()print time.localtime( time.time() )print time.asctime( time.localtime(time.time()) ) 以上实例输出结果为： 123time.time(): 1234892919.655932(2009, 2, 17, 10, 48, 39, 1, 48, 0)Tue Feb 17 10:48:39 2009]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Number/字符串/列表/元组]]></title>
    <url>%2F2017%2F12%2F27%2FNumber%2C%E5%AD%97%E7%AC%A6%E4%B8%B2%2C%E5%88%97%E8%A1%A8%2C%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[仅陈列觉得会经常使用的元素 Python Number(数字) del语句的语法是： 1del var1[,var2[,var3[....,varN]]]] 您可以通过使用del语句删除单个或多个对象，例如： 12del vardel var_a, var_b Python Number 类型转换 函数 描述 int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 str(x ) 将对象 x 转换为字符串 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 Python数学函数 函数 返回值 ( 描述 ) cmp(x, y) 如果xy 返回1 floor(x) 返回数字的下舍整数，如math.floor(4.9) 返回4 max(x1, x2,…) 返回给定参数的最大值，参数可以为序列 min(x1, x2,…) 返回给定参数的最小值，参数可以为序列 Python随机数函数 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数 random() 随机生成下一个实数，它在[0,1)范围内 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内 Python字符串 使用引号( ‘ 或 “ )来创建字符串python用反斜杠( \ )转义字符 Python字符串运算符 变量 a 值为字符串 “Hello”，b 变量值为 “Python”： 操作符 描述 实例 + 字符串连接 &gt;&gt;&gt;a + b -&gt; ‘HelloPython’ * 重复输出字符串 &gt;&gt;&gt;a * 2 -&gt; ‘HelloHello’ [] 通过索引获取字符串中字符 &gt;&gt;&gt;a[1] -&gt; ‘e’ [ : ] 截取字符串中的一部分 &gt;&gt;&gt;a[1:4] -&gt; ‘ell’ in 成员运算符 -如果字符串中包含给定的字符返回 True &gt;&gt;&gt;”H” in a -&gt; True not in 成员运算符 -如果字符串中不包含给定的字符返回 True &gt;&gt;&gt;”M” not in a -&gt; True Python字符串格式化 最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中 如下： 123#!/usr/bin/pythonprint "My name is %s and weight is %d kg!" % ('Zara', 21) 以上实例输出结果： 1My name is Zara and weight is 21 kg! %d 格式化整数 %f 格式化浮点数字，可指定小数点后的精度 Python三引号（triple quotes） python中三引号可以将复杂的字符串进行复制:python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符 Python列表(List) 列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现 Python列表脚本操作符 Python表达式 结果 描述 len([1, 2, 3]) 3 长度 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 [‘Hi!’] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 3 in [1, 2, 3] True 元素是否存在于列表中 for x in [1, 2, 3]: print x, 1 2 3 迭代 Python列表函数&amp;方法 Python包含以下函数： 函数 描述 cmp(list1, list2) 比较两个列表的元素 len(list) 列表元素个数 max(list) 返回列表元素最大值 min(list) 返回列表元素最小值 list(seq) 将元组转换为列表 Python包含以下方法： 函数 描述 list.append(添加的对象) 在列表末尾添加新的对象 list.count(统计的对象) 统计某个元素在列表中出现的次数 list.extend(元素列表) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） list.index(查找的对象) 从列表中找出某个值第一个匹配项的索引位置 list.insert(插入的索引位置, 插入的对象) 将对象插入列表 list.pop(移除对象的倒数位置) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 list.remove(移除的对象) 移除列表中某个值的第一个匹配项 list.reverse() 反向列表中元素 list.sort([func]) 对原列表进行排序 Python元组 Python的元组与列表类似，不同之处在于元组的元素不能修改元组使用小括号，列表使用方括号元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python条件语句]]></title>
    <url>%2F2017%2F12%2F26%2FPython%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。可以通过下图来简单了解条件语句的执行过程： Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。Python 编程中 if 语句用于控制程序的执行，基本形式为： 1234if 判断条件： 执行语句……else： 执行语句…… 其中”判断条件”成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句，具体例子如下： 123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- # 例1：if 基本用法 flag = Falsename = 'luren'if name == 'python': # 判断变量否为'python' flag = True # 条件成立时设置标志为真 print 'welcome boss' # 并输出欢迎信息else: print name # 条件不成立时输出变量名称 输出结果为： 1luren # 输出结果 if 语句的判断条件可以用&gt;（大于）、&lt;(小于)、==（等于）、&gt;=（大于等于）、&lt;=（小于等于）来表示其关系。当判断条件为多个值时，可以使用以下形式： 12345678if 判断条件1: 执行语句1……elif 判断条件2: 执行语句2……elif 判断条件3: 执行语句3……else: 执行语句4…… 实例如下： 123456789101112131415#!/usr/bin/python# -*- coding: UTF-8 -*-# 例2：elif用法 num = 5 if num == 3: # 判断num的值 print 'boss' elif num == 2: print 'user'elif num == 1: print 'worker'elif num &lt; 0: # 值小于零时输出 print 'error'else: print 'roadman' # 条件均不成立时输出 输出结果为： 1roadman # 输出结果 由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。 实例： 123456789101112131415161718192021222324#!/usr/bin/python# -*- coding: UTF-8 -*- # 例3：if语句多个条件 num = 9if num &gt;= 0 and num &lt;= 10: # 判断值是否在0~10之间 print 'hello'# 输出结果: hello num = 10if num &lt; 0 or num &gt; 10: # 判断值是否在小于0或大于10 print 'hello'else: print 'undefine'# 输出结果: undefine num = 8# 判断值是否在0~5或者10~15之间if (num &gt;= 0 and num &lt;= 5) or (num &gt;= 10 and num &lt;= 15): print 'hello'else: print 'undefine'# 输出结果: undefine 当 if 有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，此外 and 和 or 的优先级低于&gt;（大于）、&lt;（小于）等判断符号，即大于和小于在没有括号的情况下会比与或要优先判断。 简单的语句组 你也可以在同一行的位置上使用if条件判断语句，如下实例： 12345678#!/usr/bin/python # -*- coding: UTF-8 -*- var = 100 if ( var == 100 ) : print "变量 var 的值为100" print "Good bye!" 以上代码执行输出结果如下： 12变量 var 的值为100Good bye!]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python循环语句]]></title>
    <url>%2F2017%2F12%2F26%2FPython%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[Python提供了for循环和while循环（在Python中没有do..while循环）： 循环控制语句 循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句： Python While 循环语句 Python 编程中 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为： 12while 判断条件： 执行语句…… 执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。当判断条件假false时，循环结束。执行流程图如下： Gif演示 Python while 语句执行过程: 实例： 12345678#!/usr/bin/python count = 0while (count &lt; 9): print 'The count is:', count count = count + 1 print "Good bye!" 以上代码执行输出结果： 12345678910The count is: 0The count is: 1The count is: 2The count is: 3The count is: 4The count is: 5The count is: 6The count is: 7The count is: 8Good bye! while 语句时还有另外两个重要的命令 continue，break 来跳过循环，continue 用于跳过该次循环，break 则是用于退出循环，此外”判断条件”还可以是个常值，表示循环必定成立，具体用法如下： 123456789101112131415# continue 和 break 用法 i = 1while i &lt; 10: i += 1 if i%2 &gt; 0: # 非双数时跳过输出 continue print i # 输出双数2、4、6、8、10 i = 1while 1: # 循环条件为1必定成立 print i # 输出1~10 i += 1 if i &gt; 10: # 当i大于10时跳出循环 break 无限循环 如果条件判断语句永远为 true，循环将会无限的执行下去，如下实例： 123456789#!/usr/bin/python# -*- coding: UTF-8 -*- var = 1while var == 1 : # 该条件永远为true，循环将无限执行下去 num = raw_input("Enter a number :") print "You entered: ", num print "Good bye!" 以上实例输出结果： 12345678910Enter a number :20You entered: 20Enter a number :29You entered: 29Enter a number :3You entered: 3Enter a number between :Traceback (most recent call last): File &quot;test.py&quot;, line 5, in &lt;module&gt; num = raw_input(&quot;Enter a number :&quot;)KeyboardInterrupt 注意：以上的无限循环你可以使用 CTRL+C 来中断循环 循环使用 else 语句 在 python 中，while … else 在循环条件为 false 时执行 else 语句块： 12345678#!/usr/bin/python count = 0while count &lt; 5: print count, " is less than 5" count = count + 1else: print count, " is not less than 5" 以上实例输出结果为： 1234560 is less than 51 is less than 52 is less than 53 is less than 54 is less than 55 is not less than 5 简单语句组 类似 if 语句的语法，如果你的 while 循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示： 1234567#!/usr/bin/python flag = 1 while (flag): print 'Given flag is really true!' print "Good bye!" 注意：以上的无限循环你可以使用 CTRL+C 来中断循环。 Python for 循环语句 Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。语法：for循环的语法格式如下： 12for iterating_var in sequence: statements(s) 实例： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*- for letter in 'Python': # 第一个实例 print '当前字母 :', letter fruits = ['banana', 'apple', 'mango']for fruit in fruits: # 第二个实例 print '当前水果 :', fruit print "Good bye!" 以上实例输出结果: 12345678910当前字母 : P当前字母 : y当前字母 : t当前字母 : h当前字母 : o当前字母 : n当前水果 : banana当前水果 : apple当前水果 : mangoGood bye! 通过序列索引迭代 另外一种执行循环的遍历方式是通过索引，如下实例： 12345678#!/usr/bin/python# -*- coding: UTF-8 -*- fruits = ['banana', 'apple', 'mango']for index in range(len(fruits)): print '当前水果 :', fruits[index] print "Good bye!" 以上实例输出结果： 1234当前水果 : banana当前水果 : apple当前水果 : mangoGood bye! 以上实例我们使用了内置函数 len() 和 range(),函数 len() 返回列表的长度，即元素的个数。 range返回一个序列的数 循环使用 else 语句 在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。实例： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*- for num in range(10,20): # 迭代 10 到 20 之间的数字 for i in range(2,num): # 根据因子迭代 if num%i == 0: # 确定第一个因子 j=num/i # 计算第二个因子 print '%d 等于 %d * %d' % (num,i,j) break # 跳出当前循环 else: # 循环的 else 部分 print num, '是一个质数' 以上实例输出结果： 1234567891010 等于 2 * 511 是一个质数12 等于 2 * 613 是一个质数14 等于 2 * 715 等于 3 * 516 等于 2 * 817 是一个质数18 等于 2 * 919 是一个质数 Python break 语句 Python break语句，就像在C语言中，打破了最小封闭for或while循环。break语句用来终止循环语句，即循环条件没有False条件或者序列还没被完全递归完，也会停止执行循环语句。break语句用在while和for循环中。如果您使用嵌套循环，break语句将停止执行最深层的循环，并开始执行下一行代码。 Python语言 break 语句语法：1break 流程图： 实例： 12345678910111213141516#!/usr/bin/python# -*- coding: UTF-8 -*- for letter in 'Python': # 第一个实例 if letter == 'h': break print '当前字母 :', letter var = 10 # 第二个实例while var &gt; 0: print '当前变量值 :', var var = var -1 if var == 5: # 当变量 var 等于 5 时退出循环 break print "Good bye!" 以上实例执行结果： 123456789当前字母 : P当前字母 : y当前字母 : t当前变量值 : 10当前变量值 : 9当前变量值 : 8当前变量值 : 7当前变量值 : 6Good bye! Python continue 语句 Python continue 语句跳出本次循环，而break跳出整个循环。continue 语句用来告诉Python跳过当前循环的剩余语句，然后继续进行下一轮循环。continue语句用在while和for循环中。 Python 语言 continue 语句语法格式如下：1continue 流程图： 实例： 123456789101112131415#!/usr/bin/python# -*- coding: UTF-8 -*- for letter in 'Python': # 第一个实例 if letter == 'h': continue print '当前字母 :', letter var = 10 # 第二个实例while var &gt; 0: var = var -1 if var == 5: continue print '当前变量值 :', varprint "Good bye!" 以上实例执行结果： 123456789101112131415当前字母 : P当前字母 : y当前字母 : t当前字母 : o当前字母 : n当前变量值 : 9当前变量值 : 8当前变量值 : 7当前变量值 : 6当前变量值 : 4当前变量值 : 3当前变量值 : 2当前变量值 : 1当前变量值 : 0Good bye! Python pass 语句 Python pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。 Python 语言 pass 语句语法格式如下： 1pass 实例： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*- # 输出 Python 的每个字母for letter in 'Python': if letter == 'h': pass print '这是 pass 块' print '当前字母 :', letterprint "Good bye!" 以上实例执行结果： 12345678当前字母 : P当前字母 : y当前字母 : t这是 pass 块当前字母 : h当前字母 : o当前字母 : nGood bye!]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python简介及特性]]></title>
    <url>%2F2017%2F12%2F25%2FPython%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[简介 Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言 Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构 Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言 Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序 Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术 注：编译器是把源程序的每一条语句都编译成机器语言,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快；而解释器则是只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的 Python特点 易于学习：Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单 易于阅读：Python代码定义的更清晰 易于维护：Python的成功在于它的源代码是相当容易维护的 一个广泛的标准库：Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好 互动模式：互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断 可移植：基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台 可扩展：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用 数据库：Python提供所有主要的商业数据库的接口 GUI编程：Python支持GUI可以创建和移植到许多系统调用 可嵌入: 你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力 优点 Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序 开发效率非常高，Python有非常强大的第三方库，基本上你想通过计算机实现任何功能，Python官方库里都有相应的模块进行支持，直接下载调用后，在基础库的基础上再进行开发，大大降低开发周期，避免重复造轮子 高级语言 -&gt; 当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节 可移植性 -&gt; 由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工 作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就几乎可以在市场上所有的系统平台上运行 可扩展性 -&gt; 如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们 可嵌入性 -&gt; 你可以把Python嵌入你的C/C++程序，从而向你的程序用户提供脚本功能 缺点 速度慢，Python 的运行速度相比C语言确实慢很多，跟JAVA相比也要慢一些，但其实所指的运行速度慢在大多数情况下用户是无法直接感知到的，必须借助测试工具才能体现出来，比如你用C运一个程序花了0.01s，用Python是0.1s，这样C语言直接比Python快了10倍,算是非常夸张了，但是你是无法直接通过肉眼感知的，因为一个正常人所能感知的时间最小单位是0.15-0.4s左右，其实在大多数情况下Python已经完全可以满足你对程序速度的要求，除非你要写对速度要求极高的搜索引擎等，这种情况下，当然还是建议你用C去实现的 代码不能加密，因为PYTHON是解释性语言，它的源码都是以名文形式存放的，不过我不认为这算是一个缺点，如果你的项目要求源代码必须是加密的，那你一开始就不应该用Python来去实现 线程不能利用多CPU问题，这是Python被人诟病最多的一个缺点，GIL即全局解释器锁（Global Interpreter Lock），是计算机程序设计语言解释器用于同步线程的工具，使得任何时刻仅有一个线程在执行，Python的线程是操作系统的原生线程。在Linux上为pthread，在Windows上为Win thread，完全由操作系统调度线程的执行。一个python解释器进程内有一条主线程，以及多条用户程序的执行线程。即使在多核CPU平台上，由于GIL的存在，所以禁止多线程的并行执行。关于这个问题的折衷解决方法，我们在以后线程和进程章节里再进行详细探讨]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基本语法]]></title>
    <url>%2F2017%2F12%2F25%2FPython%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python标识符 在 Python 里，标识符由字母、数字、下划线组成。在 Python 中，所有标识符可以包括英文、数字以及下划线( _ )，但不能以数字开头。Python 中的标识符是区分大小写的。以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入；以双下划线开头的 __foo 代表类的私有成员；以双下划线开头和结尾的 __foo__ 代表 Python 里特殊方法专用的标识，如 __init__() 代表类的构造函数。Python 可以同一行显示多条语句，方法是用分号 ; 分开，如： 123&gt;&gt;&gt; print 'hello';print 'runoob';hellorunoob Python保留字符 行和缩进 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示： 1234if True: print "True"else: print "False" 以下代码将会执行错误： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：test.py if True: print "Answer" print "True"else: print "Answer" # 没有严格缩进，在执行时会报错 print "False" 执行以上代码，会出现如下错误提醒： 12345$ python test.py File "test.py", line 5 if True: ^IndentationError: unexpected indent IndentationError: unexpected indent 错误是 python 编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题”，所有 python 对格式要求非常严格。IndentationError: unindent does not match any outer indentation level 错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。因此，在 Python 的代码块中必须使用相同数目的行首缩进空格数。建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用多行语句 Python语句中一般以新行作为为语句的结束符。但是我们可以使用斜杠（ \）将一行的语句分为多行显示，如下所示： 123total = item_one + \ item_two + \ item_three 12days = &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, \ &apos;Thursday&apos;, &apos;Friday&apos; 语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下实例： 12days = [&apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;] Python 引号 Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束必须的相同类型的。其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。 1234word = 'word'sentence = "这是一个句子。"paragraph = """这是一个段落。包含了多个语句""" Python注释 python中单行注释采用 # 开头。 12345#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：test.py# 第一个注释print "Hello, Python!"; # 第二个注释 输出结果： 1Hello, Python! 注释可以在语句或表达式行末： 1name = "Madisetti" # 这是一个注释 python 中多行注释使用三个单引号(‘’’)或三个双引号(“””) 123456789101112131415#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：test.py'''这是多行注释，使用单引号。这是多行注释，使用单引号。这是多行注释，使用单引号。'''"""这是多行注释，使用双引号。这是多行注释，使用双引号。这是多行注释，使用双引号。""" Python空行 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。记住：空行也是程序代码的一部分。 等待用户输入 下面的程序执行后就会等待用户输入，按回车键后就会退出： 12#!/usr/bin/pythonraw_input("\n\nPress the enter key to exit.") 以上代码中 ，“\n\n”在结果输出前会输出两个新的空行。一旦用户按下 enter(回车) 键退出，其它键显示。 同一行显示多条语句 Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例： 12#!/usr/bin/pythonimport sys; x = 'runoob'; sys.stdout.write(x + '\n') 执行以上代码，输入结果为： 12$ python test.pyrunoob Print 输出 print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号 , 12345678910111213141516#!/usr/bin/python# -*- coding: UTF-8 -*-x="a"y="b"# 换行输出print xprint yprint '---------'# 不换行输出print x,print y,# 不换行输出print x,y 以上实例执行结果为： 1234ab---------a b a b 多个语句构成代码组 缩进相同的一组语句构成一个代码块，我们称之代码组。像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。我们将首行及后面的代码组称为一个子句(clause)。如下实例： 123456if expression : suite elif expression : suite else : suite 命令行参数 很多程序可以执行一些操作来查看一些基本信息，Python 可以使用 -h 参数查看各参数帮助信息： 123456789$ python -h usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ... Options and arguments (and corresponding environment variables): -c cmd : program passed in as string (terminates option list) -d : debug output from parser (also PYTHONDEBUG=x) -E : ignore environment variables (such as PYTHONPATH) -h : print this help message and exit [ etc. ] 我们在使用脚本形式执行 Python 时，可以接收命令行输入的参数，具体使用可以参照 Python 命令行参数。 #!/usr/bin/python：是告诉操作系统执行这个脚本的时候，调用 /usr/bin 下的 python 解释器； #!/usr/bin/env python：（推荐）这种用法是为了防止操作系统用户没有将 python 装在默认的 /usr/bin 路径里。当系统看到这一行的时候，首先会到 env 设置里查找 python 的安装路径，再调用对应路径下的解释器程序完成操作。]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python+PyCharm集成开发环境]]></title>
    <url>%2F2017%2F12%2F25%2FPython%2BPyCharm%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Python环境搭建 安装步骤1.安装Python：http://www.python.org/download/2.添加环境变量3.Python 的环境变量 Python命令行参数 集成开发环境（IDE：Integrated Development Environment）: PyCharm PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统。PyCharm 功能 : 调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制……PyCharm 下载地址 : https://www.jetbrains.com/pycharm/download/ Pycharm破解方法server选项里边输入：http://elporfirio.com:1017/不行再尝试server选项里边输入：http://idea.imsxm.com/ Pycharm 汉化方法打开Pycharm的安装目录，进入lib目录 替换resources_cn.jar 文件重启即可 http://pan.baidu.com/s/1cGMNoU PyCharm基本使用 Pycharm新建程序自动补全编码和环境 在文件的“设置”里面进行设置 选择编辑器 -&gt; Code Style -&gt; 文件和代码模板选择Python Script模板，在右侧编辑器内输入要添加的自动补全内容 新建文件夹和python文件 断点调试 设置断点：在代码前面，行号的后面，鼠标单击，就可以设置断点调试断点：点击右上方绿色的甲虫图标，进行断点调试 点击后，会运行到第一个断点。会显示该断点之前的变量信息点击Step Over 或者按F8，我们继续往下运行，到下一个断点]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自动化部署（RF+Jenkins+Appium+Python）]]></title>
    <url>%2F2017%2F12%2F25%2FAndroid%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%EF%BC%88RF%2BJenkins%2BAppium%2BPython%EF%BC%89%2F</url>
    <content type="text"><![CDATA[部署整体情况 编写安卓自动化的测试方案 部署RobotFramework环境 编写脚本并调试 部署jenkins进行自动构建 配置邮件通知 编写安卓自动化的测试方案 跳转日志（另起） 部署RobotFramework环境 跳转日志（另起） 编写脚本并调试 涉及了如下的功能点： 元素定位 跳转日志（另起） 失败用例重跑 跳转日志（另起） Python实现图片对比 跳转日志（另起） 导入自定义库 跳转日志（另起） 如下列举本次在“社保”模块的脚本及步骤 RIDE整体结构样式（选择“测试套件”Other Information）： 编写“测试用例”内容（简要，主要使用关键字）： 主要使用关键字，保持用例简洁，run keyword if条件后面结果均需要带关键字如上测试用例中使用了“社保资料页面校验”、“社保资料页面再次校验”两种关键字且通过输出结果FAIL来再次调用关键字，达到失败用例重跑的效果 编写“关键字”进行调用（社保资料页面校验）： 如上关键字“社保资料页面校验”中使用了关键字“打开随手借APP”/“登录用户-授权资料调用”和自定义库“Compare”如下作这两部分的使用说明： 关键字“打开随手借APP”： Open Application http://localhost:4723/wd/hub//打开应用 platformName=Android //应用平台名称 platformVersion=6.0.1 //应用平台版本（运行的android设备的版本号） deviceName=samsung-sm_7010-bda0ceea //应用名称（运行的android设备名称） appPackage=audaque.SuiShouJie //包名 appActivity=audaque.SuiShouJie.SplashActivity //查找Android应用界面所对应的activity名称 unicodeKeyboard=True resetKeyboard=True //机中的文本框输入数据时，位置错乱解决方法 注： 利用UI Automator Viewer工具（SDK自带的tools工具）可以查询deviceName和appPackage 查询deviceName需多台设备连接PC，才可以检验出来，appPackage则打开App即可 查询appActivity：打开appium，进入设置页选择app包，之后会对应显示，也可查appPackage 关键字“登录用户-授权资料调用” ： 调用关键字“密码调用”： 调用”Python自定义库“，使用定义关键字“Compare” 1.在D:\Python27\Lib\site-packages\中建立文件夹ssjCompare； 2.在ssjCompare文件夹中建立myclass.py，编写脚本；含图片截图，对比：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#coding=utf-8#author='nolan-wu'from PIL import Imageimport mathimport operatorclass MyClass(): def __init__(self): pass def compare(self,i,pic1,pic2): ''' :param i: 选择判定模块(0:登录，1:社保，2:公积金，3:学历，4京东，5:芝麻信用，6:运营商，7:借款) :param pic1: 图片1路径 :param pic2: 图片2路径 :return: 返回对比的结果 '''#各模块校验点坐标(左a、上b、右c和下d的像素坐标) a = ['420','691','691','60','749','749','709','351'] b = ['225','833','833','982','948','948','940','347'] c = ['658','906','906','661','964','964','924','728'] d = ['461','936','936','1108','1051','1051','1043','826'] i = int(i) a = int(a[i]) b = int(b[i]) c = int(c[i]) d = int(d[i]) box = (a,b,c,d)# 加载原始图片 img1 = Image.open(pic1)# 剪切 标识图片 img2 = img1.crop(box) img2.save(pic1)# 图片对比 image1 = Image.open(pic1) image2 = Image.open(pic2) histogram1 = image1.histogram() histogram2 = image2.histogram() differ = math.sqrt(reduce(operator.add, list(map(lambda a,b: (a-b)**2,histogram1, histogram2)))/len(histogram1))# print differ flag = False result = differ if result != 0: flag = True print u'正常' else: print u'不正常' print unicode('不正常') #故意出错，达到用例执行有误的效果 #compare(r'E:\RobotFramework\CheckPic\login.png',r'E:\RobotFramework\ComparePic\login-demo.png') #location((80, 220, 310, 450)) 3.在文件夹内建立init.py文件 12345# coding=utf-8from myclass import MyClassversion = '1.0'class ssjCompare(MyClass): ROBOT_LIBRARY_SCOPE = 'GLOBAL' 4.在Robotframework测试套件中调用这个自定义库，导入后按F5查询可以查询到该关键字 5.在用例中使用该关键字“Compare” 编写“关键字”进行调用（社保资料页面再次校验）： 调用关键字“密码调用”： 至此，用例调试成功 部署jenkins进行自动构建 涉及了如下的功能点： Jenkins环境构建 跳转日志（另起） Jenkins权限配置 跳转日志（另起） 如下列举本次在Jenkins上的配置 配置定时触发任务“授权页面自动化检测” 配置两层下级目录，用于构建后自动触发 配置丢弃旧的构建 配置构建触发器，定时进行构建 配置Appium自动启动结束的机制 配置上级目录，用于被触发 配置丢弃旧的构建 配置构建触发脚本，调用脚本运行并设定持续时长 配置RobotFramework脚本自动运行的机制 配置上级目录，用于被触发 配置丢弃旧的构建 配置构建触发脚本，调用脚本运行 配置RobotFramework结果的输出 配置邮件通知 Jenkins设置管理中配置 Extended E-mail Notification默认设置 JOB配置中增加一个构建后操作步骤Editable Email Notification Content Type选择Both HTML and PlainText Default Subject指的是邮件的标题（$BUILD_STATUS指的是执行结果状态） Default Content则填写邮件的输出内容 邮件模板配置 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;h2&gt;&lt;font color=&quot;red&quot;&gt;$&#123;ENV, var=&quot;JOB_NAME&quot;&#125;-执行情况：$BUILD_STATUS！&lt;/font&gt;&lt;/h2&gt;&lt;/head&gt;&lt;br&gt;&lt;/html&gt;$&#123;SCRIPT,template=&quot;email_result.groovy&quot;&#125; 引用了template=”email_result.groovy”自定义模板引用编辑位置：C:\Users\admin.jenkins\email-templates（jenkins目录，没有该目录自行新建） 配置自定义的模板文件 跳转日志（另起） 文件内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;% import java.text.DateFormat import java.text.SimpleDateFormat %&gt; &lt;!-- Robot Framework Results --&gt; &lt;% def robotResults = false def actions = build.actions // List&lt;hudson.model.Action&gt; actions.each() &#123; action -&gt; if( action.class.simpleName.equals("RobotBuildAction") ) &#123; // hudson.plugins.robot.RobotBuildAction robotResults = true %&gt; &lt;div style="width:100%;float:left"&gt; &lt;table cellspacing="0" cellpadding="4" border="1" align="left"&gt; &lt;thead&gt; &lt;tr bgcolor="#F3F3F3"&gt; &lt;td style="text-align:center" colspan="4"&gt;&lt;b&gt;Android自动化测试报告&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="width:90px"&gt;&lt;center&gt;&lt;b&gt;报告详情&lt;/b&gt;&lt;/center&gt;&lt;/td&gt; &lt;td colspan="4"&gt;&lt;a href="http://10.0.5.14:8080/job/%E9%9A%8F%E6%89%8B%E5%80%9F_Android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A3%80%E6%B5%8B/"&gt;点击查看报告详情&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;center&gt;&lt;b&gt;Jenkins账号&lt;/b&gt;&lt;/center&gt;&lt;/td&gt; &lt;td colspan="3"&gt;&lt;a href="http://10.0.5.14:8080/"&gt;点击跳转Jenkins&lt;/a&gt;，账号：ssj/000000&lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor="#F3F3F3"&gt; &lt;td style="width:90px"&gt;&lt;center&gt;&lt;b&gt;用例总数&lt;/b&gt;&lt;/center&gt;&lt;/td&gt; &lt;td style="width:90px"&gt;&lt;center&gt;&lt;b&gt;通 过&lt;/b&gt;&lt;/center&gt;&lt;/td&gt; &lt;td style="width:90px"&gt;&lt;center&gt;&lt;b&gt;不通过&lt;/b&gt;&lt;/center&gt;&lt;/td&gt; &lt;td style="width:90px"&gt;&lt;center&gt;&lt;b&gt;通过率&lt;/b&gt;&lt;/center&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;center&gt;&lt;%= action.result.overallTotal %&gt;&lt;/center&gt;&lt;/td&gt; &lt;td&gt;&lt;center&gt;&lt;b&gt;&lt;span style="color:#66CC00"&gt;&lt;%= action.result.overallPassed %&gt;&lt;/span&gt;&lt;/b&gt;&lt;/center&gt;&lt;/td&gt; &lt;td&gt;&lt;center&gt;&lt;b&gt;&lt;span style="color:#FF3333"&gt;&lt;%= action.result.overallFailed %&gt;&lt;/span&gt;&lt;/b&gt;&lt;/center&gt;&lt;/td&gt; &lt;td&gt;&lt;center&gt;&lt;%= action.overallPassPercentage %&gt;%&lt;/center&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor="#F3F3F3"&gt; &lt;td style="text-align:center" colspan="4"&gt;&lt;b&gt;执行情况概要&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor="#F3F3F3"&gt; &lt;td colspan="2"&gt;&lt;center&gt;&lt;b&gt;校验模块&lt;/b&gt;&lt;/center&gt;&lt;/td&gt; &lt;td&gt;&lt;center&gt;&lt;b&gt;执行结果&lt;/b&gt;&lt;/center&gt;&lt;/td&gt; &lt;td&gt;&lt;center&gt;&lt;b&gt;执行耗时&lt;/b&gt;&lt;/center&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;% def suites = action.result.allSuites suites.each() &#123; suite -&gt; def currSuite = suite def suiteName = currSuite.displayName // ignore top 2 elements in the structure as they are placeholders while (currSuite.parent != null &amp;&amp; currSuite.parent.parent != null) &#123; currSuite = currSuite.parent suiteName = currSuite.displayName + "." + suiteName &#125; %&gt; &lt;% DateFormat format = new SimpleDateFormat("yyyyMMdd HH:mm:ss") def execDateTcPairs = [] suite.caseResults.each() &#123; tc -&gt; Date execDate = format.parse(tc.starttime) execDateTcPairs &lt;&lt; [execDate, tc] &#125; // primary sort execDate, secondary displayName execDateTcPairs = execDateTcPairs.sort&#123; a,b -&gt; a[1].displayName &lt;=&gt; b[1].displayName &#125; execDateTcPairs = execDateTcPairs.sort&#123; a,b -&gt; a[0] &lt;=&gt; b[0] &#125; execDateTcPairs.each() &#123; def execDate = it[0] def tc = it[1] %&gt; &lt;tr&gt; &lt;td colspan="2"&gt;&lt;center&gt;&lt;%= tc.displayName %&gt;&lt;/center&gt;&lt;/td&gt; &lt;td&gt;&lt;center&gt;&lt;b&gt;&lt;span style="color:&lt;%= tc.isPassed() ? "#66CC00" : "#FF3333" %&gt;"&gt;&lt;%= tc.isPassed() ? "PASS" : "FAIL" %&gt;&lt;/span&gt;&lt;/b&gt;&lt;/center&gt;&lt;/td&gt; &lt;td&gt;&lt;center&gt;&lt;%= tc.getDuration().intdiv(60000)+"分"+(tc.getDuration()-tc.getDuration().intdiv(60000)*60000).intdiv(1000)+"秒" %&gt;&lt;/center&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% if(tc.errorMsg != null) &#123;%&gt; &lt;% &#125;%&gt;&lt;% &#125; // tests &#125; // suites %&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;p style="color:#AE0000;clear:both"&gt;*这个是通过Jenkins自动构建得出的报告，仅供参考&lt;br&gt; 如有疑问，请与我联系（吴泽鹏）&lt;/p&gt; &lt;/div&gt; &lt;% &#125; // robot results &#125; if (!robotResults) &#123; %&gt; &lt;p&gt;No Robot Framework test results found.&lt;/p&gt; &lt;% &#125; %&gt; 邮件配置后对应效果如下： 至此，全部部署完成根据设定的自定义构建时间，对应时刻就自动执行自动化需保持手机正常连接，网络无异常]]></content>
      <categories>
        <category>实际运用</category>
      </categories>
      <tags>
        <tag>RobotFramework</tag>
        <tag>Jenkins</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行Python脚本报错(IndentationError:unindent does not match any outer indentation level)]]></title>
    <url>%2F2017%2F12%2F25%2F%E8%BF%90%E8%A1%8CPython%E8%84%9A%E6%9C%AC%E6%8A%A5%E9%94%99%EF%BC%88unindent%20does%20not%20match%20any%20outer%20indentation%20level%20%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Python脚本运行出现语法错误：IndentationError: unindent does not match any outer indentation level 【解决过程】 1.在：视图 -&gt; 显示符号 -&gt; 显示空格与制表符 而新的Python语法，是不支持的代码对齐中，混用TAB和空格的。所以出现上述错误提示了。去把对应的TAB，都改为空格，统一一下对齐的风格，即可。 在Notepad++中，去： 设置-&gt;首选项：语言-&gt;以空格取代（TAB键）： 即可实现，对于以后每次的TAB输入，都自动转换为4个空格。]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins配置基于角色的项目权限管理]]></title>
    <url>%2F2017%2F12%2F22%2FJenkins%E9%85%8D%E7%BD%AE%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[由于jenkins默认的权限管理体系不支持用户组或角色的配置，因此需要安装第三发插件来支持角色的配置插件：Role Strategy Plugin下载地址：https://wiki.jenkins-ci.org/display/JENKINS/Role+Strategy+Plugin 一、配置插件 安装插件后，进入系统管理，配置“Configure Global Security”如下： 二、配置权限 在系统管理的“Manage and Assign Roles”进入角色管理页面： 1、管理角色（Manage Roles） 选择该项可以创建全局角色、项目角色，并可以为角色分配权限。 如上图，分别创建了admin、user两个全局角色，无项目角色。 项目角色与全局角色的区别就是，项目角色只能管理项目，没有管理jenkins的权限配置。 添加项目角色时，需要制定匹配项目的模式，如上图中的Pattern，官方文档介绍该选项支持正则表达式，如“Roger-.”表示所有以Roger-开头的项目，“(?i)roger-.”表示以roger-开头的项目并且不区分大小写，如以ABC开头的项目可以配置为“ABC|ABC.”，也可以使用“abc|bcd|efg”直接匹配多个项目。 2、创建用户 在分配角色之前需要先创建用户。在系统管理页面，点击管理用户： 3、分配角色（Assign Roles） 选择“Assign Roles”可以为用户分配所属角色，可以分配全局角色和项目角色 配置完后，这样用户就可以具有角色所拥有的权限 三、用户不能登录的情况 方法1 删除用户相关的目录 修改$Jenkins_home/config.xml文件：false 删除authorizationStrategy、securityRealm节点 重新启动Jenkins 使用该方法将删除Jenkins的权限管理，恢复成为初始状态 方法2 修改$Jenkins_home/config.xml文件，修改授权方式为系统自带的安全矩阵方式 1authorizationStrategy节点class属性修改为hudson.security.GlobalMatrixAuthorizationStrategy 配置示例如下，该示例是分配给admin用户所有权限 12345678910111213141516171819202122232425262728293031&lt;useSecurity&gt;true&lt;/useSecurity&gt; &lt;authorizationStrategy class=&quot;hudson.security.GlobalMatrixAuthorizationStrategy&quot;&gt; &lt;permission&gt;hudson.model.Computer.Configure:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Computer.Connect:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Computer.Create:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Computer.Delete:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Computer.Disconnect:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Hudson.Administer:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Hudson.Read:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Hudson.Read:anonymous&lt;/permission&gt; &lt;permission&gt;hudson.model.Hudson.RunScripts:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Item.Build:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Item.Cancel:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Item.Configure:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Item.Create:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Item.Delete:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Item.Discover:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Item.Read:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Item.Workspace:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Run.Delete:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.Run.Update:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.View.Configure:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.View.Create:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.View.Delete:admin&lt;/permission&gt; &lt;permission&gt;hudson.model.View.Read:admin&lt;/permission&gt; &lt;permission&gt;hudson.scm.SCM.Tag:admin&lt;/permission&gt; &lt;/authorizationStrategy&gt; &lt;securityRealm class=&quot;hudson.security.HudsonPrivateSecurityRealm&quot;&gt; &lt;disableSignup&gt;false&lt;/disableSignup&gt; &lt;enableCaptcha&gt;false&lt;/enableCaptcha&gt; &lt;/securityRealm&gt; 重新启动Jenkins]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python+Pillow实现图片处理（对比/裁剪/...）]]></title>
    <url>%2F2017%2F12%2F22%2FPython%2BPillow%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%EF%BC%88%E5%AF%B9%E6%AF%94%2C%E8%A3%81%E5%89%AA...%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第三方库Pillow：可以处理图片http://pillow-cn.readthedocs.io/zh_CN/latest/index.html 简单介绍 Pillow中最重要的类就是Image，可以通过以下几种方式实例化：从文件中读取图片，处理其他图片得到新图片，直接创建一个图片 警告 Pillow 不能和PIL 同时存在于一个环境中，在安装Pillow之前需要先卸载PILPillow 1.0 版本后已经不支持import Image,请使用from PIL import Image来代替Pillow 2.1.0版本以后已经不支持import _imaging,请使用from PIL.Image import core as _imaging来代替 提示 Pillow 2.0.0 版本之前只支持Python 2.4、2.5、2.6、2.7Pillow 2.0.0 版本之前只支持Python 2.6、2.7、3.2、3.3、3.4、3.5 基本安装 提示：使用PyPI安装可以工作在Windows、OS X和Linux中，使用源码包需要组建依赖环境 Windows安装使用pip安装Pillow： $ pip install Pillow使用easy_install： $ easy_install Pillow OS X 安装官方提供了OS X 系统中所有所支持的Python版本的wheel格式的二进制程序，并且已经支持所有可选的库 $ pip install Pillow Linux 安装官方在Linux中不提供任何二进制包，不过这里还是可以使用pip或者easy_install来安装毕竟我们有Python，当然我们也可以通过源码包来安装 Pillow实现图片对比 使用Image模块中的open函数打开一张图片：image1= Image.open(pic1)对比图片的时候用到了一个像素，img1.histogram() ，这个函数会返回一个列表，里面是每个坐标像素点的RGB值，对比图片不同的思路，就是对比两张图片RGB值 具体代码如下： 123456789101112131415161718192021222324#coding=utf-8from PIL import Imageimport mathimport operatordef compare(pic1,pic2): ''' :param pic1: 图片1路径 :param pic2: 图片2路径 :return: 返回对比的结果 ''' image1 = Image.open(pic1) image2 = Image.open(pic2) histogram1 = image1.histogram() histogram2 = image2.histogram() differ = math.sqrt(reduce(operator.add, list(map(lambda a,b: (a-b)**2,histogram1, histogram2)))/len(histogram1)) print differ return differcompare(r'D:\Ptest\Testcase\11.jpg',r'D:\Ptest\Testcase\22.jpg') 这个differ我这边就根据我的理解，简单解释一下计算过程吧首先histogram得到的结果是一个列表[ ]1list(map(lambda a,b: (a-b)**2,histogram1, histogram2)) 这个表达式获得结果是 一个 histogram1[i] - histogram2[i] 相减的结果平方的新的列表即：h3=[(h1[1]-h2[1])2,……….(h1[n]-h2[n])2]1reduce(operator.add, list(map(lambda a,b: (a-b)**2,histogram1, histogram2)))/len(histogram1) 这个函数返回的就是 a=(h3[1]+h3[2]+……+h3[n])/nmath.sqrt(a)这个就很容易理解啦，就是把a开2次方 最后得到differ：如果两张图 一模一样 -&gt; differ=0，即differ越小，图片越相似（甚至相同），differ越大，图片差异越大 使用PIL裁切图片 需要引用Image，使用Image的open(file)方法可以返回打开的图片，使用crop((x0,y0,x1,y1))方法可以对图片做裁切 12345678910import Imageimg = Image.open(r'E:\photo\20120402\abc.jpg')region = (100,200,400,500)#裁切图片cropImg = img.crop(region)#保存裁切后的图片cropImg.save(r'E:\photo\crop.jpg') 教程 在Python的图像库中使用最多的是Image类，从文件中加载图像可使用Image模块中的open()函数： 使用图像类 1234567891011121314151617181920212223# 导入模块&gt;&gt;&gt;&gt; from PIL import Image# 以只读模式查看图片&gt;&gt;&gt; im = Image.open('C:/users/yxn/desktop/1.jpg','r')# 获取图片属性&gt;&gt;&gt; print(im)&lt;PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=3396x2000 at 0x23E89E71978&gt;# 查看图片大小&gt;&gt;&gt; print("图片宽&#123;0&#125;px,高&#123;1&#125;px".format(im.size[0],im.size[1]))图片宽3396px,高2000px# 获取图片源格式&gt;&gt;&gt; print(im.format)JPEG# 获取图片模式,常见有：L（灰度图像），RGB和CMYK（真彩图像）&gt;&gt;&gt; print(im.mode)# 只显示加载的图像,show()这个函数会将图片保存到一个临时文件并调用XV程序来显示图像&gt;&gt;&gt; print(im.show()) 读取并保存图像 12345678910111213141516#!/usr/bin/env python3'''转换文件格式，将jpg转换为png'''import osfrom PIL import ImageImageFile = 'C:/User/xxx/Desktop/1.jpg'# 分割文件路径和后缀名FilePath,Fileext = os.path.splitext(ImageFile)# 设置保存后的文件格式outImageFile = "&#123;0&#125;.png".format(FilePath)# 打开并保存Image.open(ImageFile).save(outImageFile) 创建图片的缩略图 1234567891011121314151617181920212223#!/usr/bin/env python3'''裁剪图片'''import osfrom PIL import Imagesize = 128, 128ImageFile = 'C:/Users/yxn/Desktop/1.jpg'# 分割文件路径和后缀名FilePath,Fileext = os.path.splitext(ImageFile)# 设置保存后的文件格式outImageFile = "&#123;0&#125;.ico".format(FilePath)# 打开图片im = Image.open(ImageFile)# 设置图片裁剪大小im.thumbnail(size)# 保存图片模式为JPEGim.save(outImageFile,'JPEG') 剪切、粘贴 从图片获取一个矩形该区域由一个元祖组成，这个元祖中包含4个值分别是（左、上、右、下的坐标）那么复制的内容实际 宽度=右坐标-左坐标，高度的计算方式：下坐标-上坐标=高度 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python3'''裁剪图片'''import osfrom PIL import Imagesize = 128, 128ImageFile = 'C:/Users/xxx/Desktop/2.jpg'# 分割文件路径和后缀名FilePath, Fileext = os.path.splitext(ImageFile)# 设置保存后的文件格式outImageFile = "C:/Users/xxx/Desktop/3.jpg"# 打开图片im = Image.open(ImageFile)# 设置图片复制的4个值box = 200,0, 1024,768# 使用crop进行复制region = im.crop(box)'''使用transpose翻转图像可选值有Image.Rotate90,Image.ROTATE_180,Image.Rotate270,Image.FLIP_LEFT_RIGHT,Image.FLIP_TOP_BOTTOM分别代表翻转90°,180°270°,左右翻转，上下翻转'''region = region.transpose(Image.ROTATE_180)# 粘贴图片，此处的值不能修改否则会报错im.paste(region, box)# 保存修改后的图片im.save(outImageFile, 'JPEG')]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RobotFramework结合Jenkins]]></title>
    <url>%2F2017%2F12%2F22%2FRobotFramework%E7%BB%93%E5%90%88Jenkins%2F</url>
    <content type="text"><![CDATA[整体步骤 1、下载Jenkins2、添加节点3、安装robotframework插件4、配置job运行测试 一、下载Jenkins 下载地址：http://mirrors.jenkins-ci.org/ 推荐下载war包，如果有tomcat，把war包放到webapps目录里，直接启动tomcat即可 通常访问路径是http://localhost:8080/jenkins 如果没有tomcat，jenkins的war包里内置了jetty，直接用命令行java -jar jenkins.war就可以启动。如下图： 当看到一行信息：Jenkins is fully up and running，就代表Jenkins的服务已经启动了 启动成功后访问本地jenkins地址：http://IP:8080 安装常用的插件http://updates.jenkins-ci.org/download/plugins/如：ant、dashboard-view、disk-usage、subversion等 二、添加节点 我们启动Jenkins服务的这台机器在Jenkins里叫做master，而其他的连到master上的机器（物理机、虚拟机都可以）都是slave，也叫节点 1、点击系统管理，然后点击管理节点，就看到如下界面： 2、点击新建节点 3、输入slave的名字，点确定 注： executors：表示在slave上可以并行执行几个线程，也可以点后面的问号看说明。对于RF来说，建议设置为1 远程工作目录：在slave上创建jenkins工作目录的路径，我一般设置为D:\JK 标签：可以给slave加上一个或多个标签，通过标签选择slave 启动方法：启动slave的方法，推荐选第二个Launch slave agents via Java Web Start 如果是用来执行RF自动化测试案例的slave，严禁选择windows service的方式 设置好之后点保存。如图： 图中可以看到有多种方式来启动slave，推荐2来启动 三、安装robotframework插件 1、进入系统管理，点击管理插件，选择“高级”的上传插件 等提示安装完成，然后重启Jenkins就可以完成安装了 RF的插件下载路径：http://mirrors.jenkins-ci.org/plugins/robot/ 四、配置Job运行测试 1、在首页点左边的新建任务 对于RF的Job来说，自由风格就可以了 2、配置参数 必须设置的几个地方： a、Restrict where this project can be run: 前面的标签就在这里用上了。用来指定这个Job在哪个标签的slave上执行 b、源码管理：RF的案例推荐使用SVN c、构建：增加构建步骤-Execute Windows batch command，在命令行输入pybot.bat命令 d、构建后操作：增加构建后步骤-Publishes Robot Framework test results，第一个output默认可以为空，如果前面的pybot.bat指定了输出目录，那么这里也要对应进行设置，否则他找不到output.xml就没法解析结果 3、执行该JOB，查看控制台 4、RF插件的作用 a、在Jenkins的首页显示Job最新的构建结果，见最后那列Robot Results b、在Job的首页会显示运行结果的趋势图 五、其他有用的Job配置 1、丢弃旧的构建 2、构建触发器 build whenever a snapshot dependency is built当job依赖的快照版本被build时，执行本job build after other projects are built当本job依赖的job被build时，执行本job build periodically隔一段时间build一次，不管版本库代码是否发生变化第一个参数代表的是分钟 minute，取值 0~59第二个参数代表的是小时 hour，取值 0~23第三个参数代表的是天 day，取值 1~31第四个参数代表的是月 month，取值 1~12最后一个参数代表的是星期 week，取值 0~7，0 和 7 都是表示星期天例如：0 表示的是每个小时的第 0 分钟执行一次构建5 10-23 * 表示的是每天10-23区间的05分执行一次构建 poll scm隔一段时间比较一次源代码如果发生变更，那么就build。否则，不进行build]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>RobotFramework</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jenkins+Email Extension Plugin自定义RobotFramework邮件报告]]></title>
    <url>%2F2017%2F12%2F22%2F%E4%BD%BF%E7%94%A8Jenkins%2BEmail%20Extension%20Plugin%E8%87%AA%E5%AE%9A%E4%B9%89%E9%82%AE%E4%BB%B6%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[目标 实现RobotFramework的脚本定时自动执行，执行完后自动将结果发送到指定邮箱 前提 1、配置好Robot Framework的环境，脚本可以正常运行2、部署好Jenkins的环境3、在Jenkins里安装好以下插件：Email Extension Plugin、Zentimestamp plugin、Robot Framework plugin 配置 1、进入【系统管理】-【系统设置】进行如下配置： 》设置${BUILD_TIMESTAMP}格式 》配置 Extended E-mail Notification默认设置 2、创建一个任务 3、任务的配置 》设置保留的构建的数量 》设置每天凌晨1点的时候自动执行 》增加构建步骤，类型为：Execute shell 》设置运行RobotFramework脚本的命令，这里用-d 来定义RobotFramework的结果输出目录，格式如： robot -d /结果输出/${BUILD_TIMESTAMP} /脚本目录/ 这里用${BUILD_TIMESTAMP}环境变量是让每次构建的结构都放在以日期格式命名的文件夹里 》增加构建后操作步骤Publish Robot Framework test results，配置如下： 》再增加一个构建后操作步骤Editable Email Notification： 4、自定义RobotFramework结构汇总的邮件模板格式，效果如： 前面 Extended E-mail Notification默认设置里Default Content的值是填写${SCRIPT, template=”robot_results.groovy”} 设置这个模板 在$Jenkins_Home/email-templates目录（如果没有email-templates请自行创建）下创建一个robot_results.groovy文件，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;% import java.text.DateFormat import java.text.SimpleDateFormat %&gt; &lt;!-- Robot Framework Results --&gt; &lt;% def robotResults = false def actions = build.actions // List&lt;hudson.model.Action&gt; actions.each() &#123; action -&gt; if( action.class.simpleName.equals(&quot;RobotBuildAction&quot;) ) &#123; // hudson.plugins.robot.RobotBuildAction robotResults = true %&gt; &lt;div style=&quot;width:100%;float:left&quot;&gt; &lt;table cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; border=&quot;1&quot; align=&quot;left&quot;&gt; &lt;thead&gt; &lt;tr bgcolor=&quot;#F3F3F3&quot;&gt; &lt;td style=&quot;text-align:center&quot; colspan=&quot;4&quot;&gt;&lt;b&gt;自动化测试汇总报告&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td bgcolor=&quot;#F3F3F3&quot; style=&quot;width:80px&quot;&gt;&lt;b&gt;详细报告:&lt;/b&gt;&lt;/td&gt; &lt;td colspan=&quot;4&quot;&gt;&lt;a href=&quot;$&#123;rooturl&#125;$&#123;build.url&#125;robot/report/report.html&quot;&gt;点击查看报告详情&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor=&quot;#F3F3F3&quot;&gt; &lt;td&gt;&lt;b&gt;用例总数&lt;/b&gt;&lt;/td&gt; &lt;td&gt;&lt;b&gt;通过&lt;/b&gt;&lt;/td&gt; &lt;td style=&quot;width:60px&quot;&gt;&lt;b&gt;不通过&lt;/b&gt;&lt;/td&gt; &lt;td style=&quot;width:100px&quot;&gt;&lt;b&gt;通过率&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;%= action.result.overallTotal %&gt;&lt;/td&gt; &lt;td&gt;&lt;b&gt;&lt;span style=&quot;color:#66CC00&quot;&gt;&lt;%= action.result.overallPassed %&gt;&lt;/span&gt;&lt;/b&gt;&lt;/td&gt; &lt;td&gt;&lt;b&gt;&lt;span style=&quot;color:#FF3333&quot;&gt;&lt;%= action.result.overallFailed %&gt;&lt;/span&gt;&lt;/b&gt;&lt;/td&gt; &lt;td&gt;&lt;%= action.overallPassPercentage %&gt;%&lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor=&quot;#F3F3F3&quot;&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;b&gt;Test Name&lt;/b&gt;&lt;/td&gt; &lt;td&gt;&lt;b&gt;Status&lt;/b&gt;&lt;/td&gt; &lt;td&gt;&lt;b&gt;Elapsed Time&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;% def suites = action.result.allSuites suites.each() &#123; suite -&gt; def currSuite = suite def suiteName = currSuite.displayName // ignore top 2 elements in the structure as they are placeholders while (currSuite.parent != null &amp;&amp; currSuite.parent.parent != null) &#123; currSuite = currSuite.parent suiteName = currSuite.displayName + &quot;.&quot; + suiteName &#125; %&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;&lt;b&gt;&lt;%= suiteName %&gt;&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% DateFormat format = new SimpleDateFormat(&quot;yyyyMMdd HH:mm:ss&quot;) def execDateTcPairs = [] suite.caseResults.each() &#123; tc -&gt; Date execDate = format.parse(tc.starttime) execDateTcPairs &lt;&lt; [execDate, tc] &#125; // primary sort execDate, secondary displayName execDateTcPairs = execDateTcPairs.sort&#123; a,b -&gt; a[1].displayName &lt;=&gt; b[1].displayName &#125; execDateTcPairs = execDateTcPairs.sort&#123; a,b -&gt; a[0] &lt;=&gt; b[0] &#125; execDateTcPairs.each() &#123; def execDate = it[0] def tc = it[1] %&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;%= tc.displayName %&gt;&lt;/td&gt; &lt;td&gt;&lt;b&gt;&lt;span style=&quot;color:&lt;%= tc.isPassed() ? &quot;#66CC00&quot; : &quot;#FF3333&quot; %&gt;&quot;&gt;&lt;%= tc.isPassed() ? &quot;PASS&quot; : &quot;FAIL&quot; %&gt;&lt;/span&gt;&lt;/b&gt;&lt;/td&gt; &lt;td&gt;&lt;%= tc.getDuration().intdiv(60000)+&quot;分&quot;+(tc.getDuration()-tc.getDuration().intdiv(60000)*60000).intdiv(1000)+&quot;秒&quot; %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% if(tc.errorMsg != null) &#123;%&gt; &lt;tr&gt; &lt;td &gt;&lt;b&gt;&lt;span style=&quot;font-size:10px;color:#FF3333&quot;&gt;错误描述：&lt;/span&gt;&lt;/b&gt;&lt;/td&gt; &lt;td colspan=&quot;3&quot;&gt;&lt;span style=&quot;font-size:10px&quot;&gt;&lt;%= tc.errorMsg%&gt;&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% &#125;%&gt;&lt;% &#125; // tests &#125; // suites %&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;p style=&quot;color:#AE0000;clear:both&quot;&gt;*这个是通过Jenkins自动构建得出的报告，仅供参考。&lt;/p&gt; &lt;/div&gt; &lt;% &#125; // robot results &#125; if (!robotResults) &#123; %&gt; &lt;p&gt;No Robot Framework test results found.&lt;/p&gt; &lt;% &#125; %&gt; Jenkins_Home的路径：]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>RobotFramework</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RobotFramework/Appium元素定位问题]]></title>
    <url>%2F2017%2F12%2F21%2FRobotFramework%2CAppium%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[A 先说说不用xpath的场景，一般是用于存在id或者name 1，app上面定位用的最多的当然是id，也就是上面看到的resource-id，后面就是其所对应的值。所以在定位的时候可以是driver.find_element_by_id(‘com.wlqq:id/title_left_btn’) 注意一点就是，如果id不是唯一的，那么此办法行不通，可考虑增加下标值[x]来区分（如何加后面的xpath会提到） robotframework+appiumLibrary，使用方式就是 click element | id=com.wlqq:id/title_left_btn 2，第二种常用的办法就是name，而这里的name和web也就是html里面的name不太一样，web里面的name就是标签对应的属性name的值，而这里其实是上面图里的text的值。当然也就是在使用的时候需要用by_name(‘账单’)，或者是 name=账单 B 用到xpath的场景主要为没有id或者没有name，或者name是一个不可控的值（或者叫会发生变化的值）。xpath简单点就是按路径定位包括一级或者多级其实路径分两种，一种是绝对路径（以第一个标签为参照物），另一种是相对路径（已其他已知的标签为参照物） 1、先说说有id或者name的场景使用xpath的情况 就比如上面的”账单”和”我要”的id都是com.wlqq:id/title_left_btn，当前页面只有这两个id是这个，那么用id定位”账单”的时候，就需要写xpath=（//android.widget.TextView[@resource-id=”com.wlqq:id/title_left_btn”])[1]定位”我要”就是xpath=（//android.widget.TextView[@resource-id=”com.wlqq:id/title_left_btn”])[2] 此处注意三点： 下标是从1开始，而不是0; 如果有下标，需要用括号把前面的部分括起来，并且前面需要加xpath= 就是和web不一样的就是标签的取值，在这里取的是class的值=android.widget.TextView而不是看到的标签TextView，记住用class代替标签 当然是用name的情况也是一样的。无非就是//android.widget.TextView[@text=”我要”]，另外注意下，这里使用的@text，而用@name或报错，和上面的resource-id一样，用xpath的时候就用本身显示的就好。 另外，上面的只是为了说明1个层级的时候xpath的用法，xpath的书写规则基本是越少越好。所以层级也是越少越好。有1层可以唯一定位就不要2层。 2、没有id或者name的场景 1，场景：点击上图小人图标，但是他没有id和text属性。办法就是xpath a，用绝对路径的写法 如果图上的第一个是最顶上的话，就是 这样的，也就是需要7个层级，一次写下来就是：（数字写得有点丑。） 1//android.widget.LinearLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.RelativeLayout/android.widget.RelativeLayout/android.widget.LinearLayout[2]/android.widget.ImageButton 这种写法注意几点: [2]注意是2而不是3，因为与标签的值有关。只有2个LinearLayout 路径长度偏长，而且因为只有class的值，对于一些页面控件较多的，可能不止一个，也就是可能这种写法也都不是唯一 绝对路径基本很少使用，如果人品太差，遇到页面全是没有id或者name的，那就没办法了。或者考虑一些坐标 b，使用相对路径的办法来定位 1），大家可以看到，这个图里面有一个唯一的中文词汇–”钱包”。我们可以通过这个钱包来定位我们的小人图片。先分析下位置关系：找找关系也就是如图所示，小人图标3是钱包1的弟弟2 LinearLayout标签的儿子ImageButton。儿子好理解，xpath的层级关系也就是父子关系用/表示。//android.widget.LinearLayout/android.widget.ImageButton这样就能表示弟弟的儿子了 xpath里面有一个轴，简单点可以理解为一个函数吧。preceding-sibling:: 可以找到节点前面也就是哥哥节点，following-sibling::可以找到节点后面也就是弟弟节点，关于轴的更多用法啊，可以自行百度xpath的语法。这里还有一个用的多的就是parent:: ，可以找到节点的父亲节点。但是父亲节点可以用..表示。下面就来具体说一下怎么用： 那么这里的定位方法就是上图中的3个层级：//android.widget.TextView[@text=”钱包”]/following-sibling::android.widget.LinearLayout/android.widget.ImageButton。 第一级就同前面说的唯一的找到钱包这个位置，后面的一级就是钱包的弟弟，也就是following-sibling::android.widget.LinearLayout。当然注意因为是紧挨着的，所以弟弟没有下班，可想而知如果是第几个弟弟，就加个下标吧。哥哥也是同理。 2），前面用到了兄弟的关系，下面说一下儿子与父亲的关系。父子关系还是用图来说明 我们的钱包1的父亲2有一个儿子3的儿子4就是我们的小人图标。这就是找关系。关系找到了，那我们就可以用这个关系来写xpath了。也就是钱包（//android.widget.TextView[@text=”钱包”]）的父亲（/parent::android.widget.RelativeLayout ）的第二个class=android.widget.LinearLayout的儿子（/android.widget.LinearLayout[2]）的儿子（小人/android.widget.ImageButton）, 连起来就是：1//android.widget.TextView[@text=&quot;钱包&quot;]/parent::android.widget.RelativeLayout/android.widget.LinearLayout[2]/android.widget.ImageButton 顺便说一下父亲这个位置可以用..来代替，相比很多人都知道..在路径里面指的就是上级。1//android.widget.TextView[@text=&quot;钱包&quot;]/../android.widget.LinearLayout[2]/android.widget.ImageButton 最后再强调下关于这个地方，下标为什么是[2]，是因为只与class相同的有关。钱包的class不一样。所以它就不算了。 3），关于相对路径的父子关系，已经兄弟关系，相比大家应该有所体会了吧。如果还是没太懂，咱们再来个复杂点的例子。可能只是举例说明下语法。实际下面的可能不会这样复杂的写。先上图： 假设我们需要通过加入购物车这个位置来定位我们的立即定位按钮，那么，我们的一种写法就是图上的这个关系7层级。也就是加入购物车7(//android.widget.TextView[@text=”加入购物车”])的父亲1（/..）的父亲2（/..）的父亲3(/..)的第二个兄弟4（/following-sibling::android.view.View[2]）的儿子5(/android.view.View)的儿子6(也就是我们的立即购买/android.widget.TextView)，连起来就是 1//android.widget.TextView[@text=&quot;加入购物车&quot;]/../../../following-sibling::android.view.View[2]/android.view.View/android.widget.TextView 注意：使用text的时候避免使用输入框的默认输入值，因为当你真实输入值之后，就没有这个text了，也就找不到路径了。另外也可以用模糊匹配，xpath有一个contains函数。用法//android.widget.TextView[contains(@text,”购物车”)].也能找到“加入购物车”这个位置 元素定位 其他文章介绍 app控件获取之uiautomatorviewerhttp://www.cnblogs.com/lazytest/p/5612709.html Appium+robotframework xpath元素定位、难点解决http://blog.csdn.net/mr_zeng1993/article/details/77962733 RobotFramework测试问题二：各种元素不能定位问题http://blog.csdn.net/Allan_shore_ma/article/details/70792682?locationNum=9&amp;fps=1 元素定位介绍http://blog.csdn.net/deadgrape/article/details/50628113]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>RobotFramework</tag>
        <tag>Appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RobotFramework问题解决方法]]></title>
    <url>%2F2017%2F12%2F21%2FRobotFramework%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[解决使用robot framework + selenium测试时，RIDE运行一次后不显示log的问题 http://blog.csdn.net/dassh/article/details/50404529 robot framework-requests库安装过程问题解决 http://www.cnblogs.com/puresoul/p/4472893.html Robotframework+AppiumLibrary 过程中遇到的问题及解决办法 定位的时候用id定位的而且在虚拟机上是可以跑通的，但是到真机上就报错 用appium在命令行启动后,运行用例时报错:api版本不能低于17. 用命令adb devices提示找不到设备 可编辑区域用input text输入中文时,代码中的中文内容并没有输入到文本框中 调用hide keyboard关键词后无法再次调出键盘 Robotframework+appiumLibrary中用xpath时总是报错 http://www.robotframework.net/article/65 robotframework出现错误：Keyword ‘AppiumLibrary.Open Application’ expected 1 to 2 non-keyword arguments http://www.cnblogs.com/LittleRedPoint/p/4476949.html 关键字run keyword if 如何在一个条件下接多个执行语句 多个执行语句封装成一个关键字：run keyword if +条件 +封装的关键字解决方法：Run Keyword If 1==1 Run Keywords log 1 AND log 2可以看到用到了关键字Run Keywords和AND来处理 比如Run Keyword If ‘${B_name}’==’${B}’ and ‘${C}’==’0’ -&gt;用and就可以 常见问题总结 元素找不到 如何判断这个元素disable log显示乱码 没这个Get from Dictionary关键字 怎么设置全局变量 日志输出想改个路径 脚本assert，还想继续执行 If… Else if… Else 不行 弹出框怎么处理 需要验证提示信息，（提示输入非法等等）用到鼠标悬停 日期控件怎么办 下拉框我怎么选不上 2选1的按钮怎么做 多选按钮怎么做 Click Button点不到元素 For循环怎么写 IF语句，RF中如果让他执行多行关键字 http://www.robotframework.net/?/article/89]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>RobotFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展RobotFramework，实现失败用例自动再执行（失败重跑）]]></title>
    <url>%2F2017%2F12%2F21%2F%E6%89%A9%E5%B1%95RobotFramework%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%A4%B1%E8%B4%A5%E7%94%A8%E4%BE%8B%E8%87%AA%E5%8A%A8%E5%86%8D%E6%89%A7%E8%A1%8C%EF%BC%88%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%B7%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[出错后退出 在默认情况下，当一个测试用例中的某个关键字返回错误时，这个测试用例就停止执行剩余的关键字。RF会继续执行下一个用例。这么做的好处是节省时间–反正这里出问题要返回来看了，再继续执行剩下的关键字也没有用了。 出错后继续执行 但是，有时候，我们却需要执行用例中的所有关键字，例如：要获取更多的出错信息、更改某些全局相关的变量、做teardown或者rollback操作等。这时候，我们就可以使用BuiltIn库中的关键字来让特定关键字出错后RF仍然执行用例中剩余关键字。 第一个关键字是：Run Keyword And Continue On Failure 假设我们有个关键字叫做 Mykeyword我们这样使用： 这样，不管Mykeyword这个关键字是否fail，下一个关键字Log都会被执行。如果Mykeyword有返回值，我们可以这么使用： 获取关键字执行结果后继续执行 有时候，我们需要获取某个关键字的执行结果，然后根据结果做不同后续操作，这个时候，我们就会用到关键字Run Keyword And Ignore Error 。假设我们要执行一个关键字Mykeyword，关键字有一个返回值。我们可以如下使用： Run Keyword And Ignore Error 有2个返回值${result}获取执行结果，值为PASS或者FAIL；${returnvalue}获取Mykeyword的返回值 TestSuit级别出错处理 有些场合，我们想要在整个testsuit执行结束后根据执行结果做一些特殊操作。这时候，我们就用上了下面几个关键字： Run Keyword If All Critical Tests PassedRun Keyword If All Tests PassedRun Keyword If Any Critical Tests FailedRun Keyword If Any Tests FailedRun Keyword If Test FailedRun Keyword If Test PassedRun Keyword If Timeout Occurred 这些关键字有些像Java中的Finally语句，但是略有区别，大家可以在使用的时候细细体会。另外要说的是，这些关键字只能被用到Suit Teardown部分（一般会写到一个用户自定义关键字中,被Suit Teardown调用） 实例：]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>RobotFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RobotFramework环境搭建（仅针对App）]]></title>
    <url>%2F2017%2F12%2F21%2FRobotFramework%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BB%85%E9%92%88%E5%AF%B9App%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、RF环境搭建 安装步骤 1.python（使用2.7版本） 安装方法 1.exe文件，直接双击默认安装2.安装完设置Python环境变量：将“D:\Python27”和“D:\Python27\Scripts”添加到环境变量“PATH”项中(注意环境变量之间用“;”隔开) 下载地址 https://www.python.org/downloads/release/python-2713/ 备注根据电脑位数下载，我下载64位的python2.7.13.msi文件（目前最新版本）；该版本python已自带pip 2.wxPython（使用2.8版本） 安装方法exe文件，下载后默认安装 下载地址https://sourceforge.net/projects/wxpython/files/wxPython/ 备注只能使用wxPython2.8-win64-unicode-2.8.12.1-py27 3.robotframework 安装方法命令行安装：pip install robotframework 备注pip已包含在python中，不需要重新下载，直接使用即可 4.robotframework-ride 安装方法命令行安装：pip install robotframework-ride 备注安装成功后，命令行直接输入ride.py检查是否安装成功 5.robotframework-appiumlibrary 安装方法命令行安装：pip install robotframework-appiumlibrary 备注其他需要的库，都可以直接通过pip install安装 安装后检查 1.配置ride为桌面快捷方式： 1) 新建快捷方式，在桌面右击鼠标，弹出的菜单选择 新建-快捷方式 ，然后在 请键入对象 的位置输入这一行命令，C:\Python27\pythonw.exe -c “from robotide import main; main()”，注意“C:\Python27\pythonw.exe”是python安装的路径，需要换成你的Python所在目录的路径；注意双引号为英文。2) 点击下一步，输入你要建立的快捷方式的名称，点击完成，看到图标表示已经建好。3) 显示不爽，图标要换成机器人图标，需要快捷方式上点击右键-属性，点击“更改图标”，在浏览里找到目录F:\Python27\Lib\site-packages\robotide\widgets，里面有个robot.ico的图标（大家到自己的安装目录相同路径去找一下）选它之后，点打开，确定之后再确定就可以了，双击图标，进入ride操作页面 2.Cmd命令下执行ride.py，能成功进入ride页面说明robot framework安装成功。 3.在ride操作页面新建一个项目，把AppiumLibrary类加载，加载中如果不显示红色说明安装成功。 4.Cmd命令下执行pip list，可以查看安装的包列表有哪些 二、Android环境搭建 安装步骤 1.JDK 安装方法双击安装，并配置环境变量：1.系统变量 -&gt; 新建 JAVA_HOME 变量：变量值填写jdk的安装目录2.系统变量 -&gt; 新建 CLASSPATH 变量： .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar;3.path变量中增加： %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; 下载地址https://www.java.com/zh_CN/download/manual.jsp 备注Android是由Java语言开发的，所以想开发Android应用首先需要Java环境，所以，我们首先需要安装Java环境 2.SDK 安装方法下载安装，配置环境变量：1.系统变量 -&gt; 新建ANDROID_HOME变量：D:\android-sdk2.path变量中增加： ;%ANDROID_HOME%\platform-tools;%ANDROID_HOME%\tools; 下载地址http://developer.android.com/sdk/index.html（使用已有版本） 备注Android SDK提供了你的API库和开发工具构建，测试和调试应用程序，Android。简单来讲，Android SDK 可以看做用于开发和运行Android应用的一个软件 3.安卓模拟器（夜神模拟器） 三、appium环境搭建 安装步骤 1.node.js 安装方法exe文件，直接双击安装，安装完设置node环境变量，将C:\Program Files\nodejs（使用自己的路径）添加到环境变量“PATH”项中(注意环境变量之间用“;”隔开) 下载地址http://nodejs.org/download/ 备注检测是否安装成功：Cmd命令窗口，输入npm 2.Appium 安装方法cmd命令行执行： npm install -g appium配置环境变量：1.APPIUM_HOME： D:\Appium\Appium\node_modules（根据自己的安装路径配置）2.path： %APPIUM_HOME%.bin 下载地址可以直接使用安装包进行安装，然后调用就可以 3.Appium-Python-Client 安装方法1.下载安装2.命令安装：pip install Appium-Python-Client 下载地址https://pypi.python.org/pypi/Appium-Python-Client/0.24 安装成功后检查：cmd中输入appium-doctor到此，appium+robotframework已安装成功 四、使用过程中的问题 1.调用appiumLibrary库需要额外安装six库pip install six 2.引用库使用过程以红色标色红色表示引入失败，黑色为成功，失败可以在Tools / View RIDE Log下查看详细的失败日志 3.解决使用robot framework + selenium测试时，RIDE运行一次后不显示log的问题解决方法：1） 修改python路径\Lib\site-packages\robotide\contrib\testrunner目录下testrunner.py文件（第400行）return信息改成如下即可： 12345try: result=result.decode('UTF-8') except UnicodeDecodeError: pass return result 2） 删除testrunner.pyc文件3） 重新启动ride跑起来4） 解决问题 4.(node:784) fs: re-evaluating native module sources is not supported. If you are using the graceful-fs module, please update it to a more recent version.解决方法：Nodejs版本问题，6.0以上不支持graceful-fs，切换版本为6.0以下即可可以cmd查询node版本，“node -v”，然后查询安装位置“where node”，到官网下载6.9.4替换即可]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>RobotFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter性能测试报告]]></title>
    <url>%2F2017%2F12%2F20%2FJMeter%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[随手借 [ 注册模块 ] 压力测试报告 一、测试内容本次测试是针对随手借APP进行的压力测试，在注册阶段过程，对注册接口进行压力测试，其中涵盖注册、验证码验证与RSA公钥加密功能。 二、测试方法本次采用apache的开源测试工具jmeter，采用本地动态拼装请求数据并通过http协议post方式发送注册请求。在用户数已达到500w的基础上，采用高并发对服务器进行负载注册，观察整个注册过程的结果以及服务器期间的响应情况，结合返回的平均响应时间、最快响应时间、最慢响应时间、吞吐量、服务器性能（CPU/Memory/（I/O））、服务器每秒处理的事务数等有效数据，对数据进行统计整合，再对线上服务器与测试服务器在性能配置上进行比对，从而评估线上环境的阈值。 注：数据以最终能爬取到的有效类型为准。 三、测试场景1、15个用户并发注册2、25个用户并发注册3、35个用户并发注册4、30个用户每隔1秒注册5、30个用户每隔3秒注册6、30个用户每隔5秒注册7、1分钟内且每隔0.1s注册8、3分钟内且每隔0.1s注册9、5分钟内且每隔0.1s注册10、暴力测试 四、系统参数 注：线上环境有三台服务器，两台系统为linux，一台系统为Windows，本次就测试环境对比线上单台linux服务器 五、专业名词说明 六、性能测试结果1、15个用户并发注册500w+用户下，并发15个用户进行注册，项目日志开启info状态 1.1、聚合报告 1.2、响应时间分布图 1.3、性能指数 1.4、服务器性能指数 ……………….其他场景省略………………. 七、测试结果分析1、用户并发响应情况 1.1、响应数据列表 1.2、响应数据曲线模型 1.3、结果分析 通过曲线模型，可以大致看出，在用户并发数逐步递增的情况下，服务器的响应时间以相对吻合比例的趋势进行递增，且请求响应正常，判定服务器在15/25/35用户并发注册数下，能保持正常运行。 2、用户隔秒注册响应情况…. 3、用户注册响应情况…. 4、暴力注册响应情况…. 测试结果： 本次压力测试，最高遍历1小时内连续进行用户注册，该行为正确注册用户数达10861，整个压力测试过程服务器响应均正常，且所部署的测试环境服务器在CPU/Memory/（I/O）性能上也无出现异常，故判定：随手借注册模块目前负载能力良好 注：因测试服务器需保持正常，所以负载服务器临界暂不考虑 测试时间：2017-10-13测试对象：测试服务器]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RobotFramework-AppiumLibrary关键字]]></title>
    <url>%2F2017%2F12%2F20%2FRobotFramework-AppiumLibrary%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[AppiumLibrary常用关键字 一、实用函数 二、校验函数三、等待函数四、其他函数 1.条件判断函数 关键字：Run Keyword If 用法：Run Keyword If…ELSE IF…ELSE 实例：1）用Run Keyword If执行单条语句 2）用Run Keyword If执行多条语句时，在需要执行多条语句的if或else if或else后，增加关键字：Run Keywords 2.检查某关键字的返回状态 关键字：Run Keyword And Return Status返回值：布尔值，True False 实例：通常和Run Keyword If关键字搭配使用含义：判断当前界面中是否存在取消按钮；如果存在，则do something 3.For循环 关键字：For 实例：1）For循环单独使用时 2）For循环嵌套Run Keyword If语句，退出循环 4.自定义关键字 创建方法：测试项目-New Resource-New User Keyword 实例： 在需要使用自定义关键字的测试套件Edit标签页，Resource导入关键字，导入结果为蓝色，则导入正确 用法：导入resource后，在测试用例中，直接调用 AppiumLibrary关键字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347xpath应该匹配次数 [Arguments] $&#123;xpath&#125; $&#123;count&#125; Xpath Should Match X Times $&#123;xpath&#125; $&#123;count&#125;上传文件 [Arguments] $&#123;path&#125; $&#123;data&#125; $&#123;encode&#125;=base64 Push File $&#123;path&#125; $&#123;data&#125; $&#123;encode&#125;元素不应该包含文本 [Arguments] $&#123;locator&#125; $&#123;expected&#125; $&#123;msg&#125;= Element Should not Contain Text $&#123;locator&#125; $&#123;expected&#125; $&#123;msg&#125;元素值应该是 [Arguments] $&#123;locator&#125; $&#123;expected&#125; Element Value Should Be $&#123;locator&#125; $&#123;expected&#125;元素名应该是 [Arguments] $&#123;path&#125; $&#123;name&#125; Element Name Should Be $&#123;path&#125; $&#123;name&#125;元素属性应该匹配 [Arguments] $&#123;locator&#125; $&#123;attr_name&#125; $&#123;match_pattern&#125; $&#123;regx&#125;=False Element Attribute Should Match $&#123;locator&#125; $&#123;attr_name&#125; $&#123;match_pattern&#125; $&#123;regx&#125;元素应该包含文本 [Arguments] $&#123;locator&#125; $&#123;expected&#125; $&#123;msg&#125;=None Element Should Contain Text $&#123;locator&#125; $&#123;expected&#125; $&#123;msg&#125;元素应该失效 [Arguments] $&#123;locator&#125; $&#123;level&#125;=INFO Element should be disabled $&#123;locator&#125; $&#123;level&#125;元素应该有效 [Arguments] $&#123;locator&#125; $&#123;level&#125;=INFO Element should be enabled $&#123;locator&#125; $&#123;level&#125;元素文本应该是 [Arguments] $&#123;locator&#125; $&#123;expected&#125; $&#123;msg&#125;=None Element Text Should Be $&#123;locator&#125; $&#123;expected&#125; $&#123;msg&#125;关闭当前应用 Close Application关闭所有应用 Close All Applications切换应用 [Arguments] $&#123;index_or_alias&#125; Switch Application $&#123;index_or_alias&#125;切换页面内容 [Arguments] $&#123;webview&#125; Switch To Context $&#123;webview&#125;卸载应用 [Arguments] $&#123;application_id&#125; Remove Application $&#123;application_id&#125;后台运行 [Arguments] $&#123;sec&#125; Background App $&#123;sec&#125;向上滚动 [Arguments] $&#123;locator&#125; Scroll Up $&#123;locator&#125;向下滚动 [Arguments] $&#123;locator&#125; Scroll Down $&#123;locator&#125;失败后运行关键字 [Arguments] $&#123;keyword&#125; [Documentation] Example: # Disables run-on-failure functionality and stores the previous kw name in a variable. # Restore to the previous keyword. ... ... Register Keyword To Run On Failure \ \ \ Log Source ... \ \ \ \ \ \ \ # Run `Log Source` on failure. ... ... $&#123;previous kw&#125;= ... Register Keyword To Run On Failure \ \ Nothing ... ... ... Register Keyword To Run On Failure \ \ \ \ $&#123;previous kw&#125; \ \ \ Register Keyword To Run On Failure $&#123;keyword&#125;打印资源 [Arguments] $&#123;level&#125; Log Source $&#123;level&#125;打开URL [Arguments] $&#123;url&#125; [Documentation] Example: ... ... 打开应用 ... http://localhost:4755/wd/hub \ platformName=iOS \ platformVersion=7.0 ... deviceName=‘iPhone Simulator‘ ... browserName=Safari ... ... 打开URL \ http://m.webapp.com Go To URL $&#123;url&#125;打开应用 [Arguments] $&#123;url&#125; $&#123;platformName&#125; $&#123;version&#125; $&#123;deviceName&#125; $&#123;app&#125; [Documentation] 打开应用 $&#123;url&#125; $&#123;platformName&#125; $&#123;version&#125; $&#123;devicename&#125; $&#123;app&#125; @&#123;args&#125; ... ... 例如： ... ... 打开应用 http://localhost:4723/wd/hub Android 5.1.1 5e25d20d $&#123;CURDIR&#125;$&#123;/&#125;app$&#123;/&#125;fft.apk ... ... $&#123;url&#125; 是用于访问应用的地址，一般是固定的。 url 和 端口可以根据具体地址修改。 ... $&#123;version&#125; \ 是安卓的版本 ... $&#123;devicename&#125; 是手机的UDID, 可以打开cmd 然后用 adb devices -l \ 看到设备列表。 ... UDID 是看到的第一列的内容，真机是一串字符串，模拟器是 \ ip:port \ 的形式 ... $&#123;app&#125; 是apk 存放的路径 $&#123;CURDIR&#125; 系统变量，取得当前脚本路径。 $&#123;/&#125; 系统变量 ‘/‘ open application $&#123;url&#125; platformName=$&#123;platformName&#125; platformVersion=$&#123;version&#125; deviceName=$&#123;deviceName&#125; app=$&#123;app&#125;按关键字 [Arguments] $&#123;keycode&#125; $&#123;metastate&#125;=None Press Keycode $&#123;keycode&#125; $&#123;metastate&#125;摇动手机 Shake放大元素 [Arguments] $&#123;locator&#125; $&#123;percent&#125;=200% $&#123;step&#125;=1 Zoom $&#123;locator&#125; $&#123;percent&#125; $&#123;step&#125;敲击元素 [Arguments] $&#123;locator&#125; Tap $&#123;locator&#125;横屏 [Documentation] 手机设置横屏 LANDSCAPE清除文本 [Arguments] $&#123;locator&#125; Clear Text $&#123;locator&#125;滑动 [Arguments] $&#123;start_x&#125; $&#123;start_y&#125; $&#123;end_x&#125; $&#123;end_y&#125; swipe $&#123;start_x&#125; $&#123;start_y&#125; $&#123;end_x&#125; $&#123;end_y&#125;滚动 [Arguments] $&#123;start_locator&#125; $&#123;end_locator&#125; [Documentation] 从一个元素滚动到另一个元素 Scroll $&#123;start_locator&#125; $&#123;end_locator&#125;点击元素 [Arguments] $&#123;locator&#125; Click Element $&#123;locator&#125;点击元素坐标 [Arguments] $&#123;coordinate_x&#125; $&#123;coordinate_y&#125; Click Element At Coordinates $&#123;coordinate_x&#125; $&#123;coordinate_y&#125;点击固定点 [Arguments] $&#123;x&#125; $&#123;y&#125; @&#123;args&#125; Click A Point $&#123;x&#125; $&#123;y&#125; @&#123;args&#125;点击按钮 [Arguments] $&#123;index_or_name&#125; Click Button $&#123;index_or_name&#125;点击文本 [Arguments] $&#123;text&#125; $&#123;exact_match&#125;=false [Documentation] 点击匹配到文本的元素： ... ... 点击文本 &quot;text&quot; ... 点击文本 &quot;text&quot; True ... ... 默认模糊匹配所有元素，可以设置成精确匹配。 ... 如果可以匹配到两个或两个以上的元素，那么需要用 click Element 元素，去处理。 Click Text $&#123;text&#125; $&#123;exact_match&#125;睡眠 [Arguments] $&#123;sec&#125; sleep $&#123;sec&#125;竖屏 PORTRAIT等待页面元素出现 [Arguments] $&#123;locator&#125; $&#123;timeout&#125;=100 $&#123;err&#125;=None Wait Until Page Contains Element $&#123;locator&#125; $&#123;timeout&#125; $&#123;err&#125;等待元素出现文本 [Arguments] $&#123;text&#125; $&#123;timeout&#125;=10 $&#123;err&#125;=None Wait Until Page Contains $&#123;text&#125; $&#123;timeout&#125; $&#123;err&#125;等待页面不包含元素 [Arguments] $&#123;locator&#125; $&#123;timeout&#125;=10 $&#123;err&#125;=None Wait Until Page Does Not Contain Element $&#123;locator&#125; $&#123;timeout&#125; $&#123;err&#125;等待页面不包含文本 [Arguments] $&#123;text&#125; $&#123;timeout&#125;=10 $&#123;err&#125;=None Wait Until Page Does Not Contain $&#123;text&#125; $&#123;timeout&#125; $&#123;err&#125;缩小元素 [Arguments] $&#123;locator&#125; $&#123;percent&#125;=200% $&#123;step&#125;=1 Pinch $&#123;locator&#125; $&#123;percent&#125; $&#123;step&#125;获取Appium超时时间 $&#123;timeout&#125; Get Appium Timeout [Return] $&#123;timeout&#125;获取Web元素 [Arguments] $&#123;locator&#125; [Documentation] 获取匹配的定位器的第一个元素： ... ... $&#123;element&#125; 获取Web元素 id=name ... 点击元素 $&#123;element&#125; $&#123;element&#125; Get Webelement $&#123;locator&#125; [Return] $&#123;element&#125;获取元素坐标 [Arguments] $&#123;locator&#125; $&#123;location&#125; Get Element Location $&#123;locator&#125; [Return] $&#123;location&#125;获取元素尺寸 [Arguments] $&#123;locator&#125; $&#123;size&#125; Get Element Size $&#123;locator&#125; [Return] $&#123;size&#125;获取元素属性 [Arguments] $&#123;locator&#125; $&#123;name_or_value&#125; [Documentation 获取元素属性：（name 或者 value) ... $&#123;val&#125; \ 获取元素属性 $&#123;locator&#125; $&#123;name_or_value&#125; ... ... 例如： ... $&#123;val&#125; 获取元素属性 id=xxxx name ... $&#123;val&#125; 获取元素属性 id=xxxx value $&#123;val&#125; Get Element Attribute $&#123;locator&#125; $&#123;name_or_value&#125; [Return] $&#123;val&#125;获取匹配xpath数 [Arguments] $&#123;xpath&#125; [Documentation] 例如： ... ... $&#123;count&#125; \ \ \ 获取匹配xpath数 \ \ //android.view.View[@text=‘Test‘] $&#123;count&#125; Get Matching Xpath Count $&#123;xpath&#125; [Return] $&#123;count&#125;获取可见文本 $&#123;contents&#125; Get Contexts [Return] $&#123;contents&#125;获取当前文本 $&#123;context&#125; Get Current Context [Return] $&#123;context&#125;获取所有web元素 [Arguments] $&#123;locator&#125; [Documentation] @&#123;element&#125; 获取所有web元素 id=my_element ... 点击元素 @&#123;element&#125;[2] @&#123;element&#125; Get Webelements $&#123;locator&#125; [Return] @&#123;element&#125;获取文件 [Arguments] $&#123;file_path&#125; $&#123;decode&#125;=False pull file $&#123;file_path $&#123;decode&#125;获取文件夹 [Arguments] $&#123;folder_path&#125; $&#123;decode&#125;=False Pull Folder $&#123;folder_path&#125; $&#123;decode&#125;获取文本 [Arguments] $&#123;locator&#125; [Documentation] 获取符合元素的文本： ... $&#123;text&#125; \ 获取文本 \ //*[contains(@text,‘foo‘)] $&#123;text&#125; Get Text $&#123;locator&#125; [Return] $&#123;text&#125;获取网络连接情况 $&#123;stat&#125; Get Network Connection Status [Return] $&#123;stat&#125;获取资源 $&#123;source&#125; Get Source [Return] $&#123;source&#125;设置Appium超时 [Arguments] $&#123;sec&#125; Set Appium Timeout $&#123;sec&#125;设置网络连接状态 [Arguments] $&#123;sec&#125; Set Network Connection Status $&#123;sec&#125;输入值 [Arguments] $&#123;locator&#125; $&#123;val&#125; Input Value $&#123;locator&#125; $&#123;val&#125;输入密码 [Arguments] $&#123;path&#125; $&#123;passwd&#125; Input Password $&#123;path&#125; $&#123;passwd&#125;输入文本 [Arguments] $&#123;path&#125; $&#123;text&#125; Input Text $&#123;path&#125; $&#123;text&#125;返回 [Documentation] 浏览器返回上一个的页面 Go Back重置应用 Reset Application锁屏 [Arguments] $&#123;sec&#125; [Documentation] 这个方法只使用于IOS Lock $&#123;sec&#125;长按元素 [Arguments] $&#123;locator&#125; Long Press $&#123;locator&#125;长按关键字 [Arguments] $&#123;keycode&#125; $&#123;metastate&#125;=None [Documentation] keycode 可以在这个网址里面找到： ... http://developer.android.com/reference/android/view/KeyEvent.html. ... ... Args: ... \ \ \ \ - keycode - the keycode to be sent to the device ... \ \ - metastate - meta information about the keycode being sent Long Press Keycode $&#123;keycode&#125; $&#123;metastate&#125;隐藏键盘 Hide Keyboard页面不应该包含元素 [Arguments] $&#123;locator&#125; $&#123;lvl&#125;=INFO Page Should Not Contain Element $&#123;locator&#125; $&#123;lvl&#125;页面不应该包含文本 [Arguments] $&#123;locator&#125; $&#123;lvl&#125;=INFO Page Should Not Contain Text $&#123;locator&#125; $&#123;lvl&#125;页面应该包含元素 [Arguments] $&#123;locator&#125; $&#123;lvl&#125;=INFO Page Should Contain Element $&#123;locator&#125; $&#123;lvl&#125;页面应该包含文本 [Arguments] $&#123;locator&#125; $&#123;lvl&#125;=INFO Page Should Contain Text $&#123;locator&#125; $&#123;lvl&#125;页面截图 [Arguments] $&#123;filename&#125;= Capture Page Screenshot $&#123;filename&#125;]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>RobotFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter多维度的HTML图形化报告]]></title>
    <url>%2F2017%2F12%2F20%2FJMeter%E5%A4%9A%E7%BB%B4%E5%BA%A6%E7%9A%84HTML%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[新特性简介JMeter3.0提供一个用于生成HTML页面格式图形化报告的扩展模块 该模块支持通过两种方式生成多维度图形化测试报告： 1.在JMeter性能测试结束时，自动生成本次测试的HTML图形化报告2.使用一个已有的结果文件(如CSV文件)来生成该次结果的HTML图形化报告 默认提供的度量维度1.APDEX(Application Performance Index)指数2.聚合报告：类似于UI上的Aggregate Report3.Errors报告：展示不同错误类型的数量以及百分比4.响应时间变化曲线：展示平均响应时间随时间变化情况-&gt; 类似于JMeter Plugins在UI上的jp@gc - Response Times Over Time5.数据吞吐量时间曲线：展示每秒数据吞吐量随时间变化的情况-&gt; 类似于JMeter Plugins在UI上的jp@gc - Bytes Throughput Over Time6.Latency time变化曲线：展示Latency time随时间变化的情况-&gt; 类似于JMeter Plugins在UI上的jp@gc - Response Latencies Over Time7.每秒点击数曲线：类似于JMeter Plugins在UI上的jp@gc - Hits per Second8.HTTP状态码时间分布曲线：展示响应状态码随时间的分布情况-&gt; 类似于JMeter Plugins在UI上的jp@gc - Response Codes per Second9.事务吞吐量时间曲线(TPS)：展示每秒处理的事务数随时间变化情况-&gt; 类似于JMeter Plugins在UI上的jp@gc - Transactions per Second10.平均响应时间与每秒请求数的关系图：展示平均响应时间与每秒请求数(可以理解为QPS)的关系11.Latency time与每秒请求数的关系图：展示Latency time与每秒请求数的关系12.响应时间百分位图13.响应时间的百分位分布图14.活动线程数变化曲线：展示测试过程中活动线程数随时间变化情况15.平均响应时间与线程数的关系图：展示平均响应时间与线程数的关系-&gt; 类似于JMeter Plugins在UI上的jp@gc - Response Times vs Threads16.柱状响应时间分布图：展示落在各个平均响应时间区间的请求数情况 注：-Latency time = 接收到响应的第一个字节的时间点 - 请求开始发送的时间点-响应时间(JMeter术语中的Elapsed time) = 接收完所有响应内容的时间点 - 请求开始发送的时间点-Apdex 标准从用户的角度出发，将对应用响应时间的表现，转为用户对于应用性能的可量化为范围为 0-1 的满意度评价 快速入门1.确认基本配置在jmeter.properties或者user.properties确认如下配置项： 1234567891011121314jmeter.save.saveservice.bytes = true jmeter.save.saveservice.label = true jmeter.save.saveservice.latency = true jmeter.save.saveservice.response_code = true jmeter.save.saveservice.response_message = true jmeter.save.saveservice.successful = true jmeter.save.saveservice.thread_counts = true jmeter.save.saveservice.thread_name = true jmeter.save.saveservice.time = true # the timestamp format must include the time and should include the date. # For example the default, which is milliseconds since the epoch: jmeter.save.saveservice.timestamp_format = ms # Or the following would also be suitable jmeter.save.saveservice.timestamp_format = yyyy/MM/dd HH:mm:ss 如果希望在Errors报告中展示更详细数据，需要确保如下配置jmeter.save.saveservice.assertion_results_failure_message = true如果使用了事务控制器(Transaction Controller)，确认Generate parent sample为未勾选状态 生成报告a. 在压力测试结束时报告 基本命令格式：1jmeter -n -t &lt;test JMX file&gt; -l &lt;test log file&gt; -e -o &lt;Path to output folder&gt; 样例： 1jmeter -n -t F:\PerformanceTest\TestCase\script\getToken.jmx -l testLogFile -e -o ./output b. 使用已有的压力测试CSV日志文件生成报告 基本命令格式：1jmeter -g &lt;log file&gt; -o &lt;Path to output folder&gt; 样例：1jmeter -g D:\apache-jmeter-3.0\bin\testLogFile -o ./output 两个样例都会在\apache-jmeter-3.0\bin\output目录下产生如下文件(夹): 用浏览器打开index.html文件，即可查看各种图形化报告： 注：在3.0版本，由于源码中字符编码的问题，可能会遇到生成的报告中，中文标签展示为乱码的问题 解决办法：http://www.jianshu.com/p/034dd33554c0 自定义配置JMeter3.0在bin目录新增了reportgenerator.properties文件保存了所有关于图形化HTML报告生成模块的默认配置，要变更配置，建议不要直接编辑该文件，而是推荐在user.properties中去配置和覆盖。 1.总体配置 总体配置都是以jmeter.reportgenerator.为前缀，如：jmeter.reportgenerator.overall_granularity=60000 overall_granularity： 定义采样点粒度，默认为60000ms，通常在稳定性以外的测试中，我们可能需要定义更细的粒度，比如1000ms，我们可以在user.properties文件末尾添加如下配置：12#Change this parameter if you want to change the granularity of over time graphs.jmeter.reportgenerator.overall_granularity=6000 report_title： 定义报告的标题，我们可能需要将标题定义为实际测试项名称 apdex_satisfied_threshold： 定义Apdex评估中满意的阈值(单位ms) apdex_tolerated_threshold： 定义Apdex评估中可容忍的阈值Apdext = (Satisfied Count + Tolerating Count / 2) / Total Samples 另外，在jmeter.properties中，有关于集合报告中的三个百分位的默认值：123aggregate_rpt_pct1 : Defaults to 90 aggregate_rpt_pct2 : Defaults to 95 aggregate_rpt_pct3 : Defaults to 99 可以在user.properties中对其进行覆盖，如：1aggregate_rpt_pct1 = 70 效果如下： 2.图表配置每个图表配置都是以jmeter.reportgenerator.graph.&lt;图表名称&gt;.为前缀。 classname 图表的实现类，如果有自己定制的实现，将该配置的值写为自定义实现类的类名 title 图标标题，比如要汉化的时候，在这里配置中文标题 property.set_granularity 设置图标的采样点粒度，不配置时默认使用总体配置中的粒度设置 3.输出配置输出配置都以jmeter.reportgenerator.exporter为前缀。 property.output_dir 配置默认的报告输出路径。在命令行可以用-o选项来设置特定的路径覆盖该配置。 html.series_filter 用于过滤展示内容。如在user.properties添加如下配置：1jmeter.reportgenerator.exporter.html.series_filter=(^Login)(-success|-failure)? 则最后的报告只展示名为Login这个取样器的数据。该配置包含两部分，(-success|-failure)?是Transactions per second图表所依赖的配置。前面部分接受一个正则表达式用来过滤]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决JMeter运行一段时间卡死的问题]]></title>
    <url>%2F2017%2F12%2F20%2F%E8%A7%A3%E5%86%B3JMeter%E8%BF%90%E8%A1%8C%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%8D%A1%E6%AD%BB%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用jmeter进行压力测试时遇到一段时间后报内存溢出outfmenmory错误，导致jmeter卡死了，先尝试在jmeter.bat中增加了JVM_ARGS=”-Xmx2048m -Xms2048m -Xmn256m -XX:PermSize=128m -Xss256k”，但结果运行时间增加了，但最终还是报内存溢出，百度后按照网友的建议更改了如下设置后jmeter就没有再卡了： 1、windows环境下，修改jmeter.bat：12set HEAP=-Xms256m -Xmx256m set NEW=-XX:NewSize=128m -XX:MaxNewSize=128m 改为： 12set HEAP=-Xms256m -Xmx1024m set NEW=-XX:NewSize=128m -XX:MaxNewSize=512m 注意：JDK32位的电脑Xmx不能超过1500m，最大1378m.否则在启动Jmeter时会报错 2、linux环境下，修改jmeter.sh： 1java $JVM_ARGS -Xms1G -Xmx5G -XX:MaxPermSize=512m -Dapple.laf.useScreenMenuBar=true -jar `dirname $0`/ApacheJMeter.jar &quot;$@&quot; 3、如果查看JDK的位数 1234#java -version java version &quot;1.6.0_26&quot; Java(TM) SE Runtime Environment (build 1.6.0_26-b03) Java HotSpot(TM) Server VM (build 20.1-b02, mixed mode) 如果是64位的话,最后一行会显示64-Bit1234#java -version java version &quot;1.6.0_26&quot; Java(TM) SE Runtime Environment (build 1.6.0_26-b03) Java HotSpot(TM) 64-Bit Server VM (build 20.1-b02, mixed mode)]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter入门介绍]]></title>
    <url>%2F2017%2F12%2F20%2FJMeter%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[什么是JMeter Apache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java对象、数据库、FTP 服务器， 等等。JMeter可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。 Apache jmeter 可以用于对静态的和动态的资源（文件，Servlet，Perl脚本，java对象，数据库和查询，FTP服务器等等）的性能进行测试。它可以用于对服务器、网络或对象模拟繁重的负载来测试它们的强度或分析不同压力类型下的整体性能。你可以使用它做性能的图形分析或在大并发负载测试你的服务器/脚本/对象。 JMeter的特色 开源许可: Jmeter是完全免费的，并提供了源码可供自定义开发图形界面模式：提供了方便的图形界面来编辑和开发测试脚本平台无关：可以轻易在windows、linux、mac上运行多线程框架：通过线程组，能够轻易的设置不同测试的并发用户。图形测试结果：提供了图表、表格、树、文件等格式的结果显示。易于安装：jmeter不需要安装，下载解压即可用。高扩展性：jmeter支持用户自定义测试脚本，同样还提供了各种插件。多测试类型支持：支持性能测试、分布式测试、功能测试仿真模拟：支持多用户并发测试多协议支持：支持http、jdbc、ldap、soap、jms、ftp等等协议录制&amp;回放：支持用badboy或jmeter录制，不过笔者从来不用该模式，纯手工最佳。脚本测试:jmeter支持beanshell和selenium JMeter基本工作原理 JMeter完整的工作原理 详细介绍 前言 学习一种工具，首先得对其关键配置及目录等有一个基本的了解，这样能更方便的深入掌握该工具，下面我们就JMeter的目录及相关关键配置进行分析说明。 下载安装 1.安装主程序从Apache JMeter官网下最新版本：http://jmeter.apache.org/download_jmeter.cgi如图： 下载后直接解压即可1.安装插件管理从http://www.jmeter-plugins.org/install/Install/ 下载插件管理包，如图：将下载的包放至jmemter解压根目录的lib/ext下即可。 目录说明 bin 包含启动、配置等相关命令 docs 官方本地文档目录 extras 辅助库 lib 核心库，包含JMeter用到的各种基础库和插件 licenses 包含non-ASF软件的许可证 printable_docs 可打印版本文档目录 LICENSE JMeter许可说明 NOTICE JMeter简单信息说明 README.md JMeter官方基本介绍 下面我们重点看下bin目录，如图： 主要介绍bin目录下我们最关注几个文件： jmeter.properties JMeter核心配置文件，各种配置基本在这完成 log4j.conf JMeter日志配置管理 jmeter.log JMeter运行日志记录，什么输出信息、警告、报错都在这里进行了记录 jmeter.bat windows下jmeter启动文件 shutdown.cmd windows下jmeter关闭文件 stoptest.cmd windows下jmeter测试停止文件 jmeter-server.bat windows下jmeter服务器模式启动文件 注：每一个.cmd文件都对应一个.sh文件，.sh是linux下的对应功能的文件其他文件的功能就不一一说明了，同时其他目录这里也不再进行阐述，有兴趣的朋友可以自己深入看下。 关键配置说明 1.jmeter.properties配置说明主要包含以下几个方面的配置： SSL配置： 重点关注下面几个配置指定HTTPS协议层ttps.default.protocol=TLS指定SSL版本，实际应用中可能需要修改 https.default.protocol=SSLv3#设置启动的协议https.socket.protocols=SSLv2Hello SSLv3 TLSv1缓存控制，控制SSL是否可以在多个迭代中重用https.use.cached.ssl.context=true JMeter界面显示配置 这里就不对其界面显示控制进行说明了，一般情况下默认界面能满足大家的应用了。 JMeter测试项目自动备份配置 设置是否启用自动备份，默认是truejmeter.gui.action.save.backup_on_save=true设置自动备份目录，默认备份至JMeter根目录的backups下jmeter.gui.action.save.backup_directory=设置自动备份项目数，默认为最近10个jmeter.gui.action.save.keep_backup_max_count=10 远程主机配置 配置远程主机的IP，默认为本机。用逗号”,”可以设置多个远程主机remote_hosts=127.0.0.1多个远程主机指定示例如下,其中:后为端口remote_hosts=127.0.0.1:1099,127.0.0.1:1200,127.0.0.1:1300对于RMID的配置请直接看配置文件中的选项说明 日志管理配置 设置日志格式log_format_type=default设置日志输出级别log_level.jmeter=INFO设置junit日志输出级别log_level.jmeter.junit=DEBUG设置日志输出目标文件，默认为jmeter.loglog_file=jmeter.log 等等其他还有10多个配置大项（就不一一列举了） jmeter.bat关键配置修改 为了更优化的使用jmeter，需要对jmeter.bat中的一些配置根据当前机器的配置进行优化，这里进行关键配置项说明，大家根据自己的机器的配置来进行修改。jvm相关配置，大概在80行左右，找到这些配置，对其中的数值根据当前机器的硬件配置来修改。 1234set HEAP=-Xms2048m -Xmx2048mset NEW=-XX:NewSize=512m -XX:MaxNewSize=512msetSURVIVOR=-XX:SurvivorRatio=8 -XX:TargetSurvivorRatio=50%setTENURING=-XX:MaxTenuringThreshold=2if %current_minor% LEQ &quot;8&quot; ( rem IncreaseMaxPermSize if you use a lot of Javascript in your Test Plan : set PERM=-XXermSize=512m -XX:MaxPermSize=1024m) 启动jmeter 在bin目录下直接双击jmeter.bat即可启动后的界面如下： jmeter的核心组件构成jmeter必须掌握的入门组件 Thread Group Samplers Listeners Configuration Thread Group(线程组)线程组是一系列线程的集合，每一个线程代表着一个正在使用应用程序的用户。在jmeter中，每个线程意味着模拟一个真实用户向服务器发起请求。在jmeter中，线程组组件运行用户设置线程数量、初始化方式等等配置。例如，如果你设置线程数为100，那么jmeter将创建并模拟测试100个用户请求到服务器端。如下图所示： Samplers我们常用的jmeter测试有HTTP、FTP、JDBC协议，以及其他各种支持的协议。在上节我们已经知道线程组件用于模拟用户请求至服务器端。但还未讲解如何在线程组件中实现某种请求类型（比如如何发起HTTP请求？）。在本节中，我们将演示如何利用Samplers组件的元素来实现各类请求类型。我们先看一下在jmeter中Samplers组件已经实现了哪些协议的支持。如下图所示: jmeter重要组件 BeanShell Sampler 这个组件元素允许我们在jmeter中写Bean Shell脚本，写这个脚本有什么作用？意味着你可以完全的控制和实现自己的需要。灵活定制，自然也就有难度，你得有点脚本功底。参见图说明： 注：每一个Sampler都有自己独立的beanshell解析器，并且sampler只能在自己的线程中调用（意味着不可跨线程使用）。 FTP Request FTP Request元素提供了测试ftp服务器的能力，这个元素让我们能够去测试ftp的上传、下载功能。下面我们看一下ftp元素的基本配置说明： 注：我们经常在windows和linux直接通过ftp进行文件传输，建议勾选Use Binary Mode，避免编码问题。 HTTP Request HTTP Request提供了HTTP/HTTPS协议的测试支持能力。下面我们一起看看HTTP Request元素的基本配置说明，了解下基本的功能。 Java Request Java Request提供了测试java API的支持，但要注意要测试的javaAPI需要有对应的测试类，该测试类必须继承AbstractJavaSamplerClient。示例如下：待测类class Sum; -&gt; 生成sum.jar继承至AbstractJavaSamplerClient的测试类Class TestSum(AbstractJavaSamplerClient) -&gt; 生成testSum.jar注：一个java测试应该要实现以下几个方法，以便jmeter java sampler可以正确调用： 注意testSum.jar要能调用sum.jar。将上述sum.jar、testSum.jar拷贝至jmeter安装目录的lib/ext下。 jmeter配置java测试 Listeners(监听器) 在jmeter中Listeners提供了执行结果生成和显示能力的支持，提供了树形结构、表、图形和日志方式。 图形模式： 树模式： 表模式： 日志方式： Configuration Elements(即配置元件) 配置元件包含了Samplers下各种Sampler的默认配置设置，如果有配置默认配置，在Sampler下对应的sampler就会使用该默认配置。 下面进行逐一的说明。 CSV Data Set ConfigCSV Data Set Config主要用于读取csv格式的文件中数据，实现参数化。 HTTP Cookie ManagerHTTP Cookie Manager主要用于默认cookie管理。 HTTP Request DefaultsHTTP Request Defaults用于配置HTTPrequest的默认值，例如IP、端口等等都设置好默认值后，在后续HTTPrequest元素里就不需要重复设置，节省时间。 JMeter性能测试基本过程及示例 前言 性能测试是我们日常测试过程中，必须掌握的技能。通过进行性能测试，我们能分析服务端的整体性能、负载等，以便进一步评估我们的业务系统是否能满足当前运营生产及未来业务增长情况下如何进一步调整我们的服务配置方案。 jmeter为性能测试提供了一下特色： jmeter可以对测试静态资源（例如js、html等）以及动态资源（例如php、jsp、ajax等等）进行性能测试 jmeter可以挖掘出系统最大能处理的并发用户数 jmeter提供了一系列各种形式的性能分析报告 使用jmeter一般用于以下两种类型的性能测试 负载测试：通过测试系统在资源超负荷情况下的表现，以发现设计上的错误或验证系统的负载能力。压力测试：测试系统能承受的最大负载能力。目的在于发挖掘出目标服务系统可以处理的最大负载。 基本过程 对上图进行简要的说明 新增线程组创建测试线程组，并设置线程数量及线程初始化启动方式。 新增JMeter元组创建各种默认元组及测试元组，填入目标测试静态资源请求和动态资源请求参数及数据。 新增监听器创建各种形式的结果搜集元组，以便在运行过程及运行结束后搜集监控指标数据。 运行&amp;查看结果调试运行，分析指标数据，挖掘性能瓶颈、评估系统性能状态、 示例 下面我们以打开百度演示上述过程 新增线程组在jmeter的bin目录下双击jmeter.bat启动jmeter在左边操作栏中选择“测试计划”，右击新增一个线程组，如图所示： 初始化线程组相关信息，如图： 新增JMeter元组添加默认配置元素，添加如下默认配置，如图 各默认组件配置如图所示。HTTP Cache Manager HTTP Cookie管理器 HTTP请求默认值 添加HTTP Request元组在线程组上右击新增HTTP请求，如图： HTTP请求设置如图： 新增监听器在这里我们添加如下监听器，如图所示 运行&amp;查看结果如果启动运行jmeter，可以单击添加的监听器查看运行过程中的监控指标数据，也可以等运行结束后，再查看。 结果说明 下面我们就监听器所采集的结果图进行简要的说明：图形结果 察看结果树 用表格查看结果 聚合报告]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter压力测试-用户注册]]></title>
    <url>%2F2017%2F12%2F20%2FJMeter%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[需求：对用户注册行为进行压力测试，500w用户基础上，并发或连续时间进行测试，观察Linux服务器的负载情况和相应能力，测试完成后输出结果和报告。 1.下载JMeter下载版本3.1，新版本3.3过新的原因无法调用监控linux的插件，会报错地址：http://jmeter.apache.org/download_jmeter.cgi2.启动jmeter运行文件bin/jmeter.bat3.添加线程组在TestPlan节点上右键，添加 -&gt; Threads(Users) -&gt; 线程组4.脚本录制本次针对的是APP，所以使用jmeter自带的“HTTP代理服务器”如果是web版本，可以使用badboy进行录制导入（另起日志）第1：设置代理服务器端口第2：填写自己本地的IP第3：选择目标控制器，选择设定的线程组，对应采集到的HTTP协议会录入到线程组下第4：选择分组“每个组放入一个新的控制器”到手机上设置代理，然后操作注册流程，就可以在jmeter的线程组中看到对应的HTTP请求（整个流程）5.完善脚本及请求 关注脚本的录制情况，筛选掉一些无用的脚本，然后补充请求，关注request和response的请求值和响应值补充注册过程的加密原理，注册过程使用了RSA加密的算法，所以最后通过开发帮忙新增加密接口的方式返回加密后的秘密值，进而下方接口再调用该结果，实现注册加密的行为 添加 -&gt; 后置处理器 -&gt; 正则表达式提取器 引用名称：passwd正则表达式： .“result”:”(.+?)”.模板： $1$匹配数字：1 引用正则表达式把上一接口返回结果即定义的“passwd”作为下方接口请求的请求值，用json方式传参 6.数据参数化 注册号码需要进行参数化，所以通过jmeter自带的参数化方式 配置元件（CSV Data Set Config）实现具体jmeter的参数化方式另起日志说明 1）线程组 -&gt; 右键添加 -&gt; 配置元件 -&gt; CSV Data Set Config 2）调用本地设置好的数参 3）填写刚才定义好的变量 到此脚本的录制和编写完成，但是执行过程会出现异常，分别存在如下两个问题，需要在类似这种注册登录模式关注cookie、session和token的问题：注册过程需要保持同一个cookie（另起日志说明三者的区分）网络IP安全的限制 7.添加HTTP Cookie管理器 添加 -&gt; 配置元件 -&gt; HTTP Cookie管理器 8.网络IP的限制 由于服务器出于安全考虑会对同一IP地址做过滤，所以如果想要达到正常的压测效果，我们需要在发请求时伪造出不同的IP地址，本次过程直接开发帮忙设置，把IP同网段的限制取消，所以顺利达成 实际jmeter在IP上有IP欺骗的方式，具体另起日志介绍 9.配置实时监控Linux服务器的性能 另起日志说明如何安装以及使用，这里直接说明本次的使用 步骤： 1）打开linux监控目录下的serverAgent服务（服务器须事先开放端口4445）./startAgent.sh --udp-port 4445 --tcp-port 4445 2）jmeter添加监听器 线程组 -&gt; 添加 -&gt; 监听器（jp@gc - PerfMon Metrics Collector） 注：在配合测试场景过程，如果监测服务器性能，如连续监测1个小时的注册量，需要事先把“结果树”禁用掉，以免电脑响应处理不过来 10.执行测试场景案例 测试场景主要是针对线程组的参数进行配置 如：1）并发15个用户：线程数：15 in seconds：1 循环次数：12）半小时用户注册：线程数：1 in seconds：1 循环次数：永远 调度器：持续时间1800 11.查看测试结果 jmeter本身主要使用图形结果、聚合报告、查看结果树的方式linux的服务器监控则使用PerfMon Metrics Collector 根据jmeter3.0新特性，可直接生成HTML可视化报告，在压力测试结束后可生成 到jmeter bin目录下执行如下命令：1jmeter -n -t &lt;test JMX file&gt; -l &lt;test log file&gt; -e -o &lt;Path to output folder&gt; 样例：1jmeter -n -t 登录.jmx（具体脚本位置如E:\A\登录.jmx） -l testLogFile -e -o ./output 12.输出测试报告]]></content>
      <categories>
        <category>实际运用</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter使用插件进行服务器性能监控]]></title>
    <url>%2F2017%2F12%2F20%2FJMeter%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[性能测试时，关注点有两部分 1 服务本身：并发 响应时间 QPS2 服务器的资源使用情况：cpu memory I/O disk等 JMeter的plugins插件可以实现对运行服务器的监控，具体操作步骤如下： 说明：jmeter版本是3.1，3.3版本会出现不兼容的现象，导致插件在使用过程一直报错 一. 下载插件 1.访问网址http://jmeter-plugins.org/downloads/all/，下载三个文件。其中JMeterPlugins-Standard和JMeterPlugins-Extras是客户端的，ServerAgent是服务端的。 2.解压客户端的两个文件，进入其路径JMeterPlugins-Extras(Standard)-1.3.1\lib\ext，复制JmeterPlugins-Extras.jar(JmeterPlugins-Standard.jar)两个文件，放到JMeter客户端的lib/ext文件夹中,打开JMeter，可在监听器中看到Permon Metrics Collector，客户端配置成功。 3.将ServerAgent-2.2.1.jar上传到被测服务器，解压，进入目录，Windows环境，双击ServerAgent.bat启动；linux环境执 ServerAgent.sh启动，默认使用4444端口，出现如下情况即服务端成功： 注：这里需要先确认端口是否开放，如更换端口，使用如下的方式：./startAgent.sh –udp-port 4445 –tcp-port 4445 二. 测试使用情况 1.ServerAgent启动的校验 a. 在笔记本电脑打开telnet监听(控制面板-程序-打开或关闭Windows功能-telnet客户端勾选打开)b. cmd进入命令框，输入如下内容： 123telnet yourip 4444 #连接ServerAgenttest #发送test进行测试exit #退出，即断开连接 c. 观察server端是否有接收到消息，出现如下情况说明ServerAgent打开成功 1234567[root@bjdhj-120-215 ~]# /opt/soft/ServerAgent-2.2.1/startAgent.sh INFO 2016-02-18 10:52:51.749 [kg.apc.p] (): Binding UDP to 4444 INFO 2016-02-18 10:52:52.749 [kg.apc.p] (): Binding TCP to 4444 INFO 2016-02-18 10:52:52.754 [kg.apc.p] (): JP@GC Agent v2.2.0 started INFO 2016-02-18 10:56:55.198 [kg.apc.p] (): Accepting new TCP connection #成功连接 INFO 2016-02-18 10:57:00.830 [kg.apc.p] (): Yep, we received the &apos;test&apos; command #接收到test消息 INFO 2016-02-18 10:57:05.185 [kg.apc.p] (): Client disconnected #断开连接 2.Jmeter客户端的监听测试 a. 打开JMeter.bat，添加监听器Permon Metrics Collector-Add Row添加一行monitor配置(修改Host/IP为测试IP)-运行-观察server日志即chart图标内容。 ServerAgent端的日志： b. 运行jmeter时，成功连接然后立刻断开了，并没有获取我们想要的数据。猜想需要一个时间控制的元器件，使其能够获取一段时间的数据。 i 步骤：添加线程组(不添加发送请求)，设置循环次数为永远，点击运行。 结果：成功连接然后立刻断开 ii 添加线程组，设置循环次数为”用玄”；为线程组任意添加一个Sampler(并不设置参数)；添加一个PerfMon Metrics Collector监听器；点击运行。 结果：成功获取chart图，点击stop，即结束监听数据。全部配置图如下]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用JMeter的beanshell进行接口的加密处理]]></title>
    <url>%2F2017%2F12%2F20%2F%E5%88%A9%E7%94%A8JMeter%E7%9A%84beanshell%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近项目中在做http协议的接口测试，其中接口请求报文数据有个字段值需要用到加密后的签名，即出于网络传输过程中，对数据安全的考虑，要对请求的数据进行特定的处理（加密），再进行请求。 jmeter中的BeanShell，可以用来调用我们的工具类对数据进行处理，然后再进行相关的请求。自己刚好以前工作中使用过，于是就利用jmeter的beanshell来解决这个问题。 解决过程： 1、获取对应接口加密的工具类，并生成jar包 这个需要看测试人员是否具有代码查看的权限，如果没有权限，直接要求开发人员把该工具类的代码发过来即可。在eclipse中建个Java工程，把得到的工具类代码导进去。然后再导出成jar包。 2、把jar包放到${jmeter_home}\lib\ext下 将导出的jar包放到jmeter的lib\ext目录里。也可以不放进该目录，然后在jmeter的测试计划直接引用即可。 3、创建jmeter脚本 在jmeter中创建一个项目，添加一个httprequest，在这个请求里添加一个BeanShell PreProcessor。 在http请求中根据实际情况填写对应的数据： 在BeanShellPreProcessor中导入我们的jar包，BeanShell PreProcessor中的两个方法是我们最常用到的：vars.get(String paramStr)、vars.put(Stringkey,String value)，前一个是从jmeter中获得变量值，后一个是将数据存到jmeter变量中。 说明：mac是需要签名加密的字段，在BeanShell PreProcessor中主要是利用加密的工具类对报文进行加密，得到加密后的mac值，然后在接口报文中调用mac即可。 4、执行jmeter脚本 通过上述步骤脚本即可解决接口报文需要进行加密后才发送请求的测试处理。 未加密的请求结果： 利用beanshell加密后的请求结果： 至此，接口请求的加密处理已完成，不仅解决需通过代码生成请求报文的繁琐方法，还可以在此脚本的基础上，实现数据驱动的接口自动化测试]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义导入RobotFramework 关键字（库文件）]]></title>
    <url>%2F2017%2F12%2F20%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%BC%E5%85%A5RobotFramework%20%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E5%BA%93%E6%96%87%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[假设python的安装路径在D:/下面 第一步：在D:/python/Lib/site-packages 建立库文件文件夹 MyLibrary第二步：在MyLibrary 内建立 mytool.py 文件这个文件里面写自己需要穿件的关键字既方法，如下代码里面有一个比较两参数大小的方法，在Robot Framework 里面将以关键字的方式使用 1234567891011121314# coding=utf-8 class mytool(): def __init__(self): pass def test_a_b(self,a,b): ''' 比较两个参数的大小 ''' if a&gt;b: flag = False return flag else: flag = True return flag 第三步：在MyLibrary 内建立 init.py 文件如下文件内容模板，注意类名要与库文件夹名称一致 12345# coding=utf-8 from mytoolimport mytool version = '1.0' class MyLibrary(mytool): ROBOT_LIBRARY_SCOPE = 'GLOBAL' 注：ROBOT_LIBRARY_SCOPE = ‘GLOBAL’-&gt; 代表库是全局的version=’1.0’ -&gt; 版本定义 第四步：RIDE中导入库 库文件的导入： 如上图单击套件名称，右边的面板展示如下图点击 Library 后再弹窗内填写需要导入的库的名称。 若是做elenium web自动化测试，我们则需要导入selenium2library，以导入selenium2library为例，在弹窗内填写selenium2library点击OK按钮，RIDE则会自动去python目录下去搜寻库，若是不存在或者库有错，导入则不成功 查看错误原因：我们看到里面有一条：Print ‘FALLED’ ,library_name,err ,代表我们库名称错误，若是其他错误也可已在这里根据错误提示去对应解决。 第五步：自定义使用 导入完成之后，我们可以在Ride中键盘按F5到Search Keywords , source选择我们刚刚导入的库，我们会在面板中看见我们库中所有的方法的介绍 使用关键字 运行结果]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>RobotFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RobotFramework-Android自动化测试方案]]></title>
    <url>%2F2017%2F12%2F20%2FRobotFramework-Android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[随手借Android自动化测试-方案 方案版本号说明 版本 更新说明 更新时间 编写人 V1.0.0 新增 20171031 吴泽鹏 Android自动化测试模块 方案以如下几点作简要说明（点击可跳转对应说明）： 一、自动化测试的架构模式说明 二、如何使用该自动化平台 三、需线上配合提供的有效数据账号 四、账号关联表数据的定时性清理模式 五、测试结果的输出以及邮件通知说明 六、该自动化测试模式的不足 一、自动化测试的架构模式说明 1.自动化测试的优点 提高测试效率和降低测试成本 实现快速的回归测试，加快测试进度从而加快产品发布进度 更多的测试，提高测试覆盖率 可检测换服换包后线上环境的运行 2.为什么要做自动化测试框架 随手借项目在整体业务流程上趋于稳定，且为了达到节省人力时间、缩短bug发现周期、提高效率等目的。 3.希望达成的目标及效果 与Jenkins集成进行配合，点击构建任务能达到自动运行服务器脚本，自动执行自动化测试，测试结束输出结果到平台，并邮件通知测试结论，Jenkins平台有十次的构建记录和结果。可人工触发执行或者以每90分钟（时间待定，以实际脚本整体运行时长再做考量）自动取执行测试并返回结果。 4.自动化运行模式 架构模式：Jenkins+RobotFramework+Appium+Python 服务器：Windows7 I5-4300U 运行手机：三星Galaxy C7 Pro 5.实现思路 以模拟人的行为对真机进行自动化模拟行为操作，在自动化运行测试开始后，首先会验证进入的页面其主要页面元素是否具备，以及各个字段的正确性，再到验证功能点的正确性，组合各个功能点进行业务逻辑、业务流程的验证，最终确保Android应用APP包满足业务需求。 二、如何使用该自动化平台 1.打开Jenkins链接，执行构建任务 入口链接：http://10.A.A.A:8080/ 登录账号：账号：ssj 密码：AAAAAA 2.选择所要执行的自动化项目 3.点击左侧“立即构建”，等待执行结果 随手借_Android自动化检测 整体流程 -&gt;耗时20分钟左右 随手借_Android自动化检测 – 授权模块校验 -&gt;耗时10分钟左右 随手借_Android自动化检测 – 注册登录流程 -&gt;耗时8分钟左右 4.查看报告结果 进入项目首页，有最新一次构建的结果信息，信息展示执行的案例成功失败的情况，以及最新几次构建情况汇总图可供参考，具体的执行情况需要参考日志和报告。 进入“工作区”可查看响应的日志和报告，以及具体了解哪个模块执行失败注：具体报告内容的说明请详情后面第五点三、需线上配合提供的有效数据账号 1.账号1：用于注册 手机号：158AAAAAAAA 所属地区：深圳 运营商：中国移动 2.账号2：用于登录、基本资料提交 手机号：158BBBBBBBB 所属地区：深圳 运营商：中国移动 3.账号3：用于授权信息的校验 手机号：158CCCCCCCC 所属地区：深圳 运营商：中国移动 需具备数据能力：该账号已提交身份认证 4.账号4：用于借款流程的校验 手机号：158DDDDDDDD 所属地区：深圳 运营商：中国移动 需具备数据能力：该账号已提交基本资料项（身份认证、工作、通讯录）和其他资料项（社保正常、芝麻信用600），所提交资料正常，用户UseState状态正常为1，可正常进行借款操作 注：因本次自动化构建为线上环境，牵涉到数据及金额业务，所以需线上环境支持第四点“账号关联表数据的定时性清理模式”的实现 四、账号关联表数据的定时性清理模式 1.定时性清理模式 对四个账号操作过程中所产生的数据进行定时清理，时间暂拟定为每天整点自动清理。 即：0~24各整点，如：14:00开始清理 2.运行模式 四个账号在运营层面，涉及到该账号信息，运营人员无需进行审核处理，或实现管理后台无相关的信息 借款提交后产生的借款数据不会干扰或直接不产生，不会提交到亚联财 3.各账号关联表数据的处理说明 注：因涉及到线上业务，清理表数据需保持正常业务或实际不走正常录入表数据 五、测试结果的输出以及邮件通知说明 1.测试结果的输出说明 自动化测试结束后会在主页显示测试结果，对应进入“工作区”可详见报告和日志。 注：log.html为日志，report.html为报告 2.日志说明 日志中会详细显示本次自动化所涉及的模块，所运行的结果以及耗时等基本信息，且显示在哪个模块测试上验证失败，对应点击该模块可显示报错的位置以及相应不符合的测试点说明和截图。 3.报告说明 运行成功：报告呈现为绿色，运行失败：报告呈现为红色 报告Status状态：显示失败的运行数目，点击可展开该部分的信息 报告Documentation：显示本次运行的内容概要 报告Time：显示本次构建的起始时间和结束时间 报告Elapsed Time：本次构建的耗时 LOG File：点击跳转LOG日志 4.邮件通知说明 根据job项目的不同会触发响应响应的的邮件通知模式，具体以设置为准。 如：设置整体流程的自动化构建，构建完成后自动发送报告到邮箱设置授权资料项页面的自动化构建，构建失败才自动发送报告到邮箱 邮件通知的内容模式如下： 六、该自动化测试模式的不足 因该自动化搭建在本地PC笔记本上，整体架构及运行均由本地支撑，笔记本性能较差，所以存在运行卡顿，响应慢等问题，且考虑PC电脑的正常运作，电脑无法一直处于运行状态，故相应会进行shutdown处理，在自动化自动构建的任务上会出现误差。 原考虑用模拟器作为本次自动化的运行对象，但是也由于本地搭建的局限，会出现模拟器响应慢的情况，故本次以真机三星Galaxy C7 Pro作为自动化操作对象，但仍存在机子在性能上响应的问题，且所有的模拟行为均针对该机型，后续延展性不高。 如上为本次自动化测试方案综述，如有疑问和建议，请与我沟通联系。]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>RobotFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter+Badbody实现WEB脚本录制]]></title>
    <url>%2F2017%2F12%2F19%2FJMeter%2BBadbody%E5%AE%9E%E7%8E%B0WEB%E8%84%9A%E6%9C%AC%E5%BD%95%E5%88%B6%2F</url>
    <content type="text"><![CDATA[工具Badbody 下载地址：http://www.badboy.com.au/JMeter 下载地址：http://jmeter.apache.org/录制脚本打开Badbody地址栏中输入要录制的系统URL如下图录制的我们的系统输入密码和验证码登录这个验证码有个窍门，可以弄一个神码，只要是这个验证码的都不真实的校验验证码；也可以测试时暂时关闭验证码的功能。登录成功后随便点几个URL，可以在badbody左侧看到你点击的url，然后在Badbody的File-&gt;Export to JMeter导出一个jmeter的脚本打开JMeter 用Jmeter打开刚刚录制的脚本 这里有二个地方要处理一下1.打开HTTP Header Manager，如下图。原因是登录之后一般有session从badbody导出来的时候是没有这个session的，可能导致登录后操作其它的时候又跳转到登录了 打开登录的URL这个地方要选择跟随重定向 到此配置就完成了。直接运行应该可以看到结果了可以在Thread Group上添加一个察看结果树]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter设置IP欺骗]]></title>
    <url>%2F2017%2F12%2F19%2FJMeter%E8%AE%BE%E7%BD%AEIP%E6%AC%BA%E9%AA%97%2F</url>
    <content type="text"><![CDATA[准备工作： 1.window7一台，安装jdk1.6环境 2.下载最新jmeter 3. 3.使用IP欺骗功能必须得本地有多个可用IP，通常普通的PC机只有一个物理网卡，这就需要我们手工设置多IP绑定同一网卡： a、开始菜单 -&gt; 控制面板 -&gt; 网络共享中心 -&gt; 更改适配器设置 -&gt; 本地链接 b、右键本地链接 -&gt; 属性，选择Internet 协议版本4（双击打开窗口），如果是采用自动获取IP，得通过手工设置IP c、在属性窗口中选择高级按钮，选择IP设置，点击添加，输入新的IP地址(须要注意在局域网内不要有IP冲突，可以事先ping一下找没有使用的IP)，但子网掩码必须一致。 4.设置好多个IP后就可以开始使用jmeter的IP欺骗功能了，这里要注意的是到目前为止，基于http 请求必须使用httpClient4方可成功。首先我们把设置好的IP保存在cvs文件中方便我们导入到jmeter参数中： 5.在jmeter测试计划中添加配置元件 并配置IP参数 6.对http 请求进行调整 针对每个http都要设置一遍，jmeter在每个并发线程开始时从文件中取一个IP值；测试结果：结果可以从服务端通过日志观察变化，也可以通过jmeter 的察看结果树看到效果：]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter的参数化方法]]></title>
    <url>%2F2017%2F12%2F19%2FJMeter%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、利用函数助手获取参数值 选项-&gt;函数助手对话框（__CSVRead / __Random） 生成的函数字符串： ${__Random(,,)}第一个参数为随机数的下限，第二个参数为随机数的上限，第三个参数为储存随机数的变量名；${__CSVRead(,)}第一个参数是文件名(包含路径)，第二个参数是文件中的列（列数从0开始）； 参数化数据 __CSVRead：复制生成的参数化函数，打开登陆请求页面，在右则的参数化中找到我们要参数化的字段，这里对用户名和密码做参数化，第一列是用户名，列号为0；第二列是密码，列号为1；修改函数中对应的参数化字段列号就可以了，点击运行会调用相应路径下的参数文件 _Random函数是从某数据段随机读取数据替换参数，当需要添加多条数据记录且某些字段需要唯一性时使用。 二、利用配置元件（CSV Data Set Config） –最常用 1.选中线程组，点击右键，添加－配置元件－CSV Data Set Config Recycle on EOF：是否循环读入，因为CSV Data Set Config一次读入一行，分割后存入若干变量中交给一个线程，如果线程数超过 文本的记录行数，那么可以选择从头再次读入. Recycle on EOF与Stop thread on EOF结果的关联：当Recycle on EOF 选择true时，Stop thread on EOF选择true和false无任何意义，通俗的讲，在前面控制了不停的循环读取，后面再来让stop或run没有任何意义当Recycle on EOF 选择flase时，Stop thread on EOF选择true，线程4个，参数3个，那么只会请求3次当Recycle on EOF 选择flase时，Stop thread on EOF选择flase，线程4个，参数3个，那么会请求4次，但第4次没有参数可取，不让循环，所以第4次请求错误 2.填写刚才定义好的变量 三、用户自定义变量 一般定义测试系统的固定使用的变量，比如主机地址端口号，数据库账号密码等 选中线程组，点击右键，添加－配置元件-用户定义的变量 值可以直接输入，也可通过函数__CSVRead从文件中读取，还可以通过前缀加随机数和方法获取。 比如用户名为user_0到user100的用户，那么用户名可设置名user${__Random(0,100,)} 但是这种每次执行的多个线程所替换的参数一样，因为先获取到随机参数，再执行多个HTTP请求。]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Token/Cookie/Session的区别]]></title>
    <url>%2F2017%2F12%2F19%2FToken%2CCookie%2CSession%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Cookiecookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。 cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。 Sessionsession 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。 session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。 服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。 Tokentoken的意思是“令牌”，是用户身份的验证方式，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库 Cookie 和Session的区别1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、所以个人建议：将登陆信息等重要信息存放为SESSION其他信息如果需要保留，可以放在COOKIE中 Token 和Session 的区别session 和 oauth token并不矛盾，作为身份认证 token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加session来在服务器端保存一些状态 App通常用restful api跟server打交道。Rest是stateless的，也就是app不需要像browser那样用cookie来保存session,因此用session token来标示自己就够了，session/state由api server的逻辑处理。 如果你的后端不是stateless的rest api, 那么你可能需要在app里保存session.可以在app里嵌入webkit,用一个隐藏的browser来管理cookie session. Session 是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。所谓Session 认证只是简单的把User 信息存储到Session 里，因为SID 的不可预测性，暂且认为是安全的。这是一种认证手段。 而Token ，如果指的是OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对App 。其目的是让 某App有权利访问 某用户 的信息。这里的 Token是唯一的。不可以转移到其它 App上，也不可以转到其它 用户 上。 转过来说Session 。Session只提供一种简单的认证，即有此 SID，即认为有此 User的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方App。 所以简单来说，如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。 token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。 传统身份验证HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。 解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。 上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。 基于Token 的身份验证使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：1.客户端使用用户名跟密码请求登录2.服务端收到请求，去验证用户名与密码3.验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端4.客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里5.客户端每次向服务端请求资源的时候需要带着服务端签发的 Token6.服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 APP登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为token，存储到服务器中，并返回token到APP，以后APP请求时，凡是需要验证的地方都要带上该token，然后服务器端验证token，成功返回所需要的结果，失败返回错误信息，让他重新登录。其中服务器上token设置一个有效期，每次APP请求的时候都验证token和有效期。 问题： 1.服务器上的token存储到数据库中，每次查询会不会很费时。如果不存储到数据库，应该存储到哪里呢？ 2.客户端得到的token肯定要加密存储的，发送token的时候再解密。存储到数据库还是配置文件呢？ token是个易失数据，丢了无非让用户重新登录一下，所以如果你觉得普通的数据库表撑不住了，可以放到 MSSQL/MySQL 的内存表里（不过据说mysql的内存表性能提升有限），可以放到 Memcache里（讲真，这个是挺常见的策略），可以放到redis里（我做过这样的实现），甚至可以放到 OpenResty 的变量字典里（只要你有信心不爆内存）。 token是个凭条，不过它比门票温柔多了，门票丢了重新花钱买，token丢了重新操作下认证一个就可以了，因此token丢失的代价是可以忍受的——前提是你别丢太频繁，要是让用户隔三差五就认证一次那就损失用户体验了。 基于这个出发点，如果你认为用数据库来保持token查询时间太长，会成为你系统的瓶颈或者隐患，可以放在内存当中。比如memcached、redis，KV方式很适合你对token查询的需求。这个不会太占内存，比如你的token是32位字符串，要是你的用户量在百万级或者千万级，那才多少内存。要是数据量真的大到单机内存扛不住，或者觉得一宕机全丢风险大，只要这个token生成是足够均匀的，高低位切一下分到不同机器上就行，内存绝对不会是问题。 客户端方面这个除非你有一个非常安全的办法，比如操作系统提供的隐私数据存储，那token肯定会存在泄露的问题。比如我拿到你的手机，把你的token拷出来，在过期之前就都可以以你的身份在别的地方登录。 解决这个问题的一个简单办法 1、在存储的时候把token进行对称加密存储，用时解开。2、将请求URL、时间戳、token三者进行合并加盐签名，服务端校验有效性。这两种办法的出发点都是：窃取你存储的数据较为容易，而反汇编你的程序hack你的加密解密和签名算法是比较难的。然而其实说难也不难，所以终究是防君子不防小人的做法。话说加密存储一个你要是被人扒开客户端看也不会被喷明文存储……方法1它拿到存储的密文解不开、方法2它不知道你的签名算法和盐，两者可以结合食用。但是如果token被人拷走，他自然也能植入到自己的手机里面，那到时候他的手机也可以以你的身份来用着，这你就瞎了。于是可以提供一个让用户可以主动expire一个过去的token类似的机制，在被盗的时候能远程止损。 在网络层面上token明文传输的话会非常的危险，所以建议一定要使用HTTPS，并且把token放在post body里。]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决MySQL5.6+版本出现错误提示：Using a password on the command line...]]></title>
    <url>%2F2017%2F12%2F19%2F%E8%A7%A3%E5%86%B3MySQL5.6%2B%E7%89%88%E6%9C%AC%E5%87%BA%E7%8E%B0Warning%2F</url>
    <content type="text"><![CDATA[MySQL数据库的导出和访问的时候采用mysqldump命令，出现如下错误提示：“Warning: Using a password on the command line interface can be insecure.” 这个问题应该是在MySQL5.6+版本的时候就有出现，可能是为了确保数据库的安全性采用的保护机制。 汇总网上的解决方案如下：实际最后采用的方式是：降低版本至5.5完美解决 第一种方法：修改数据库配置文件 1、我们需要修改数据库配置文件，这个要看我们数据库的配置的，有些是在/etc/my.cnf，有些是/etc/my.conf 我们需要在[client]部分添加脚本： 123host=localhost user=数据库用户 password=&apos;数据库密码&apos; 这里参数要修改成我们自己的。 2、采用命令导出和导入数据库 其实在这个时候，我们如果采用”详解使用mysqldump命令备份还原MySQL数据用法整理”介绍的方法也是可以使用的，虽然依旧有错误提示，但是数据库还是可以导出的。您肯定和老左一样是追求细节的人，一点点问题都不能有，但我们可以用下面的命令导出和导入，就没有错误提示。 导出数据库1mysqldump --defaults-extra-file=/etc/my.cnf database &gt; database.sql 导入数据库1mysql --defaults-extra-file=/etc/my.cnf database &lt; database.sql 这里我们可以看到上面的命令和以前常用的快速导入和导入命令有所不同了，需要加载我们配置的MYSQL配置文件，这个红色部分要根据我们实际的路径修改。用这样的命令导出备份和导入是没有错误提示的。 第二种方法、利用mysql_config_editor 1、设置加密模式 1mysql_config_editor set --login-path=local --host=localhost --user=db_user --password 红色部分是需要修改成我们自己数据库用户名的，回车之后会提示我们输入数据库密码，我们照样输入。 2、执行备份 1mysqldump -u db_user -pInsecurePassword my_database | gzip &gt; backup.tar.gz 根据我们数据信息修改用户和用户名和数据库密码，执行备份，这里老左测试还是有错误提示，但数据库是可以备份的。]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL同时删除多表记录]]></title>
    <url>%2F2017%2F12%2F19%2FMySQL%E5%90%8C%E6%97%B6%E5%88%A0%E9%99%A4%E5%A4%9A%E8%A1%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[在Mysql4.0之后，mysql开始支持跨表delete。 Mysql可以在一个sql语句中同时删除多表记录，也可以根据多个表之间的关系来删除某一个表中的记录。假定我们有两张表：Product表和ProductPrice表。前者存在Product的基本信息，后者存在Product的价格。 第一种： 跨表删除的方式是不用join，在delete时指定用半角逗号分隔多个表来删除，如下sql语句：复制代码 代码如下： 1234DELETE p.*, pp.* FROM product p, productPrice pp WHERE p.productId = pp.productId AND p.created &lt; '2004-01-01' 第二种： 跨表删除的方式是使用inner join在join中指定两表之间的关联关系，如下sql语句：复制代码 代码如下:1234DELETE p.*, pp.* FROM product p INNER JOIN productPrice pp WHERE p.created &lt; '2004-01-01' 注意：跨表删除不必删除所有表的数据，上面的sql语句表会同时删除Product和ProductPrice两张表中的数据，但是你可以指定 DELETE product.* 从而只删除product表中的记录，而不处理ProductPrice表中的记录。 跨表删除也可以使用left join 例如我们要删除所有在ProductPrice表中没有记录的Product表记录。如下sql语句：复制代码 代码如下:123DELETE p.* FROM product p LEFT JOIN productPrice pp ON p.productId = pp.productId WHERE pp.productId is null]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter如何将上一个请求的结果作为下一个请求的参数（使用正则提取器）]]></title>
    <url>%2F2017%2F12%2F19%2FJMeter%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%8A%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E7%BB%93%E6%9E%9C%E4%BD%9C%E4%B8%BA%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E6%8F%90%E5%8F%96%E5%99%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在压力测试的时候，经常要将几个流程串联起来才能将程序测试通过。如：我现在用户首先要登录，获得我登录的凭证（tokenId），之后我的请求其他的资源的时候需要带上这个凭证。才能识别你是否是合法的用户。 创建一个线程租 创建一个获取凭证的请求 创建后置处理器JMeter GUI视图中右击该采样器 打开右键菜单 -&gt; 添加 -&gt; 后置处理器 -&gt; 正则表达式提取器，打开”正则表达式提取器”会话页面并编辑其内容如下： 后置处理器是当这个请求返回后要做得事情，我这里是要从返回的内容中将我们要的tokenId获取出来。这里使用“正则表达式提取器”，用正则表达式，将我们要的内容获取出来。 正则表达式提取器配置 引用名称是下个请求将要引用到的变量名； 正则表达式是提取你想要内容的正则表达式，小括号()表示提取，也就是说对于你想要提取的内容需要用它括起来； 模板是使用提取到的第几个值。因为可能有多个值匹配，所以要使用模板。从 1 开始匹配，依次类推。这里只有一个，所以填写 $1$ 即可； 匹配数字表示如何取值。0 代表随机取值，1 代表全部取值。这里只有一个，填 1 即可； 缺省值表示参数没有取到值的话，默认给它的值。一般不填。 这个请求返回的数据如下：1&#123;&quot;message&quot;:&quot;success&quot;,&quot;statusCode&quot;:200,&quot;registerDay&quot;:&quot;20&quot;,&quot;tokenId&quot;:&quot;bf1017bc1bb495ae31764b306a3422885f5&quot;&#125; 我们现在要获取的是上面这个json字符串中tokenId的值，即bf1017bc1bb495ae31764b306a3422885f5 添加下一个请求在这个请求中，我们要将上面的tokenId作为一个参数一并发送。添加一个http请求（线程租右键——》添加——》Sampler——》HTTP请求 添加查看结果树 执行后通过”查看结果树“查询]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python运算符]]></title>
    <url>%2F2017%2F12%2F12%2FPython%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Python语言支持的运算符 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 Python算术运算符 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 30 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 - x除以y b / a 输出结果 2 % 取模 - 返回除法的余数 b % a 输出结果 0 ** 幂 - 返回x的y次幂 a**b 为10的20次方，输出结果 100000000000000000000 // 取整除 - 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 实例： 1234567891011121314151617181920212223242526272829303132#!/usr/bin/python # -*- coding: UTF-8 -*- a = 21 b = 10 c = 0 c = a + b print "1 - c 的值为：", c c = a - b print "2 - c 的值为：", c c = a * b print "3 - c 的值为：", c c = a / b print "4 - c 的值为：", c c = a % b print "5 - c 的值为：", c # 修改变量 a 、b 、c a = 2 b = 3 c = a**b print "6 - c 的值为：", c a = 10 b = 5 c = a//b print "7 - c 的值为：", c 以上实例输出结果： 12345671 - c 的值为： 31 2 - c 的值为： 11 3 - c 的值为： 210 4 - c 的值为： 2 5 - c 的值为： 1 6 - c 的值为： 8 7 - c 的值为： 2 注意：Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可123456&gt;&gt;&gt; 1/2 0 &gt;&gt;&gt; 1.0/2 0.5 &gt;&gt;&gt; 1/float(2) 0.5 Python赋值运算符 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a //= 取整除赋值运算符 c //= a 等效于 c = c // a Python逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值 (a and b) 返回 20 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值 (a or b) 返回 10 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True not(a and b) 返回 False 实例： 1234567891011121314151617181920212223242526272829303132#!/usr/bin/python # -*- coding: UTF-8 -*- a = 10 b = 20 if ( a and b ): print "1 - 变量 a 和 b 都为 true" else: print "1 - 变量 a 和 b 有一个不为 true" if ( a or b ): print "2 - 变量 a 和 b 都为 true，或其中一个变量为 true" else: print "2 - 变量 a 和 b 都不为 true" # 修改变量 a 的值 a = 0 if ( a and b ): print "3 - 变量 a 和 b 都为 true" else: print "3 - 变量 a 和 b 有一个不为 true" if ( a or b ): print "4 - 变量 a 和 b 都为 true，或其中一个变量为 true" else: print "4 - 变量 a 和 b 都不为 true" if not( a and b ): print "5 - 变量 a 和 b 都为 false，或其中一个变量为 false" else: print "5 - 变量 a 和 b 都为 true" 以上实例输出结果：123451 - 变量 a 和 b 都为 true 2 - 变量 a 和 b 都为 true，或其中一个变量为 true 3 - 变量 a 和 b 有一个不为 true 4 - 变量 a 和 b 都为 true，或其中一个变量为 true 5 - 变量 a 和 b 都为 false，或其中一个变量为 false Python成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False x 在 y 序列中 , 如果 x 在 y 序列中返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True 实例：1234567891011121314151617181920212223#!/usr/bin/python # -*- coding: UTF-8 -*- a = 10 b = 20 list = [1, 2, 3, 4, 5 ]; if ( a in list ): print "1 - 变量 a 在给定的列表中 list 中" else: print "1 - 变量 a 不在给定的列表中 list 中" if ( b not in list ): print "2 - 变量 b 不在给定的列表中 list 中" else: print "2 - 变量 b 在给定的列表中 list 中" # 修改变量 a 的值 a = 2 if ( a in list ): print "3 - 变量 a 在给定的列表中 list 中" else: print "3 - 变量 a 不在给定的列表中 list 中" 以上实例输出结果： 1231 - 变量 a 不在给定的列表中 list 中 2 - 变量 b 不在给定的列表中 list 中 3 - 变量 a 在给定的列表中 list 中 Python身份运算符身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False 实例： 123456789101112131415161718192021222324252627#!/usr/bin/python # -*- coding: UTF-8 -*- a = 20 b = 20 if ( a is b ): print "1 - a 和 b 有相同的标识" else: print "1 - a 和 b 没有相同的标识" if ( a is not b ): print "2 - a 和 b 没有相同的标识" else: print "2 - a 和 b 有相同的标识" # 修改变量 b 的值 b = 30 if ( a is b ): print "3 - a 和 b 有相同的标识" else: print "3 - a 和 b 没有相同的标识" if ( a is not b ): print "4 - a 和 b 没有相同的标识" else: print "4 - a 和 b 有相同的标识" 以上实例输出结果： 12341 - a 和 b 有相同的标识 2 - a 和 b 有相同的标识 3 - a 和 b 没有相同的标识 4 - a 和 b 没有相同的标识 is 与 == 区别：is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 &gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; b = a &gt;&gt;&gt; b is a True &gt;&gt;&gt; b == a True &gt;&gt;&gt; b = a[:] &gt;&gt;&gt; b is a False &gt;&gt;&gt; b == a True Python运算符优先级以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python变量类型]]></title>
    <url>%2F2017%2F12%2F05%2FPython%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[变量存储在内存中的值。这就意味着在创建变量时会在内存中开辟一个空间。基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。 变量赋值Python 中的变量赋值不需要类型声明。每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。等号（=）用来给变量赋值。等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如： 12345678910#!/usr/bin/env python # -*- coding: UTF-8 -*- counter = 100 # 赋值整型变量 miles = 1000.0 # 浮点型 name = "John" # 字符串 print counter print miles print name 以上实例中，100，1000.0和”John”分别赋值给counter，miles，name变量。执行以上程序会输出如下结果：123100 1000.0 John 多个变量赋值Python允许你同时为多个变量赋值。例如：a = b = c = 1以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。 您也可以为多个对象指定多个变量。例如：a, b, c = 1, 2, &quot;john&quot;以上实例，两个整型对象1和2的分配给变量 a 和 b，字符串对象 “john” 分配给变量 c。 标准数据类型在内存中存储的数据可以有多种类型。例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。 Python 定义了一些标准类型，用于存储各种类型的数据。 Python有五个标准的数据类型： Numbers（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） Python数字数字数据类型用于存储数值。他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。 当你指定一个值时，Number对象就会被创建：var1 = 1var2 = 10 您也可以使用del语句删除一些对象的引用 del语句的语法是： 1del var1[,var2[,var3[....,varN]]]] 您可以通过使用del语句删除单个或多个对象的引用。例如： del vardel var_a, var_b Python支持四种不同的数字类型： int（有符号整型） long（长整型[也可以代表八进制和十六进制]） float（浮点型） complex（复数） 实例：一些数值类型的实例 int long float complex 10 51924361L 0.0 3.14j 100 -0x19323L 15.20 45.j -786 0122L -21.9 9.322e-36j 080 0xDEFABCECBDAECBFBAEl 32.3e+18 .876j -0490 535633629843L -90 .-.6545+0J -0x260 -052318172735L -32.54e100 3e+26J 0x69 -4721885298529L 70.2E-12 4.53e-7j 长整型也可以使用小写 l，但是还是建议您使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。 Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。 Python字符串字符串或串(String)是由数字、字母、下划线组成的一串字符。一般记为： s=&quot;a1a2···an&quot;(n&gt;=0)它是编程语言中表示文本的数据类型。 python的字串列表有2种取值顺序:从左到右索引默认0开始的，最大范围是字符串长度少1从右到左索引默认-1开始的，最大范围是字符串开头 如果你要实现从字符串中获取一段子字符串的话，可以使用变量 [头下标:尾下标]，就可以截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。 比如: s = ‘ilovepython’s[1:5]的结果是love。当使用以冒号分隔的字符串，python返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。 上面的结果包含了s[1]的值l，而取到的最大范围不包括上边界，就是s[5]的值p。加号（+）是字符串连接运算符，星号（*）是重复操作。如下实例： 1234567891011#!/usr/bin/env python # -*- coding: UTF-8 -*- str = 'Hello World!' print str # 输出完整字符串 print str[0] # 输出字符串中的第一个字符 print str[2:5] # 输出字符串中第三个至第五个之间的字符串 print str[2:] # 输出从第三个字符开始的字符串 print str * 2 # 输出字符串两次 print str + "TEST" # 输出连接的字符串 以上实例输出结果： 123456Hello World! H llo llo World! Hello World!Hello World! Hello World!TEST Python元组元组是另一个数据类型，类似于List（列表）。元组用”()”标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 实例： 123456789101112#!/usr/bin/env python # -*- coding: UTF-8 -*- tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 ) tinytuple = (123, 'john') print tuple # 输出完整元组 print tuple[0] # 输出元组的第一个元素 print tuple[1:3] # 输出第二个至第三个的元素 print tuple[2:] # 输出从第三个开始至列表末尾的所有元素 print tinytuple * 2 # 输出元组两次 print tuple + tinytuple # 打印组合的元组 以上实例输出结果： 123456('runoob', 786, 2.23, 'john', 70.2) runoob (786, 2.23) (2.23, 'john', 70.2) (123, 'john', 123, 'john') ('runoob', 786, 2.23, 'john', 70.2, 123, 'john') 以下是元组无效的，因为元组是不允许更新的。而列表是允许更新的： 实例： 1234567#!/usr/bin/python # -*- coding: UTF-8 -*- tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 ) list = [ 'runoob', 786 , 2.23, 'john', 70.2 ] tuple[2] = 1000 # 元组中是非法应用 list[2] = 1000 # 列表中是合法应用 Python 字典字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用”{ }”标识。字典由索引(key)和它对应的值value组成。 实例： 123456789101112131415#!/usr/bin/python # -*- coding: UTF-8 -*- dict = &#123;&#125; dict['one'] = "This is one" dict[2] = "This is two" tinydict = &#123;'name': 'john','code':6734, 'dept': 'sales'&#125; print dict['one'] # 输出键为'one' 的值 print dict[2] # 输出键为 2 的值 print tinydict # 输出完整的字典 print tinydict.keys() # 输出所有键 print tinydict.values() # 输出所有值 输出结果为：12345This is one This is two &#123;'dept': 'sales', 'code': 6734, 'name': 'john'&#125; ['dept', 'code', 'name'] ['sales', 6734, 'john'] Python数据类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。 函数 描述 int(x [,base]) 将x转换为一个整数 long(x [,base] ) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批处理实现选项执行SQL清楚测试数据]]></title>
    <url>%2F2017%2F12%2F04%2F%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E9%80%89%E9%A1%B9%E6%89%A7%E8%A1%8CSQL%E6%B8%85%E6%A5%9A%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[需求：Android自动化每次构建均会产生数据，希望循环使用脚本数据，所以做清除数据库表内容,希望节省时间，实现点击直接运行清空表数据，考虑是否可使用批处理。 第一：考虑可否单个场景SQL语句运用如：仅清空注册表关联信息 此处学习了sql语句的场景：多表含有一个共同字段，希望通过这个字段，清除所有相关的表格数据根据文献，结合写出如下执行语句，可生效删除。 第一个场景：清空注册相关的所有形成表数据： DELETE a.\*, b.\* FROM \`user_base_info\` a, \`user_account_info\` b WHERE a.\`ID\` = b.\`ID\` AND a.\`Phone\` = &apos;13631166220&apos; 第二个场景：清空资料提交三项的数据并恢复user_base_info表的基本资料项的state状态 DELETE b.\*, c.\*, d.\*, e.\* FROM \`user_base_info\` a,\`user_identity_info\` b,\`user_work_info\` c,\`user_contacts_info\` d, \`user_app_contacts\` e WHERE a.\`ID\` = b.\`UserID\` AND **a.\`ID\` = c.\`UserID\` AND a.\`ID\` = d.\`UserID\` AND a.\`ID\` = e.\`UserID\` AND a.\`Phone\` = &apos;13631166210&apos;; 恢复表数据执行语句如下： UPDATE \`user_base_info\` AS a SET a.\`Auth_Identity\` = &apos;1&apos;, a.\`Auth_Work\` = &apos;1&apos;, a.\`Auth_Contacts\` = &apos;1&apos; WHERE a.\`Phone\` = &apos;13631166210&apos; 第二：考虑这些语句执行如何结合bat批处理进行执行期望：点击批处理即完成数据的清理，无需再过多操作 想法是直接把sql直接放进格式为.bat的文本中直接执行，现象：报“不是内部或外部命令，也不是可运行的程序” 所以怀疑本地未部署sql的环境及环境变量，故进行检查并进行部署 环境部署： Mysql下载地址：https://dev.mysql.com/downloads/file/?id=473607版本号：mysql-5.5.58-winx64.msi 注：这里后面根据实践得出，需安装版本5.5，因为5.6以上加大了安全方面的校验，导致链接数据库过程会一直弹出“Warning:Using a password on the command line interface can be insecure.”这里存在其他的解决方案，但是研究无果，索性直接换成低版本，完美解决哈哈。 Mysql环境变量配置：对应安装目录到bin目录，对应添加到path环境中去 安装配置完成后，执行sql连接数据库： mysql -h 主机地址 -u 用户名 -p用户密码 注：-p后边无空格 连接后执行sql的方式： 1.后面直接带 -e”sql1;sql2;sql3”，如本次的执行sql mysql -h 120.24.67.aa -u ss -psauda2015 -e&quot;use test;DELETE b.\*, c.\*, d.\*, e.\* FROM \`user_base_info\` a, \`user_identity_info\` b, \`user_work_info\` c, \`user_contacts_info\` d, \`user_app_contacts\` e WHERE a.\`ID\` = b.\`UserID\` AND a.\`ID\` = c.\`UserID\` AND a.\`ID\` = d.\`UserID\` AND a.\`ID\` = e.\`UserID\` AND a.\`Phone\` = &apos;13631166210&apos;;UPDATE \`user_base_info\` AS a SET a.\`Auth_Identity\` = &apos;1&apos;, a.\`Auth_Work\` = &apos;1&apos;, a.\`Auth_Contacts\` = &apos;1&apos; WHERE a.\`Phone\` = &apos;13631166210&apos;&quot; 注：该sql封装成批处理文件，这条语句不能间隔分行，不然会执行报错 2.在连接数据库后带 &lt; “sql文件目录” 1mysql -h 120.24.67.aa -u ss -psaudae2015 &lt; &quot;e:\\aa.sql&quot; 第三：实现一个批处理调用这几个分类批处理，做成选项执行的效果参考了一篇启动Mysql和关闭Mysql的选项文章，对应再根据自己理解进行调整实现，批处理的形式以另一篇日志输出。 参考的例子文献如下：Windows下使用批处理实现启动关闭mysql 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091cls @echo off :设置窗口字体颜色color 0a :设置窗口标题 TITLE MySQL管理程序 call :checkAdmin goto menu:菜单 :menu cls echo. echo.=-=-=-=-请选择您要对MySQL的操作-=-=-=-=-echo. echo.1: 启动MySQLecho. echo.2: 关闭MySQL echo. echo.3: 重启MySQL echo. echo.4: 退 出 echo. echo.=-=-=-=-请输入您要选择的项目序号↓-=-=-=- set /p id= if "%id%"=="1" goto startupif "%id%"=="2" goto shutdown if "%id%"=="3" goto reboot if "%id%"=="4" exit pause :启动 :startup echo. call :checkMySQL 1echo.启动MySQL......net start "MySQL" echo.启动MySQL成功！ pause goto menu :停止 :shutdownecho. call :checkMySQL 2echo.关闭MySQL......net stop "MySQL" echo.关闭MySQL成功！ pause goto menu :重启:reboot echo. call :checkMySQL 2 echo.关闭MySQL...... net stop "MySQL"echo.关闭MySQL成功！ goto startup goto menu:退出 :gooutpausegoto menu:检查MySQL进程是否存在:checkMySQLset /a count=0 for /f "tokens=1 delims= " %%i in ('tasklist /nh \^\| find /i "MySQL"') do (set/a count+=1) if %count% neq 0 if "%1" equ "1" ( echo 警告：MySQL已启动 goto goout)if %count% equ 0 if "%1" equ "2" ( echo 警告：MySQL未启动 goto goout):检查是否是以管理员身份运行 :checkAdminecho test am i admin? \%SystemRoot%\\System32\\test.sunhao if not exist %SystemRoot%\\System32\\test.sunhao ( echo 警告：请以管理员身份运行！ pause exit )del %SystemRoot%\\System32\\test.sunhao ##第四：实现用批处理去执行清理自动化形成的数据 脚本代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546cls @echo off :设置窗口字体颜色color 0a :设置窗口标题TITLE 随手借Android自动化数据清理工具 goto menu:菜单 :menucls echo. echo.=-=-=-=-=-=-=-=项目序号说明=-=-=-=-=-=-=- echo.echo.1: 清理注册信息echo. echo.2: 清理基本资料信息echo. echo.3: 退出程序 echo.echo.=-=-=-=-请输入您要选择的项目序号↓-=-=-=- set /p id= if "%id%"=="1" goto registerif "%id%"=="2" goto information if "%id%"=="3" exit pause:清理注册信息:registercall .\\sql\\register_clear.batecho.清理完成！pause goto menu :清理基本资料信息:information echo.清理数据中...... call .\\sql\\information_clear.bat echo.清理完成！pause goto menu:退出程序 :gooutpause goto menu 注：脚本的命令定义另起日志说明批处理 样式：]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批处理随电脑开启自动后台运行]]></title>
    <url>%2F2017%2F12%2F04%2F%E6%89%B9%E5%A4%84%E7%90%86%E9%9A%8F%E7%94%B5%E8%84%91%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[需求 自动化部署了jenkins，希望本地服务器即windows7启动时自动运行jenkins，并在后台直接运行，避免不小心关闭导致自动化构建失败 配置后台运行 方法一：bat里有隐藏窗口的命令，很简单，只需要在代码头部加一段代码就可以了。 12345@echo off if "%1" == "h" goto begin mshta vbscript:createobject("wscript.shell").run("%~nx0 h",0)(window.close)&amp;&amp;exit :begin ::下面是你自己的代码。 方法二：在你批处理的相同目录下新建一个记事本，里面输入： 12DIM objShell set objShell=wscript.createObject("wscript.shell") iReturn=objShell.Run("cmd.exe /C c:\1.bat", 0, TRUE) （其中c:\1.bat为你自己的批处理名字，自己改） 然后把这个记事本保存为后缀名为.vbe的文件，到时候你只要运行这个vbe文件就达到目的了！ 可以写的简单点： 12Set ws = CreateObject("Wscript.Shell") ws.run "cmd /c c:\1.bat",0 或者： 1CreateObject("WScript.Shell").Run "cmd /c c:\1.bat",0 （这种写法很多杀软报毒， 需要替换参数0） 最后那个0是指窗口参数，用法为： 0 隐藏窗口并激活另一窗口。 1 激活并显示一个窗口。若窗口是最小化或最大化，则恢复到其原来的大小和位置。 2 激活窗口并以最小化显示该窗口。 3 激活窗口并以最大化显示该窗口。 4 按窗口最近的大小和位置显示。活动窗口保持活动。 5 以当前大小和位置激活并显示窗口。 6 最小化指定窗口并激活按 Z 序排序的下一个顶层窗口。 7 最小化显示窗口。活动窗口保持活动。 8 以当前状态显示窗口。活动窗口保持活动。 9 激活并显示窗口。若窗口是最小化或最大化，则恢复到原来的大小和位置。在还原应用程序的最小化窗口时，应指定该标志。 实际运用 1.新建vbs文件，如jenkins.vbs 内容如下： 12Set ws = CreateObject("Wscript.Shell") ws.run "cmd /c E:\RobotFramework\Android_automation\jenkins.bat", vbhide 2.配置jenkins.bat的启动内容（jenkins.bat） 内容如下： 1java -Dhudson.model.DirectoryBrowserSupport.CSP= -jar D:\jenkins\jenkins.war 3.直接运行jenkins.vbs文件就可以直接在后台进行运行了，具体可查看进程 Windows7开机自动运行批处理文件 –&gt; 开始 -&gt; 所有程序 -&gt; 启动 -&gt; 右击打开启动文件夹 -&gt; 将批处理文件放进去即可]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常用语句命令]]></title>
    <url>%2F2017%2F12%2F04%2FMySQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[连接MySQL格式： 1mysql -h 主机地址 -u 用户名 -p 用户密码 连接本机上的MYSQL首先在打开DOS窗口，然后进入目录 mysql bin，再键入命令 mysql -uroot -p，回车后提示你输密码，如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是：mysql&gt; 连接到远程主机上的MYSQL假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令： 1mysql -h 110.110.110.110 -uroot -p abcd123 （注:u与root可以不用加空格，其它也一样） 退出MYSQL命令： exit （回车） 修改密码格式：1mysqladmin -u用户名 -p旧密码 password 新密码 1、例1：给root加个密码ab12。首先在DOS下进入目录mysql bin，然后键入以下命令： 1mysqladmin -uroot -password ab12 注：因为开始时root没有密码，所以-p旧密码一项就可以省略了。 2、例2：再将root的密码改为djg345。 1mysqladmin -uroot -pab12 password djg345 增加新用户（注意：和上面不同，下面的因为是MySQL环境中的命令，所以后面都带一个分号作为命令结束符） 格式： 1grant select on 数据库.* to 用户名@登录主机 identified by \"密码\" 例1、增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用以root用户连入MySQL，然后键入以下命令： 12grant select,insert,update, delete on *.* to test2@localhost identified by \"abc\"; 如果你不想test2有密码，可以再打一个命令将密码消掉。 12grant select,insert,update,delete on mydb .* to test2@localhost identified by \"\"; 在上面讲了登录、增加用户、密码更改等问题。下面我们来看看MySQL中有关数据库方面的操作。注意：你必须首先登录到MySQL中，以下操作都是在MySQL的提示符下进行的，而且每个命令以分号结束。 MySQL其他常用命令create database name; 创建数据库use databasename; 选择数据库drop database name 直接删除数据库，不提醒show tables; 显示表describe tablename; 表的详细描述select中加上distinct去除重复字段mysqladmin drop database name 删除数据库前，有提示 在mysql中select top用法和ms sqlserver有所区别。若在mysql中实现select top功能得用：select * from tablename limit M,N, 这里M表示从（M+1）条记录开始，N表示返回的记录条数 显示当前mysql版本和当前日期select version(),current_date; 修改mysql中root的密码shell&gt;mysql -u root -pmysql&gt; update user set password=password(”xueok654123″) where user=’root’;mysql&gt; flush privileges //刷新数据库mysql&gt;use dbname； 打开数据库：mysql&gt;show databases; 显示所有数据库mysql&gt;show tables; 显示数据库mysql中所有的表：先use mysql；然后mysql&gt;describe user; 显示表mysql数据库中user表的列信息）； grant创建一个可以从任何地方连接服务器的一个完全的超级用户，但是必须使用一个口令something做这个 mysql&gt; grant all privileges on . to user@localhost identified by ’something’ with 增加新用户格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码” GRANT ALL PRIVILEGES ON . TO monty@localhost IDENTIFIED BY ’something’ WITHGRANT OPTION;GRANT ALL PRIVILEGES ON . TO monty@”%” IDENTIFIED BY ’something’ WITH GRANTOPTION; 删除授权mysql&gt; revoke all privileges on *.* from root\@”%”;mysql&gt; delete from user where user=”root” and host=”%”;mysql&gt; flush privileges; 创建一个用户custom在特定客户端it363.com登录，可访问特定数据库fangchandb mysql &gt;grant select, insert, update, delete, create,drop on fangchandb.* tocustom@ it363.com identified by ‘ passwd’ 重命名表mysql &gt; alter table t1 rename t2; mysqldump 备份数据库shell&gt; mysqldump -h host -u root -p dbname &gt;dbname_backup.sql 恢复数据库shell&gt; mysqladmin -h myhost -u root -p create dbnameshell&gt; mysqldump -h host -u root -p dbname &lt; dbname_backup.sql 如果只想卸出建表指令，则命令如下：shell&gt; mysqladmin -u root -p -d databasename &gt; a.sql 如果只想卸出插入数据的sql命令，而不需要建表命令，则命令如下：shell&gt; mysqladmin -u root -p -t databasename &gt; a.sql 那么如果我只想要数据，而不想要什么sql命令时，应该如何操作呢？mysqldump -T./ phptest driver 其中，只有指定了-T参数才可以卸出纯文本文件，表示卸出数据的目录，./表示当前目录，即与mysqldump同一目录。如果不指定driver表，则将卸出整个数据库的数据。每个表会生成两个文件，一个为.sql文件，包含建表执行。另一个为.txt文件，只包含数据，且没有sql指令。 测试实例1)创建数据库staffermysql&gt; create database staffer 2)创建表staffer,department,position,depart_pos 1234567891011121314151617181920212223create table department ( id int not null auto_increment, name varchar(20) not null default '系统部', #设定默认值 description varchar(100), primary key PK_department (id) #设定主键 ); create table depart_pos ( department_id int not null, position_id int not null, primary key PK_depart_pos (department_id,position_id) #设定复和主键 ); create table staffer ( id int not null auto_increment primary key, #设定主键 name varchar(20) not null default '无名氏', #设定默认值 department_id int not null, position_id int not null, unique (department_id,position_id) #设定唯一值 ); 3)删除mysql&gt; drop table depart_pos; 4)修改结构alter命令mysql&gt; 123456789101112131415161718192021#表position增加列test alter table position add(test char(10)); #表position修改列test alter table position modify test char(20) not null; #表position修改列test默认值alter table position alter test set default 'system'; #表position去掉test默认值 alter table position alter test drop default; #表position去掉列test alter table position drop column test; #表depart_pos删除主键 alter table depart_pos drop primary key; #表depart_pos增加主键 alter table depart_pos add primary key PK_depart_pos (department_id,position_id); 5)操作数据insert命令 1234567891011121314151617181920212223#插入表department insert into department(name,description) values('系统部','系统部'); insert into department(name,description) values('公关部','公关部'); insert into department(name,description) values('客服部','客服部'); insert into department(name,description) values('财务部','财务部'); insert into department(name,description) values('测试部','测试部'); #插入表s_positioninsert into s_position(name,description) values('总监','总监'); insert into s_position(name,description) values('经理','经理'); insert into s_position(name,description) values('普通员工','普通员工'); #插入表depart_posinsert into depart_pos(department_id,position_id) select a.id department_id,b.id postion_id from department a,s_position b; #插入表staffer insert into staffer(name,department_id,position_id) values('陈达治',1,1); insert into staffer(name,department_id,position_id) values('李文宾',1,2); insert into staffer(name,department_id,position_id) values('马佳',1,3); insert into staffer(name,department_id,position_id) values('亢志强',5,1); insert into staffer(name,department_id,position_id) values('杨玉茹',4,1); 6)查询及删除操作select、delete命令1234567891011121314151617181920#显示系统部的人员和职位 select a.name,b.name department_name,c.name position_name from staffer a,department b,s_position c where a.department_id=b.id and a.position_id=c.id and b.name='系统部'; #显示系统部的人数 select count(*) from staffer a,department b where a.department_id=b.id and b.name='系统部' #显示各部门的人数 select count(*) cou,b.name from staffer a,department b where a.department_id=b.id group by b.name; #删除客服部 delete from department where name='客服部'; #将财务部修改为财务一部 update department set name='财务一部' where name='财务部'; 7)备份和恢复12#备份数据库staffer c:\mysql\bin\mysqldump -uroot -proot staffer&gt;e:\staffer.sql 得到的staffer.sql是一个sql脚本，不包括建库的语句，所以你需要手工创建数据库才可以导入 恢复数据库staffer,需要创建一个空库staffer1c:\mysql\bin\mysql -uroot -proot staffer&lt;staffer.sql 如果不希望后来手工创建staffer,可以12c:\mysql\bin\mysqldump -uroot -proot --databases staffer&gt;e:\staffer.sql mysql -uroot -proot \&gt;e:\\staffer.sql 但这样的话系统种就不能存在staffer库，且无法导入其他名字的数据库，当然你可以手工修改staffer.sql文件]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL查询语句执行顺序]]></title>
    <url>%2F2017%2F12%2F04%2FSQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[SQL查询语句执行顺序 SELECT DISTINCT FROM JOIN ON WHERE ON WHERE GROUP BY HAVING ORDER BY LIMIT 实例前期准备工作 1、新建一个测试数据库create database testData; 2、创建测试表,并插入数据如下： 用户表 订单表 准备SQL逻辑查询测试语句12345678SELECT a.user_id,COUNT(b.order_id) as total_orders FROM user as a LEFT JOIN orders as b ON a.user_id = b.user_id WHERE a.city = 'beijing' GROUP BY a.user_id HAVING COUNT(b.order_id) &lt; 2 ORDER BY total_orders desc 使用上述SQL查询语句来获得来自北京，并且订单数少于2的客户;在这些SQL语句的执行过程中，都会产生一个虚拟表，用来保存SQL语句的执行结果 一、执行FROM语句 第一步，执行FROM语句。我们首先需要知道最开始从哪个表开始的，这就是FROM告诉我们的。现在有了和两个表，我们到底从哪个表开始，还是从两个表进行某种联系以后再开始呢？它们之间如何产生联系呢？—笛卡尔积 经过FROM语句对两个表执行笛卡尔积，会得到一个虚拟表，VT1（vitual table1），内容如下： 总共有28（user的记录条数 *orders的记录条数）条记录。这就是VT1的结果，接下来的操作就在VT1的基础上进行 二、执行ON过滤 执行完笛卡尔积以后，接着就进行ON a.user_id = b.user_id条件过滤，根据ON中指定的条件，去掉那些不符合条件的数据,得到VT2如下： select * from user as a inner JOIN orders as b ON a.user_id = b.user_id; 三、添加外部行 这一步只有在连接类型为OUTER JOIN时才发生，如LEFT OUTER JOIN、RIGHT OUTER JOIN和FULL OUTER JOIN。在大多数的时候，我们都是会省略掉OUTER关键字的，但OUTER表示的就是外部行的概念。 LEFT OUTER JOIN把左表记为保留表：即左表的数据会被全部查询，若右表中无对应数据，会用NULL来填充： RIGHT OUTER JOIN把右表记为保留表：即右表的数据会被全部查询出来，若左表中无对应数据，则用NULL补充； FULL OUTER JOIN把左右表都作为保留表，但在Mysql中不支持全连接，可以通过以下方式实现全连接：123select * from A left join B on A.id = B.id (where 条件） union select * from A right join B on A.id = B.id （where条件); 由于我在准备的测试SQL查询逻辑语句中使用的是LEFT JOIN，得到的VT3表如下： 四、执行where条件过滤 对添加了外部行的数据进行where条件过滤，只有符合\条件的记录会被筛选出来，执行WHERE a.city = ‘beijing’ 得到VT4如下： 但是在使用WHERE子句时，需要注意以下两点：1、由于数据还没有分组，因此现在还不能在where过滤条件中使用where_condition=MIN(col)这类对分组统计的过滤；2、由于还没有进行列的选取操作，因此在select中使用列的别名也是不被允许的，如：select city as c from table1 wherec=’beijing’ 是不允许的 五、执行group by分组语句 GROU BY子句主要是对使用WHERE子句得到的虚拟表进行分组操作，执行GROUP BY a.user_id 得到VT5如下： 六、执行having HAVING子句主要和GROUP BY子句配合使用，对分组得到VT5的数据进行条件过滤，执行 HAVING COUNT(b.order_id)&lt; 2，得到VT6如下： 七、select列表 现在才会执行到SELECT子句，不要以为SELECT子句被写在第一行，就是第一个被执行的。我们执行测试语句中的SELECT a.user_id,user_name,COUNT(b.order_id) as total_orders，从VT6中选择出我们需要的内容，得到VT7如下： 八、执行distinct去重复数据 如果在查询中指定了DISTINCT子句，则会创建一张内存临时表（如果内存放不下，就需要存放在硬盘了）。这张临时表的表结构和上一步产生的虚拟表是一样的，不同的是对进行DISTINCT操作的列增加了一个唯一索引，以此来除重复数据。测试SQL中没有DISTINCT字句，所以不会执行 九、执行order by字句 对虚拟表VT7中的内容按照指定的列进行排序，然后返回一个新的虚拟表，我们执行测试SQL语句中的ORDER BY total_orders DESC ，得到结果如下： DESC倒序排序，ASC升序排序 十、执行LIMIT子句 LIMIT子句从上一步得到的VT8虚拟表中选出从指定位置开始的指定行数据。对于没有应用ORDERBY的LIMIT子句，得到的结果同样是无序的，所以很多时候都会看到LIMIT子句会和ORDERBY子句一起使用。]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批处理命令介绍]]></title>
    <url>%2F2017%2F12%2F04%2F%E6%89%B9%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[批处理介绍批处理（Batch）是一种简化的脚本语言，它应用于DOS和Windows系统中，它是由DOS或者Windows系统内嵌的命令解释器（通常是COMMAND.COM或者CMD.EXE）解释运行。类似于Unix中的Shell脚本。批处理文件具有.bat或者.cmd的扩展名，其最简单的例子，是逐行书写在命令行中会用到的各种命令。更复杂的情况，需要使用if，for，goto等命令控制程序的运行过程，如同C，Basic等高级语言一样。如果需要实现更复杂的应用，利用外部程序是必要的，这包括系统本身提供的外部命令和第三方提供的工具或者软件。批处理程序虽然是在命令行环境中运行，但不仅仅能使用命令行软件，任何32位的Windows程序都可以放在批处理文件中运行。 windows下主要的批处理命令echo：用于在屏幕显示文字信息命令格式： 1echo [&#123;on|off&#125;][message] 参数说明： on：允许批处理文件在执行的过程中显示命令。off：禁止…………………………………………。message：表示需要显示在屏幕上的信息。 实例： 我把前面创建的1.bat修改为如下几条指令，先打开echo，然后ver显示系统版本，然后path一下显示环境变量，然后关闭echo，再做一遍。我们来看看有什么区别。 我们清楚得看到，echooff之后的ver和path就没有显示在屏幕上了，而他们的执行结果就顺序连接在一起了。 @：用于屏蔽执行的命令显示在屏幕上 命令格式：@[command] 参数说明： command：要屏蔽的显示命令。 goto：指定跳转到标签，找到标签后，程序将处理从下一行开始的命令命令格式：goto label 参数说明： label：一个标记罢了。 实例： 继续上面的例子，我在ver和path之间放了一个label，然后在echo on后面增加语句gotolabel，这样我希望的是跳过ver语句。（这里需要注意，label以:开头并紧跟标识符，其实也可以不以:开头，但为了下面的call语句统一，建议标签都以:开头。标识符不能有逗号、冒号等，但可以有空格，有效长度是8位，超过的将忽略8位之后的部分） 123456789101112@echo off :start cls set /p numis=请输入数字1或2： if /i "%numis%"=="1" goto 1 if /i "%numis%"=="2" (goto 2) else (echo 输入有误!&amp;&amp;pause&gt;nul&amp;&amp;goto start) :1 echo 你输入的是1 pause&gt;nul&amp;&amp;goto start :2 echo 你输入的是2 pause&gt;nul&amp;&amp;goto start pause：用于暂停命令格式：pause 参数说明： 没有参数。 实例： 还是上面的例子，我在ver之后放置一个pause命令看看会发生什么。 它在执行了ver命令后，继续执行pause命令，然后就暂停了，按任意键继续，按ctrl+c就直接结束了，不执行之后的命令。 call：允许在一个批处理文件中调用另外一个批处理文件命令格式：1call [绝对路径]Filename 或者 [:label] 参数说明： [绝对路径]Filename：另一个批处理文件。[:label]：像goto一样，call也可以跳到某个标签之后执行。 实例： 这次我需要两个批处理文件，于是我在目录下又建了一个2.bat，里面就放了两条命令，一个path，一个ver。然后我修改了1.bat，让它先调用2.bat，然后跳到我在1.bat中ver之后放置的cc标识符处执行。 我们看到，这里的执行大部分都按照我们的想法在做，为什么我说大部分而不是全部呢？因为我们发现call跳到cc之后执行了path后，结果又回到call:cc执行继续执行了一遍，相当于跳到一个地方做完事情后又回到原地方继续往下做，这样，我们的path命令就被执行了两次。 start：用于启动一个单独的命令行窗口命令格式： 1234START ["title"] [/Dpath] [/I] [/MIN] [/MAX] [/SEPARATE | /SHARED] [/LOW | /NORMAL | /HIGH | /REALTIME | /ABOVENORMAL | /BELOWNORMAL] [/WAIT] [/B] [command/program] [parameters] 参数说明： “title”：在窗口标题栏中显示的标题。path：起始目录。B：在不创建新窗口的情况下开始应用程序。 除非启动 ^C 处理，否则该应用程序会忽略 ^C 处理；^Break 是唯一可以中断该应用程序的方式。I：新环境是传递给 cmd.exe 的原始环境，而不是当前环境。MIN：开始时窗口最小化。MAX：开始时窗口最大化。SEPARATE：在分开的空间内开始 16 位 Windows 程序。SHARED：在分共享的空间内开始 16 位 Windows 程序。LOW：在 IDLE 优先级类别开始应用程序。NORMAL：在 NORMAL 优先级类别开始应用程序。HIGH：在 HIGH 优先级类别开始应用程序。REALTIME：在 REALTIME 优先级类别开始应用程序。ABOVENORMAL：在 ABOVENORMAL 优先级类别开始应用程序。BELOWNORMAL：在 BELOWNORMAL 优先级类别开始应用程序。WAIT：启动应用程序并等候它结束。command/program：如果是内部 cmd 命令或批文件，那么该命令处理器是用 /K 命令行开关运行 cmd.exe 的。这表示该窗口在命令运行后仍然存在。如果不是内部 cmd命令或批文件，则是一个程序，并作为窗口应用程序或控制台应用程序运行。parameters 这些为传送到命令/程序的参数。 实例： 继续修改上述的第一个批处理文件，让他启动一个新的命令行窗口并执行2.bat文件 当然，对于上述的各种参数，你完全可以自己慢慢摸索，这也是一个慢慢熟悉的过程。 rem：注释命令格式：rem [comment] 参数说明： comment：注释。 实例： 修改1.bat，在ver和path中插入一个rem行的注释，可以看到它也显示在命令行窗口了，可以用echooff命令让他不显示出来。 if：条件判断命令格式： 123IF [NOT] ERRORLEVEL number command IF [NOT] string1==string2 command IF [NOT] EXIST filename command 参数说明： NOT：指定只有条件为 false 的情况下， Windows XP 才应该执行该命令。ERRORLEVEnumber：如果最后运行的程序返回一个等于或大于指定数字的退出编码，指定条件为true。string1==string2：如果指定的文字字符串匹配，指定条件为 true。EXIST filename：如果指定的文件名存在，指定条件为 true。command：如果符合条件，指定要执行的命令。如果指定的条件为FALSE，命令后可跟一个执行 ELSE关键字后的命令的 ELSE 命令。 set：定义变量和设置环境命令格式： 1SET [variable=[string]] 参数说明： variable：指定环境变量名。string：指定要指派给变量的一系列字符串。 实例： 修改1.bat，把2.bat作为变量xxx的值，然后在if判断里直接判断是否存在xxx这个变量，如下： shift：移位命令格式： 1shift [/n] 参数说明： /n：设置批处理从第n个参数开始移位，n的值为0～8。 实例： 修改1.bat文件，设置了两个标签，%0~%9用来获取参数的，如下我输入的命令为：1.bat1.bat2.bat，那么%0就是1.bat，%1是1.bat，%2是2.bat。这个批处理文件的作用是先判断第一个参数是否为空，如果不为空就显示其内容，然后循环移动参数，直到参数为空。shift起到的作用就是移动参数。 for：循环语句命令格式： 1FOR %variable IN (set) DO command [command-parameters] 参数说明： %variable：指定一个单一字母可替换的参数。(set)：指定一个或一组文件。可以使用通配符。command：指定对每个文件执行的命令。command-parameters：为特定命令指定参数或命令行开关。 实例： 修改1.bat，在当前目录下循环查找.bat结尾的文件，找到一个显示一个，并把变量sum+1]]></content>
      <categories>
        <category>学习随笔</category>
      </categories>
      <tags>
        <tag>bat</tag>
      </tags>
  </entry>
</search>
